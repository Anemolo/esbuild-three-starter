/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@unseenco/e/src/e.js":
/*!*******************************************!*\
  !*** ./node_modules/@unseenco/e/src/e.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ E)\n/* harmony export */ });\n/* harmony import */ var selector_set__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! selector-set */ \"./node_modules/selector-set/selector-set.next.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./node_modules/@unseenco/e/src/utils.js\");\n\n\nclass E {\n  bindAll(context, methods) {\n    if (methods === void 0) {\n      methods = Object.getOwnPropertyNames(Object.getPrototypeOf(context));\n    }\n    for (let i = 0; i < methods.length; i++) {\n      context[methods[i]] = context[methods[i]].bind(context);\n    }\n  }\n  on(event, el, callback, options) {\n    const events = event.split(\" \");\n    for (let i = 0; i < events.length; i++) {\n      if (typeof el === \"function\" && callback === void 0) {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.makeBusStack)(events[i]);\n        _utils__WEBPACK_IMPORTED_MODULE_1__.listeners[events[i]].push(el);\n        continue;\n      }\n      if (el.nodeType && el.nodeType === 1 || el === window || el === document) {\n        el.addEventListener(events[i], callback, options);\n        continue;\n      }\n      el = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.maybeRunQuerySelector)(el);\n      for (let n = 0; n < el.length; n++) {\n        el[n].addEventListener(events[i], callback, options);\n      }\n    }\n  }\n  delegate(event, delegate, callback) {\n    const events = event.split(\" \");\n    for (let i = 0; i < events.length; i++) {\n      let map = _utils__WEBPACK_IMPORTED_MODULE_1__.eventTypes[events[i]];\n      if (map === void 0) {\n        map = new selector_set__WEBPACK_IMPORTED_MODULE_0__.default();\n        _utils__WEBPACK_IMPORTED_MODULE_1__.eventTypes[events[i]] = map;\n        if (_utils__WEBPACK_IMPORTED_MODULE_1__.nonBubblers.indexOf(events[i]) !== -1) {\n          document.addEventListener(events[i], _utils__WEBPACK_IMPORTED_MODULE_1__.handleDelegation, true);\n        } else {\n          document.addEventListener(events[i], _utils__WEBPACK_IMPORTED_MODULE_1__.handleDelegation);\n        }\n      }\n      map.add(delegate, callback);\n    }\n  }\n  off(event, el, callback, options) {\n    const events = event.split(\" \");\n    for (let i = 0; i < events.length; i++) {\n      if (el === void 0) {\n        _utils__WEBPACK_IMPORTED_MODULE_1__.listeners[events[i]] = [];\n        continue;\n      }\n      if (typeof el === \"function\") {\n        (0,_utils__WEBPACK_IMPORTED_MODULE_1__.makeBusStack)(events[i]);\n        for (let n = 0; n < _utils__WEBPACK_IMPORTED_MODULE_1__.listeners[events[i]].length; n++) {\n          if (_utils__WEBPACK_IMPORTED_MODULE_1__.listeners[events[i]][n] === el) {\n            _utils__WEBPACK_IMPORTED_MODULE_1__.listeners[events[i]].splice(n, 1);\n          }\n        }\n        continue;\n      }\n      const map = _utils__WEBPACK_IMPORTED_MODULE_1__.eventTypes[events[i]];\n      if (map !== void 0) {\n        map.remove(el, callback);\n        if (map.size === 0) {\n          delete _utils__WEBPACK_IMPORTED_MODULE_1__.eventTypes[events[i]];\n          document.removeEventListener(events[i], _utils__WEBPACK_IMPORTED_MODULE_1__.handleDelegation);\n          continue;\n        }\n      }\n      if (el.removeEventListener !== void 0) {\n        el.removeEventListener(events[i], callback, options);\n        continue;\n      }\n      el = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.maybeRunQuerySelector)(el);\n      for (let n = 0; n < el.length; n++) {\n        el[n].removeEventListener(events[i], callback, options);\n      }\n    }\n  }\n  emit(event, ...args) {\n    (0,_utils__WEBPACK_IMPORTED_MODULE_1__.triggerBus)(event, args);\n  }\n  debugDelegated() {\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.clone)(_utils__WEBPACK_IMPORTED_MODULE_1__.eventTypes);\n  }\n  debugBus() {\n    return (0,_utils__WEBPACK_IMPORTED_MODULE_1__.clone)(_utils__WEBPACK_IMPORTED_MODULE_1__.listeners);\n  }\n}\n\n\n//# sourceURL=webpack://esbuild-three-starter/./node_modules/@unseenco/e/src/e.js?");

/***/ }),

/***/ "./node_modules/@unseenco/e/src/utils.js":
/*!***********************************************!*\
  !*** ./node_modules/@unseenco/e/src/utils.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"eventTypes\": () => (/* binding */ eventTypes),\n/* harmony export */   \"listeners\": () => (/* binding */ listeners),\n/* harmony export */   \"nonBubblers\": () => (/* binding */ nonBubblers),\n/* harmony export */   \"makeBusStack\": () => (/* binding */ makeBusStack),\n/* harmony export */   \"triggerBus\": () => (/* binding */ triggerBus),\n/* harmony export */   \"maybeRunQuerySelector\": () => (/* binding */ maybeRunQuerySelector),\n/* harmony export */   \"handleDelegation\": () => (/* binding */ handleDelegation),\n/* harmony export */   \"clone\": () => (/* binding */ clone)\n/* harmony export */ });\nconst eventTypes = {};\nconst listeners = {};\nconst nonBubblers = [\"mouseenter\", \"mouseleave\"];\nfunction makeBusStack(event) {\n  if (listeners[event] === void 0) {\n    listeners[event] = [];\n  }\n}\nfunction triggerBus(event, args) {\n  if (listeners[event]) {\n    for (let i = 0; i < listeners[event].length; i++) {\n      listeners[event][i](...args);\n    }\n  }\n}\nfunction maybeRunQuerySelector(el) {\n  return typeof el === \"string\" ? document.querySelectorAll(el) : el;\n}\nfunction handleDelegation(e) {\n  let matches = traverse(eventTypes[e.type], e.target);\n  if (matches.length) {\n    for (let i = 0; i < matches.length; i++) {\n      for (let i2 = 0; i2 < matches[i].stack.length; i2++) {\n        if (nonBubblers.indexOf(e.type) !== -1) {\n          addDelegateTarget(e, matches[i].delegatedTarget);\n          if (e.target === matches[i].delegatedTarget) {\n            matches[i].stack[i2].data(e);\n          }\n        } else {\n          addDelegateTarget(e, matches[i].delegatedTarget);\n          matches[i].stack[i2].data(e);\n        }\n      }\n    }\n  }\n}\nfunction traverse(listeners2, target) {\n  const queue = [];\n  let node = target;\n  do {\n    if (node.nodeType !== 1) {\n      break;\n    }\n    const matches = listeners2.matches(node);\n    if (matches.length) {\n      queue.push({delegatedTarget: node, stack: matches});\n    }\n  } while (node = node.parentElement);\n  return queue;\n}\nfunction addDelegateTarget(event, delegatedTarget) {\n  Object.defineProperty(event, \"currentTarget\", {\n    configurable: true,\n    enumerable: true,\n    get: () => delegatedTarget\n  });\n}\nfunction clone(object) {\n  return JSON.parse(JSON.stringify(object));\n}\n\n\n\n//# sourceURL=webpack://esbuild-three-starter/./node_modules/@unseenco/e/src/utils.js?");

/***/ }),

/***/ "./node_modules/selector-set/selector-set.next.js":
/*!********************************************************!*\
  !*** ./node_modules/selector-set/selector-set.next.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ SelectorSet)\n/* harmony export */ });\nfunction SelectorSet() {\n  if (!(this instanceof SelectorSet)) {\n    return new SelectorSet();\n  }\n  this.size = 0;\n  this.uid = 0;\n  this.selectors = [];\n  this.selectorObjects = {};\n  this.indexes = Object.create(this.indexes);\n  this.activeIndexes = [];\n}\nvar docElem = window.document.documentElement;\nvar matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector;\nSelectorSet.prototype.matchesSelector = function(el, selector) {\n  return matches.call(el, selector);\n};\nSelectorSet.prototype.querySelectorAll = function(selectors, context) {\n  return context.querySelectorAll(selectors);\n};\nSelectorSet.prototype.indexes = [];\nvar idRe = /^#((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/g;\nSelectorSet.prototype.indexes.push({\n  name: \"ID\",\n  selector: function matchIdSelector(sel) {\n    var m;\n    if (m = sel.match(idRe)) {\n      return m[0].slice(1);\n    }\n  },\n  element: function getElementId(el) {\n    if (el.id) {\n      return [el.id];\n    }\n  }\n});\nvar classRe = /^\\.((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/g;\nSelectorSet.prototype.indexes.push({\n  name: \"CLASS\",\n  selector: function matchClassSelector(sel) {\n    var m;\n    if (m = sel.match(classRe)) {\n      return m[0].slice(1);\n    }\n  },\n  element: function getElementClassNames(el) {\n    var className = el.className;\n    if (className) {\n      if (typeof className === \"string\") {\n        return className.split(/\\s/);\n      } else if (typeof className === \"object\" && \"baseVal\" in className) {\n        return className.baseVal.split(/\\s/);\n      }\n    }\n  }\n});\nvar tagRe = /^((?:[\\w\\u00c0-\\uFFFF\\-]|\\\\.)+)/g;\nSelectorSet.prototype.indexes.push({\n  name: \"TAG\",\n  selector: function matchTagSelector(sel) {\n    var m;\n    if (m = sel.match(tagRe)) {\n      return m[0].toUpperCase();\n    }\n  },\n  element: function getElementTagName(el) {\n    return [el.nodeName.toUpperCase()];\n  }\n});\nSelectorSet.prototype.indexes[\"default\"] = {\n  name: \"UNIVERSAL\",\n  selector: function() {\n    return true;\n  },\n  element: function() {\n    return [true];\n  }\n};\nvar Map;\nif (typeof window.Map === \"function\") {\n  Map = window.Map;\n} else {\n  Map = function() {\n    function Map2() {\n      this.map = {};\n    }\n    Map2.prototype.get = function(key) {\n      return this.map[key + \" \"];\n    };\n    Map2.prototype.set = function(key, value) {\n      this.map[key + \" \"] = value;\n    };\n    return Map2;\n  }();\n}\nvar chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g;\nfunction parseSelectorIndexes(allIndexes, selector) {\n  allIndexes = allIndexes.slice(0).concat(allIndexes[\"default\"]);\n  var allIndexesLen = allIndexes.length, i, j, m, dup, rest = selector, key, index, indexes = [];\n  do {\n    chunker.exec(\"\");\n    if (m = chunker.exec(rest)) {\n      rest = m[3];\n      if (m[2] || !rest) {\n        for (i = 0; i < allIndexesLen; i++) {\n          index = allIndexes[i];\n          if (key = index.selector(m[1])) {\n            j = indexes.length;\n            dup = false;\n            while (j--) {\n              if (indexes[j].index === index && indexes[j].key === key) {\n                dup = true;\n                break;\n              }\n            }\n            if (!dup) {\n              indexes.push({index, key});\n            }\n            break;\n          }\n        }\n      }\n    }\n  } while (m);\n  return indexes;\n}\nfunction findByPrototype(ary, proto) {\n  var i, len, item;\n  for (i = 0, len = ary.length; i < len; i++) {\n    item = ary[i];\n    if (proto.isPrototypeOf(item)) {\n      return item;\n    }\n  }\n}\nSelectorSet.prototype.logDefaultIndexUsed = function() {\n};\nSelectorSet.prototype.add = function(selector, data) {\n  var obj, i, indexProto, key, index, objs, selectorIndexes, selectorIndex, indexes = this.activeIndexes, selectors = this.selectors, selectorObjects = this.selectorObjects;\n  if (typeof selector !== \"string\") {\n    return;\n  }\n  obj = {\n    id: this.uid++,\n    selector,\n    data\n  };\n  selectorObjects[obj.id] = obj;\n  selectorIndexes = parseSelectorIndexes(this.indexes, selector);\n  for (i = 0; i < selectorIndexes.length; i++) {\n    selectorIndex = selectorIndexes[i];\n    key = selectorIndex.key;\n    indexProto = selectorIndex.index;\n    index = findByPrototype(indexes, indexProto);\n    if (!index) {\n      index = Object.create(indexProto);\n      index.map = new Map();\n      indexes.push(index);\n    }\n    if (indexProto === this.indexes[\"default\"]) {\n      this.logDefaultIndexUsed(obj);\n    }\n    objs = index.map.get(key);\n    if (!objs) {\n      objs = [];\n      index.map.set(key, objs);\n    }\n    objs.push(obj);\n  }\n  this.size++;\n  selectors.push(selector);\n};\nSelectorSet.prototype.remove = function(selector, data) {\n  if (typeof selector !== \"string\") {\n    return;\n  }\n  var selectorIndexes, selectorIndex, i, j, k, selIndex, objs, obj, indexes = this.activeIndexes, selectors = this.selectors = [], selectorObjects = this.selectorObjects, removedIds = {}, removeAll = arguments.length === 1;\n  selectorIndexes = parseSelectorIndexes(this.indexes, selector);\n  for (i = 0; i < selectorIndexes.length; i++) {\n    selectorIndex = selectorIndexes[i];\n    j = indexes.length;\n    while (j--) {\n      selIndex = indexes[j];\n      if (selectorIndex.index.isPrototypeOf(selIndex)) {\n        objs = selIndex.map.get(selectorIndex.key);\n        if (objs) {\n          k = objs.length;\n          while (k--) {\n            obj = objs[k];\n            if (obj.selector === selector && (removeAll || obj.data === data)) {\n              objs.splice(k, 1);\n              removedIds[obj.id] = true;\n            }\n          }\n        }\n        break;\n      }\n    }\n  }\n  for (i in removedIds) {\n    delete selectorObjects[i];\n    this.size--;\n  }\n  for (i in selectorObjects) {\n    selectors.push(selectorObjects[i].selector);\n  }\n};\nfunction sortById(a, b) {\n  return a.id - b.id;\n}\nSelectorSet.prototype.queryAll = function(context) {\n  if (!this.selectors.length) {\n    return [];\n  }\n  var matches2 = {}, results = [];\n  var els = this.querySelectorAll(this.selectors.join(\", \"), context);\n  var i, j, len, len2, el, m, match, obj;\n  for (i = 0, len = els.length; i < len; i++) {\n    el = els[i];\n    m = this.matches(el);\n    for (j = 0, len2 = m.length; j < len2; j++) {\n      obj = m[j];\n      if (!matches2[obj.id]) {\n        match = {\n          id: obj.id,\n          selector: obj.selector,\n          data: obj.data,\n          elements: []\n        };\n        matches2[obj.id] = match;\n        results.push(match);\n      } else {\n        match = matches2[obj.id];\n      }\n      match.elements.push(el);\n    }\n  }\n  return results.sort(sortById);\n};\nSelectorSet.prototype.matches = function(el) {\n  if (!el) {\n    return [];\n  }\n  var i, j, k, len, len2, len3, index, keys, objs, obj, id;\n  var indexes = this.activeIndexes, matchedIds = {}, matches2 = [];\n  for (i = 0, len = indexes.length; i < len; i++) {\n    index = indexes[i];\n    keys = index.element(el);\n    if (keys) {\n      for (j = 0, len2 = keys.length; j < len2; j++) {\n        if (objs = index.map.get(keys[j])) {\n          for (k = 0, len3 = objs.length; k < len3; k++) {\n            obj = objs[k];\n            id = obj.id;\n            if (!matchedIds[id] && this.matchesSelector(el, obj.selector)) {\n              matchedIds[id] = true;\n              matches2.push(obj);\n            }\n          }\n        }\n      }\n    }\n  }\n  return matches2.sort(sortById);\n};\n\n\n//# sourceURL=webpack://esbuild-three-starter/./node_modules/selector-set/selector-set.next.js?");

/***/ }),

/***/ "./node_modules/three/build/three.module.js":
/*!**************************************************!*\
  !*** ./node_modules/three/build/three.module.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ACESFilmicToneMapping\": () => (/* binding */ ACESFilmicToneMapping),\n/* harmony export */   \"AddEquation\": () => (/* binding */ AddEquation),\n/* harmony export */   \"AddOperation\": () => (/* binding */ AddOperation),\n/* harmony export */   \"AdditiveAnimationBlendMode\": () => (/* binding */ AdditiveAnimationBlendMode),\n/* harmony export */   \"AdditiveBlending\": () => (/* binding */ AdditiveBlending),\n/* harmony export */   \"AlphaFormat\": () => (/* binding */ AlphaFormat),\n/* harmony export */   \"AlwaysDepth\": () => (/* binding */ AlwaysDepth),\n/* harmony export */   \"AlwaysStencilFunc\": () => (/* binding */ AlwaysStencilFunc),\n/* harmony export */   \"AmbientLight\": () => (/* binding */ AmbientLight),\n/* harmony export */   \"AmbientLightProbe\": () => (/* binding */ AmbientLightProbe),\n/* harmony export */   \"AnimationClip\": () => (/* binding */ AnimationClip),\n/* harmony export */   \"AnimationLoader\": () => (/* binding */ AnimationLoader),\n/* harmony export */   \"AnimationMixer\": () => (/* binding */ AnimationMixer),\n/* harmony export */   \"AnimationObjectGroup\": () => (/* binding */ AnimationObjectGroup),\n/* harmony export */   \"AnimationUtils\": () => (/* binding */ AnimationUtils),\n/* harmony export */   \"ArcCurve\": () => (/* binding */ ArcCurve),\n/* harmony export */   \"ArrayCamera\": () => (/* binding */ ArrayCamera),\n/* harmony export */   \"ArrowHelper\": () => (/* binding */ ArrowHelper),\n/* harmony export */   \"Audio\": () => (/* binding */ Audio),\n/* harmony export */   \"AudioAnalyser\": () => (/* binding */ AudioAnalyser),\n/* harmony export */   \"AudioContext\": () => (/* binding */ AudioContext),\n/* harmony export */   \"AudioListener\": () => (/* binding */ AudioListener),\n/* harmony export */   \"AudioLoader\": () => (/* binding */ AudioLoader),\n/* harmony export */   \"AxesHelper\": () => (/* binding */ AxesHelper),\n/* harmony export */   \"AxisHelper\": () => (/* binding */ AxisHelper),\n/* harmony export */   \"BackSide\": () => (/* binding */ BackSide),\n/* harmony export */   \"BasicDepthPacking\": () => (/* binding */ BasicDepthPacking),\n/* harmony export */   \"BasicShadowMap\": () => (/* binding */ BasicShadowMap),\n/* harmony export */   \"BinaryTextureLoader\": () => (/* binding */ BinaryTextureLoader),\n/* harmony export */   \"Bone\": () => (/* binding */ Bone),\n/* harmony export */   \"BooleanKeyframeTrack\": () => (/* binding */ BooleanKeyframeTrack),\n/* harmony export */   \"BoundingBoxHelper\": () => (/* binding */ BoundingBoxHelper),\n/* harmony export */   \"Box2\": () => (/* binding */ Box2),\n/* harmony export */   \"Box3\": () => (/* binding */ Box3),\n/* harmony export */   \"Box3Helper\": () => (/* binding */ Box3Helper),\n/* harmony export */   \"BoxBufferGeometry\": () => (/* binding */ BoxGeometry),\n/* harmony export */   \"BoxGeometry\": () => (/* binding */ BoxGeometry),\n/* harmony export */   \"BoxHelper\": () => (/* binding */ BoxHelper),\n/* harmony export */   \"BufferAttribute\": () => (/* binding */ BufferAttribute),\n/* harmony export */   \"BufferGeometry\": () => (/* binding */ BufferGeometry),\n/* harmony export */   \"BufferGeometryLoader\": () => (/* binding */ BufferGeometryLoader),\n/* harmony export */   \"ByteType\": () => (/* binding */ ByteType),\n/* harmony export */   \"Cache\": () => (/* binding */ Cache),\n/* harmony export */   \"Camera\": () => (/* binding */ Camera),\n/* harmony export */   \"CameraHelper\": () => (/* binding */ CameraHelper),\n/* harmony export */   \"CanvasRenderer\": () => (/* binding */ CanvasRenderer),\n/* harmony export */   \"CanvasTexture\": () => (/* binding */ CanvasTexture),\n/* harmony export */   \"CatmullRomCurve3\": () => (/* binding */ CatmullRomCurve3),\n/* harmony export */   \"CineonToneMapping\": () => (/* binding */ CineonToneMapping),\n/* harmony export */   \"CircleBufferGeometry\": () => (/* binding */ CircleGeometry),\n/* harmony export */   \"CircleGeometry\": () => (/* binding */ CircleGeometry),\n/* harmony export */   \"ClampToEdgeWrapping\": () => (/* binding */ ClampToEdgeWrapping),\n/* harmony export */   \"Clock\": () => (/* binding */ Clock),\n/* harmony export */   \"Color\": () => (/* binding */ Color),\n/* harmony export */   \"ColorKeyframeTrack\": () => (/* binding */ ColorKeyframeTrack),\n/* harmony export */   \"CompressedTexture\": () => (/* binding */ CompressedTexture),\n/* harmony export */   \"CompressedTextureLoader\": () => (/* binding */ CompressedTextureLoader),\n/* harmony export */   \"ConeBufferGeometry\": () => (/* binding */ ConeGeometry),\n/* harmony export */   \"ConeGeometry\": () => (/* binding */ ConeGeometry),\n/* harmony export */   \"CubeCamera\": () => (/* binding */ CubeCamera),\n/* harmony export */   \"CubeReflectionMapping\": () => (/* binding */ CubeReflectionMapping),\n/* harmony export */   \"CubeRefractionMapping\": () => (/* binding */ CubeRefractionMapping),\n/* harmony export */   \"CubeTexture\": () => (/* binding */ CubeTexture),\n/* harmony export */   \"CubeTextureLoader\": () => (/* binding */ CubeTextureLoader),\n/* harmony export */   \"CubeUVReflectionMapping\": () => (/* binding */ CubeUVReflectionMapping),\n/* harmony export */   \"CubeUVRefractionMapping\": () => (/* binding */ CubeUVRefractionMapping),\n/* harmony export */   \"CubicBezierCurve\": () => (/* binding */ CubicBezierCurve),\n/* harmony export */   \"CubicBezierCurve3\": () => (/* binding */ CubicBezierCurve3),\n/* harmony export */   \"CubicInterpolant\": () => (/* binding */ CubicInterpolant),\n/* harmony export */   \"CullFaceBack\": () => (/* binding */ CullFaceBack),\n/* harmony export */   \"CullFaceFront\": () => (/* binding */ CullFaceFront),\n/* harmony export */   \"CullFaceFrontBack\": () => (/* binding */ CullFaceFrontBack),\n/* harmony export */   \"CullFaceNone\": () => (/* binding */ CullFaceNone),\n/* harmony export */   \"Curve\": () => (/* binding */ Curve),\n/* harmony export */   \"CurvePath\": () => (/* binding */ CurvePath),\n/* harmony export */   \"CustomBlending\": () => (/* binding */ CustomBlending),\n/* harmony export */   \"CustomToneMapping\": () => (/* binding */ CustomToneMapping),\n/* harmony export */   \"CylinderBufferGeometry\": () => (/* binding */ CylinderGeometry),\n/* harmony export */   \"CylinderGeometry\": () => (/* binding */ CylinderGeometry),\n/* harmony export */   \"Cylindrical\": () => (/* binding */ Cylindrical),\n/* harmony export */   \"DataTexture\": () => (/* binding */ DataTexture),\n/* harmony export */   \"DataTexture2DArray\": () => (/* binding */ DataTexture2DArray),\n/* harmony export */   \"DataTexture3D\": () => (/* binding */ DataTexture3D),\n/* harmony export */   \"DataTextureLoader\": () => (/* binding */ DataTextureLoader),\n/* harmony export */   \"DataUtils\": () => (/* binding */ DataUtils),\n/* harmony export */   \"DecrementStencilOp\": () => (/* binding */ DecrementStencilOp),\n/* harmony export */   \"DecrementWrapStencilOp\": () => (/* binding */ DecrementWrapStencilOp),\n/* harmony export */   \"DefaultLoadingManager\": () => (/* binding */ DefaultLoadingManager),\n/* harmony export */   \"DepthFormat\": () => (/* binding */ DepthFormat),\n/* harmony export */   \"DepthStencilFormat\": () => (/* binding */ DepthStencilFormat),\n/* harmony export */   \"DepthTexture\": () => (/* binding */ DepthTexture),\n/* harmony export */   \"DirectionalLight\": () => (/* binding */ DirectionalLight),\n/* harmony export */   \"DirectionalLightHelper\": () => (/* binding */ DirectionalLightHelper),\n/* harmony export */   \"DiscreteInterpolant\": () => (/* binding */ DiscreteInterpolant),\n/* harmony export */   \"DodecahedronBufferGeometry\": () => (/* binding */ DodecahedronGeometry),\n/* harmony export */   \"DodecahedronGeometry\": () => (/* binding */ DodecahedronGeometry),\n/* harmony export */   \"DoubleSide\": () => (/* binding */ DoubleSide),\n/* harmony export */   \"DstAlphaFactor\": () => (/* binding */ DstAlphaFactor),\n/* harmony export */   \"DstColorFactor\": () => (/* binding */ DstColorFactor),\n/* harmony export */   \"DynamicBufferAttribute\": () => (/* binding */ DynamicBufferAttribute),\n/* harmony export */   \"DynamicCopyUsage\": () => (/* binding */ DynamicCopyUsage),\n/* harmony export */   \"DynamicDrawUsage\": () => (/* binding */ DynamicDrawUsage),\n/* harmony export */   \"DynamicReadUsage\": () => (/* binding */ DynamicReadUsage),\n/* harmony export */   \"EdgesGeometry\": () => (/* binding */ EdgesGeometry),\n/* harmony export */   \"EdgesHelper\": () => (/* binding */ EdgesHelper),\n/* harmony export */   \"EllipseCurve\": () => (/* binding */ EllipseCurve),\n/* harmony export */   \"EqualDepth\": () => (/* binding */ EqualDepth),\n/* harmony export */   \"EqualStencilFunc\": () => (/* binding */ EqualStencilFunc),\n/* harmony export */   \"EquirectangularReflectionMapping\": () => (/* binding */ EquirectangularReflectionMapping),\n/* harmony export */   \"EquirectangularRefractionMapping\": () => (/* binding */ EquirectangularRefractionMapping),\n/* harmony export */   \"Euler\": () => (/* binding */ Euler),\n/* harmony export */   \"EventDispatcher\": () => (/* binding */ EventDispatcher),\n/* harmony export */   \"ExtrudeBufferGeometry\": () => (/* binding */ ExtrudeGeometry),\n/* harmony export */   \"ExtrudeGeometry\": () => (/* binding */ ExtrudeGeometry),\n/* harmony export */   \"FaceColors\": () => (/* binding */ FaceColors),\n/* harmony export */   \"FileLoader\": () => (/* binding */ FileLoader),\n/* harmony export */   \"FlatShading\": () => (/* binding */ FlatShading),\n/* harmony export */   \"Float16BufferAttribute\": () => (/* binding */ Float16BufferAttribute),\n/* harmony export */   \"Float32Attribute\": () => (/* binding */ Float32Attribute),\n/* harmony export */   \"Float32BufferAttribute\": () => (/* binding */ Float32BufferAttribute),\n/* harmony export */   \"Float64Attribute\": () => (/* binding */ Float64Attribute),\n/* harmony export */   \"Float64BufferAttribute\": () => (/* binding */ Float64BufferAttribute),\n/* harmony export */   \"FloatType\": () => (/* binding */ FloatType),\n/* harmony export */   \"Fog\": () => (/* binding */ Fog),\n/* harmony export */   \"FogExp2\": () => (/* binding */ FogExp2),\n/* harmony export */   \"Font\": () => (/* binding */ Font),\n/* harmony export */   \"FontLoader\": () => (/* binding */ FontLoader),\n/* harmony export */   \"FrontSide\": () => (/* binding */ FrontSide),\n/* harmony export */   \"Frustum\": () => (/* binding */ Frustum),\n/* harmony export */   \"GLBufferAttribute\": () => (/* binding */ GLBufferAttribute),\n/* harmony export */   \"GLSL1\": () => (/* binding */ GLSL1),\n/* harmony export */   \"GLSL3\": () => (/* binding */ GLSL3),\n/* harmony export */   \"GammaEncoding\": () => (/* binding */ GammaEncoding),\n/* harmony export */   \"GreaterDepth\": () => (/* binding */ GreaterDepth),\n/* harmony export */   \"GreaterEqualDepth\": () => (/* binding */ GreaterEqualDepth),\n/* harmony export */   \"GreaterEqualStencilFunc\": () => (/* binding */ GreaterEqualStencilFunc),\n/* harmony export */   \"GreaterStencilFunc\": () => (/* binding */ GreaterStencilFunc),\n/* harmony export */   \"GridHelper\": () => (/* binding */ GridHelper),\n/* harmony export */   \"Group\": () => (/* binding */ Group),\n/* harmony export */   \"HalfFloatType\": () => (/* binding */ HalfFloatType),\n/* harmony export */   \"HemisphereLight\": () => (/* binding */ HemisphereLight),\n/* harmony export */   \"HemisphereLightHelper\": () => (/* binding */ HemisphereLightHelper),\n/* harmony export */   \"HemisphereLightProbe\": () => (/* binding */ HemisphereLightProbe),\n/* harmony export */   \"IcosahedronBufferGeometry\": () => (/* binding */ IcosahedronGeometry),\n/* harmony export */   \"IcosahedronGeometry\": () => (/* binding */ IcosahedronGeometry),\n/* harmony export */   \"ImageBitmapLoader\": () => (/* binding */ ImageBitmapLoader),\n/* harmony export */   \"ImageLoader\": () => (/* binding */ ImageLoader),\n/* harmony export */   \"ImageUtils\": () => (/* binding */ ImageUtils),\n/* harmony export */   \"ImmediateRenderObject\": () => (/* binding */ ImmediateRenderObject),\n/* harmony export */   \"IncrementStencilOp\": () => (/* binding */ IncrementStencilOp),\n/* harmony export */   \"IncrementWrapStencilOp\": () => (/* binding */ IncrementWrapStencilOp),\n/* harmony export */   \"InstancedBufferAttribute\": () => (/* binding */ InstancedBufferAttribute),\n/* harmony export */   \"InstancedBufferGeometry\": () => (/* binding */ InstancedBufferGeometry),\n/* harmony export */   \"InstancedInterleavedBuffer\": () => (/* binding */ InstancedInterleavedBuffer),\n/* harmony export */   \"InstancedMesh\": () => (/* binding */ InstancedMesh),\n/* harmony export */   \"Int16Attribute\": () => (/* binding */ Int16Attribute),\n/* harmony export */   \"Int16BufferAttribute\": () => (/* binding */ Int16BufferAttribute),\n/* harmony export */   \"Int32Attribute\": () => (/* binding */ Int32Attribute),\n/* harmony export */   \"Int32BufferAttribute\": () => (/* binding */ Int32BufferAttribute),\n/* harmony export */   \"Int8Attribute\": () => (/* binding */ Int8Attribute),\n/* harmony export */   \"Int8BufferAttribute\": () => (/* binding */ Int8BufferAttribute),\n/* harmony export */   \"IntType\": () => (/* binding */ IntType),\n/* harmony export */   \"InterleavedBuffer\": () => (/* binding */ InterleavedBuffer),\n/* harmony export */   \"InterleavedBufferAttribute\": () => (/* binding */ InterleavedBufferAttribute),\n/* harmony export */   \"Interpolant\": () => (/* binding */ Interpolant),\n/* harmony export */   \"InterpolateDiscrete\": () => (/* binding */ InterpolateDiscrete),\n/* harmony export */   \"InterpolateLinear\": () => (/* binding */ InterpolateLinear),\n/* harmony export */   \"InterpolateSmooth\": () => (/* binding */ InterpolateSmooth),\n/* harmony export */   \"InvertStencilOp\": () => (/* binding */ InvertStencilOp),\n/* harmony export */   \"JSONLoader\": () => (/* binding */ JSONLoader),\n/* harmony export */   \"KeepStencilOp\": () => (/* binding */ KeepStencilOp),\n/* harmony export */   \"KeyframeTrack\": () => (/* binding */ KeyframeTrack),\n/* harmony export */   \"LOD\": () => (/* binding */ LOD),\n/* harmony export */   \"LatheBufferGeometry\": () => (/* binding */ LatheGeometry),\n/* harmony export */   \"LatheGeometry\": () => (/* binding */ LatheGeometry),\n/* harmony export */   \"Layers\": () => (/* binding */ Layers),\n/* harmony export */   \"LensFlare\": () => (/* binding */ LensFlare),\n/* harmony export */   \"LessDepth\": () => (/* binding */ LessDepth),\n/* harmony export */   \"LessEqualDepth\": () => (/* binding */ LessEqualDepth),\n/* harmony export */   \"LessEqualStencilFunc\": () => (/* binding */ LessEqualStencilFunc),\n/* harmony export */   \"LessStencilFunc\": () => (/* binding */ LessStencilFunc),\n/* harmony export */   \"Light\": () => (/* binding */ Light),\n/* harmony export */   \"LightProbe\": () => (/* binding */ LightProbe),\n/* harmony export */   \"Line\": () => (/* binding */ Line),\n/* harmony export */   \"Line3\": () => (/* binding */ Line3),\n/* harmony export */   \"LineBasicMaterial\": () => (/* binding */ LineBasicMaterial),\n/* harmony export */   \"LineCurve\": () => (/* binding */ LineCurve),\n/* harmony export */   \"LineCurve3\": () => (/* binding */ LineCurve3),\n/* harmony export */   \"LineDashedMaterial\": () => (/* binding */ LineDashedMaterial),\n/* harmony export */   \"LineLoop\": () => (/* binding */ LineLoop),\n/* harmony export */   \"LinePieces\": () => (/* binding */ LinePieces),\n/* harmony export */   \"LineSegments\": () => (/* binding */ LineSegments),\n/* harmony export */   \"LineStrip\": () => (/* binding */ LineStrip),\n/* harmony export */   \"LinearEncoding\": () => (/* binding */ LinearEncoding),\n/* harmony export */   \"LinearFilter\": () => (/* binding */ LinearFilter),\n/* harmony export */   \"LinearInterpolant\": () => (/* binding */ LinearInterpolant),\n/* harmony export */   \"LinearMipMapLinearFilter\": () => (/* binding */ LinearMipMapLinearFilter),\n/* harmony export */   \"LinearMipMapNearestFilter\": () => (/* binding */ LinearMipMapNearestFilter),\n/* harmony export */   \"LinearMipmapLinearFilter\": () => (/* binding */ LinearMipmapLinearFilter),\n/* harmony export */   \"LinearMipmapNearestFilter\": () => (/* binding */ LinearMipmapNearestFilter),\n/* harmony export */   \"LinearToneMapping\": () => (/* binding */ LinearToneMapping),\n/* harmony export */   \"Loader\": () => (/* binding */ Loader),\n/* harmony export */   \"LoaderUtils\": () => (/* binding */ LoaderUtils),\n/* harmony export */   \"LoadingManager\": () => (/* binding */ LoadingManager),\n/* harmony export */   \"LogLuvEncoding\": () => (/* binding */ LogLuvEncoding),\n/* harmony export */   \"LoopOnce\": () => (/* binding */ LoopOnce),\n/* harmony export */   \"LoopPingPong\": () => (/* binding */ LoopPingPong),\n/* harmony export */   \"LoopRepeat\": () => (/* binding */ LoopRepeat),\n/* harmony export */   \"LuminanceAlphaFormat\": () => (/* binding */ LuminanceAlphaFormat),\n/* harmony export */   \"LuminanceFormat\": () => (/* binding */ LuminanceFormat),\n/* harmony export */   \"MOUSE\": () => (/* binding */ MOUSE),\n/* harmony export */   \"Material\": () => (/* binding */ Material),\n/* harmony export */   \"MaterialLoader\": () => (/* binding */ MaterialLoader),\n/* harmony export */   \"Math\": () => (/* binding */ MathUtils),\n/* harmony export */   \"MathUtils\": () => (/* binding */ MathUtils),\n/* harmony export */   \"Matrix3\": () => (/* binding */ Matrix3),\n/* harmony export */   \"Matrix4\": () => (/* binding */ Matrix4),\n/* harmony export */   \"MaxEquation\": () => (/* binding */ MaxEquation),\n/* harmony export */   \"Mesh\": () => (/* binding */ Mesh),\n/* harmony export */   \"MeshBasicMaterial\": () => (/* binding */ MeshBasicMaterial),\n/* harmony export */   \"MeshDepthMaterial\": () => (/* binding */ MeshDepthMaterial),\n/* harmony export */   \"MeshDistanceMaterial\": () => (/* binding */ MeshDistanceMaterial),\n/* harmony export */   \"MeshFaceMaterial\": () => (/* binding */ MeshFaceMaterial),\n/* harmony export */   \"MeshLambertMaterial\": () => (/* binding */ MeshLambertMaterial),\n/* harmony export */   \"MeshMatcapMaterial\": () => (/* binding */ MeshMatcapMaterial),\n/* harmony export */   \"MeshNormalMaterial\": () => (/* binding */ MeshNormalMaterial),\n/* harmony export */   \"MeshPhongMaterial\": () => (/* binding */ MeshPhongMaterial),\n/* harmony export */   \"MeshPhysicalMaterial\": () => (/* binding */ MeshPhysicalMaterial),\n/* harmony export */   \"MeshStandardMaterial\": () => (/* binding */ MeshStandardMaterial),\n/* harmony export */   \"MeshToonMaterial\": () => (/* binding */ MeshToonMaterial),\n/* harmony export */   \"MinEquation\": () => (/* binding */ MinEquation),\n/* harmony export */   \"MirroredRepeatWrapping\": () => (/* binding */ MirroredRepeatWrapping),\n/* harmony export */   \"MixOperation\": () => (/* binding */ MixOperation),\n/* harmony export */   \"MultiMaterial\": () => (/* binding */ MultiMaterial),\n/* harmony export */   \"MultiplyBlending\": () => (/* binding */ MultiplyBlending),\n/* harmony export */   \"MultiplyOperation\": () => (/* binding */ MultiplyOperation),\n/* harmony export */   \"NearestFilter\": () => (/* binding */ NearestFilter),\n/* harmony export */   \"NearestMipMapLinearFilter\": () => (/* binding */ NearestMipMapLinearFilter),\n/* harmony export */   \"NearestMipMapNearestFilter\": () => (/* binding */ NearestMipMapNearestFilter),\n/* harmony export */   \"NearestMipmapLinearFilter\": () => (/* binding */ NearestMipmapLinearFilter),\n/* harmony export */   \"NearestMipmapNearestFilter\": () => (/* binding */ NearestMipmapNearestFilter),\n/* harmony export */   \"NeverDepth\": () => (/* binding */ NeverDepth),\n/* harmony export */   \"NeverStencilFunc\": () => (/* binding */ NeverStencilFunc),\n/* harmony export */   \"NoBlending\": () => (/* binding */ NoBlending),\n/* harmony export */   \"NoColors\": () => (/* binding */ NoColors),\n/* harmony export */   \"NoToneMapping\": () => (/* binding */ NoToneMapping),\n/* harmony export */   \"NormalAnimationBlendMode\": () => (/* binding */ NormalAnimationBlendMode),\n/* harmony export */   \"NormalBlending\": () => (/* binding */ NormalBlending),\n/* harmony export */   \"NotEqualDepth\": () => (/* binding */ NotEqualDepth),\n/* harmony export */   \"NotEqualStencilFunc\": () => (/* binding */ NotEqualStencilFunc),\n/* harmony export */   \"NumberKeyframeTrack\": () => (/* binding */ NumberKeyframeTrack),\n/* harmony export */   \"Object3D\": () => (/* binding */ Object3D),\n/* harmony export */   \"ObjectLoader\": () => (/* binding */ ObjectLoader),\n/* harmony export */   \"ObjectSpaceNormalMap\": () => (/* binding */ ObjectSpaceNormalMap),\n/* harmony export */   \"OctahedronBufferGeometry\": () => (/* binding */ OctahedronGeometry),\n/* harmony export */   \"OctahedronGeometry\": () => (/* binding */ OctahedronGeometry),\n/* harmony export */   \"OneFactor\": () => (/* binding */ OneFactor),\n/* harmony export */   \"OneMinusDstAlphaFactor\": () => (/* binding */ OneMinusDstAlphaFactor),\n/* harmony export */   \"OneMinusDstColorFactor\": () => (/* binding */ OneMinusDstColorFactor),\n/* harmony export */   \"OneMinusSrcAlphaFactor\": () => (/* binding */ OneMinusSrcAlphaFactor),\n/* harmony export */   \"OneMinusSrcColorFactor\": () => (/* binding */ OneMinusSrcColorFactor),\n/* harmony export */   \"OrthographicCamera\": () => (/* binding */ OrthographicCamera),\n/* harmony export */   \"PCFShadowMap\": () => (/* binding */ PCFShadowMap),\n/* harmony export */   \"PCFSoftShadowMap\": () => (/* binding */ PCFSoftShadowMap),\n/* harmony export */   \"PMREMGenerator\": () => (/* binding */ PMREMGenerator),\n/* harmony export */   \"ParametricBufferGeometry\": () => (/* binding */ ParametricGeometry),\n/* harmony export */   \"ParametricGeometry\": () => (/* binding */ ParametricGeometry),\n/* harmony export */   \"Particle\": () => (/* binding */ Particle),\n/* harmony export */   \"ParticleBasicMaterial\": () => (/* binding */ ParticleBasicMaterial),\n/* harmony export */   \"ParticleSystem\": () => (/* binding */ ParticleSystem),\n/* harmony export */   \"ParticleSystemMaterial\": () => (/* binding */ ParticleSystemMaterial),\n/* harmony export */   \"Path\": () => (/* binding */ Path),\n/* harmony export */   \"PerspectiveCamera\": () => (/* binding */ PerspectiveCamera),\n/* harmony export */   \"Plane\": () => (/* binding */ Plane),\n/* harmony export */   \"PlaneBufferGeometry\": () => (/* binding */ PlaneGeometry),\n/* harmony export */   \"PlaneGeometry\": () => (/* binding */ PlaneGeometry),\n/* harmony export */   \"PlaneHelper\": () => (/* binding */ PlaneHelper),\n/* harmony export */   \"PointCloud\": () => (/* binding */ PointCloud),\n/* harmony export */   \"PointCloudMaterial\": () => (/* binding */ PointCloudMaterial),\n/* harmony export */   \"PointLight\": () => (/* binding */ PointLight),\n/* harmony export */   \"PointLightHelper\": () => (/* binding */ PointLightHelper),\n/* harmony export */   \"Points\": () => (/* binding */ Points),\n/* harmony export */   \"PointsMaterial\": () => (/* binding */ PointsMaterial),\n/* harmony export */   \"PolarGridHelper\": () => (/* binding */ PolarGridHelper),\n/* harmony export */   \"PolyhedronBufferGeometry\": () => (/* binding */ PolyhedronGeometry),\n/* harmony export */   \"PolyhedronGeometry\": () => (/* binding */ PolyhedronGeometry),\n/* harmony export */   \"PositionalAudio\": () => (/* binding */ PositionalAudio),\n/* harmony export */   \"PropertyBinding\": () => (/* binding */ PropertyBinding),\n/* harmony export */   \"PropertyMixer\": () => (/* binding */ PropertyMixer),\n/* harmony export */   \"QuadraticBezierCurve\": () => (/* binding */ QuadraticBezierCurve),\n/* harmony export */   \"QuadraticBezierCurve3\": () => (/* binding */ QuadraticBezierCurve3),\n/* harmony export */   \"Quaternion\": () => (/* binding */ Quaternion),\n/* harmony export */   \"QuaternionKeyframeTrack\": () => (/* binding */ QuaternionKeyframeTrack),\n/* harmony export */   \"QuaternionLinearInterpolant\": () => (/* binding */ QuaternionLinearInterpolant),\n/* harmony export */   \"REVISION\": () => (/* binding */ REVISION),\n/* harmony export */   \"RGBADepthPacking\": () => (/* binding */ RGBADepthPacking),\n/* harmony export */   \"RGBAFormat\": () => (/* binding */ RGBAFormat),\n/* harmony export */   \"RGBAIntegerFormat\": () => (/* binding */ RGBAIntegerFormat),\n/* harmony export */   \"RGBA_ASTC_10x10_Format\": () => (/* binding */ RGBA_ASTC_10x10_Format),\n/* harmony export */   \"RGBA_ASTC_10x5_Format\": () => (/* binding */ RGBA_ASTC_10x5_Format),\n/* harmony export */   \"RGBA_ASTC_10x6_Format\": () => (/* binding */ RGBA_ASTC_10x6_Format),\n/* harmony export */   \"RGBA_ASTC_10x8_Format\": () => (/* binding */ RGBA_ASTC_10x8_Format),\n/* harmony export */   \"RGBA_ASTC_12x10_Format\": () => (/* binding */ RGBA_ASTC_12x10_Format),\n/* harmony export */   \"RGBA_ASTC_12x12_Format\": () => (/* binding */ RGBA_ASTC_12x12_Format),\n/* harmony export */   \"RGBA_ASTC_4x4_Format\": () => (/* binding */ RGBA_ASTC_4x4_Format),\n/* harmony export */   \"RGBA_ASTC_5x4_Format\": () => (/* binding */ RGBA_ASTC_5x4_Format),\n/* harmony export */   \"RGBA_ASTC_5x5_Format\": () => (/* binding */ RGBA_ASTC_5x5_Format),\n/* harmony export */   \"RGBA_ASTC_6x5_Format\": () => (/* binding */ RGBA_ASTC_6x5_Format),\n/* harmony export */   \"RGBA_ASTC_6x6_Format\": () => (/* binding */ RGBA_ASTC_6x6_Format),\n/* harmony export */   \"RGBA_ASTC_8x5_Format\": () => (/* binding */ RGBA_ASTC_8x5_Format),\n/* harmony export */   \"RGBA_ASTC_8x6_Format\": () => (/* binding */ RGBA_ASTC_8x6_Format),\n/* harmony export */   \"RGBA_ASTC_8x8_Format\": () => (/* binding */ RGBA_ASTC_8x8_Format),\n/* harmony export */   \"RGBA_BPTC_Format\": () => (/* binding */ RGBA_BPTC_Format),\n/* harmony export */   \"RGBA_ETC2_EAC_Format\": () => (/* binding */ RGBA_ETC2_EAC_Format),\n/* harmony export */   \"RGBA_PVRTC_2BPPV1_Format\": () => (/* binding */ RGBA_PVRTC_2BPPV1_Format),\n/* harmony export */   \"RGBA_PVRTC_4BPPV1_Format\": () => (/* binding */ RGBA_PVRTC_4BPPV1_Format),\n/* harmony export */   \"RGBA_S3TC_DXT1_Format\": () => (/* binding */ RGBA_S3TC_DXT1_Format),\n/* harmony export */   \"RGBA_S3TC_DXT3_Format\": () => (/* binding */ RGBA_S3TC_DXT3_Format),\n/* harmony export */   \"RGBA_S3TC_DXT5_Format\": () => (/* binding */ RGBA_S3TC_DXT5_Format),\n/* harmony export */   \"RGBDEncoding\": () => (/* binding */ RGBDEncoding),\n/* harmony export */   \"RGBEEncoding\": () => (/* binding */ RGBEEncoding),\n/* harmony export */   \"RGBEFormat\": () => (/* binding */ RGBEFormat),\n/* harmony export */   \"RGBFormat\": () => (/* binding */ RGBFormat),\n/* harmony export */   \"RGBIntegerFormat\": () => (/* binding */ RGBIntegerFormat),\n/* harmony export */   \"RGBM16Encoding\": () => (/* binding */ RGBM16Encoding),\n/* harmony export */   \"RGBM7Encoding\": () => (/* binding */ RGBM7Encoding),\n/* harmony export */   \"RGB_ETC1_Format\": () => (/* binding */ RGB_ETC1_Format),\n/* harmony export */   \"RGB_ETC2_Format\": () => (/* binding */ RGB_ETC2_Format),\n/* harmony export */   \"RGB_PVRTC_2BPPV1_Format\": () => (/* binding */ RGB_PVRTC_2BPPV1_Format),\n/* harmony export */   \"RGB_PVRTC_4BPPV1_Format\": () => (/* binding */ RGB_PVRTC_4BPPV1_Format),\n/* harmony export */   \"RGB_S3TC_DXT1_Format\": () => (/* binding */ RGB_S3TC_DXT1_Format),\n/* harmony export */   \"RGFormat\": () => (/* binding */ RGFormat),\n/* harmony export */   \"RGIntegerFormat\": () => (/* binding */ RGIntegerFormat),\n/* harmony export */   \"RawShaderMaterial\": () => (/* binding */ RawShaderMaterial),\n/* harmony export */   \"Ray\": () => (/* binding */ Ray),\n/* harmony export */   \"Raycaster\": () => (/* binding */ Raycaster),\n/* harmony export */   \"RectAreaLight\": () => (/* binding */ RectAreaLight),\n/* harmony export */   \"RedFormat\": () => (/* binding */ RedFormat),\n/* harmony export */   \"RedIntegerFormat\": () => (/* binding */ RedIntegerFormat),\n/* harmony export */   \"ReinhardToneMapping\": () => (/* binding */ ReinhardToneMapping),\n/* harmony export */   \"RepeatWrapping\": () => (/* binding */ RepeatWrapping),\n/* harmony export */   \"ReplaceStencilOp\": () => (/* binding */ ReplaceStencilOp),\n/* harmony export */   \"ReverseSubtractEquation\": () => (/* binding */ ReverseSubtractEquation),\n/* harmony export */   \"RingBufferGeometry\": () => (/* binding */ RingGeometry),\n/* harmony export */   \"RingGeometry\": () => (/* binding */ RingGeometry),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x10_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x10_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x6_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x6_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_10x8_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_10x8_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_12x10_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_12x10_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_12x12_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_12x12_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_4x4_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_4x4_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_5x4_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_5x4_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_5x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_5x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_6x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_6x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_6x6_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_6x6_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_8x5_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_8x5_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_8x6_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_8x6_Format),\n/* harmony export */   \"SRGB8_ALPHA8_ASTC_8x8_Format\": () => (/* binding */ SRGB8_ALPHA8_ASTC_8x8_Format),\n/* harmony export */   \"Scene\": () => (/* binding */ Scene),\n/* harmony export */   \"SceneUtils\": () => (/* binding */ SceneUtils),\n/* harmony export */   \"ShaderChunk\": () => (/* binding */ ShaderChunk),\n/* harmony export */   \"ShaderLib\": () => (/* binding */ ShaderLib),\n/* harmony export */   \"ShaderMaterial\": () => (/* binding */ ShaderMaterial),\n/* harmony export */   \"ShadowMaterial\": () => (/* binding */ ShadowMaterial),\n/* harmony export */   \"Shape\": () => (/* binding */ Shape),\n/* harmony export */   \"ShapeBufferGeometry\": () => (/* binding */ ShapeGeometry),\n/* harmony export */   \"ShapeGeometry\": () => (/* binding */ ShapeGeometry),\n/* harmony export */   \"ShapePath\": () => (/* binding */ ShapePath),\n/* harmony export */   \"ShapeUtils\": () => (/* binding */ ShapeUtils),\n/* harmony export */   \"ShortType\": () => (/* binding */ ShortType),\n/* harmony export */   \"Skeleton\": () => (/* binding */ Skeleton),\n/* harmony export */   \"SkeletonHelper\": () => (/* binding */ SkeletonHelper),\n/* harmony export */   \"SkinnedMesh\": () => (/* binding */ SkinnedMesh),\n/* harmony export */   \"SmoothShading\": () => (/* binding */ SmoothShading),\n/* harmony export */   \"Sphere\": () => (/* binding */ Sphere),\n/* harmony export */   \"SphereBufferGeometry\": () => (/* binding */ SphereGeometry),\n/* harmony export */   \"SphereGeometry\": () => (/* binding */ SphereGeometry),\n/* harmony export */   \"Spherical\": () => (/* binding */ Spherical),\n/* harmony export */   \"SphericalHarmonics3\": () => (/* binding */ SphericalHarmonics3),\n/* harmony export */   \"SplineCurve\": () => (/* binding */ SplineCurve),\n/* harmony export */   \"SpotLight\": () => (/* binding */ SpotLight),\n/* harmony export */   \"SpotLightHelper\": () => (/* binding */ SpotLightHelper),\n/* harmony export */   \"Sprite\": () => (/* binding */ Sprite),\n/* harmony export */   \"SpriteMaterial\": () => (/* binding */ SpriteMaterial),\n/* harmony export */   \"SrcAlphaFactor\": () => (/* binding */ SrcAlphaFactor),\n/* harmony export */   \"SrcAlphaSaturateFactor\": () => (/* binding */ SrcAlphaSaturateFactor),\n/* harmony export */   \"SrcColorFactor\": () => (/* binding */ SrcColorFactor),\n/* harmony export */   \"StaticCopyUsage\": () => (/* binding */ StaticCopyUsage),\n/* harmony export */   \"StaticDrawUsage\": () => (/* binding */ StaticDrawUsage),\n/* harmony export */   \"StaticReadUsage\": () => (/* binding */ StaticReadUsage),\n/* harmony export */   \"StereoCamera\": () => (/* binding */ StereoCamera),\n/* harmony export */   \"StreamCopyUsage\": () => (/* binding */ StreamCopyUsage),\n/* harmony export */   \"StreamDrawUsage\": () => (/* binding */ StreamDrawUsage),\n/* harmony export */   \"StreamReadUsage\": () => (/* binding */ StreamReadUsage),\n/* harmony export */   \"StringKeyframeTrack\": () => (/* binding */ StringKeyframeTrack),\n/* harmony export */   \"SubtractEquation\": () => (/* binding */ SubtractEquation),\n/* harmony export */   \"SubtractiveBlending\": () => (/* binding */ SubtractiveBlending),\n/* harmony export */   \"TOUCH\": () => (/* binding */ TOUCH),\n/* harmony export */   \"TangentSpaceNormalMap\": () => (/* binding */ TangentSpaceNormalMap),\n/* harmony export */   \"TetrahedronBufferGeometry\": () => (/* binding */ TetrahedronGeometry),\n/* harmony export */   \"TetrahedronGeometry\": () => (/* binding */ TetrahedronGeometry),\n/* harmony export */   \"TextBufferGeometry\": () => (/* binding */ TextGeometry),\n/* harmony export */   \"TextGeometry\": () => (/* binding */ TextGeometry),\n/* harmony export */   \"Texture\": () => (/* binding */ Texture),\n/* harmony export */   \"TextureLoader\": () => (/* binding */ TextureLoader),\n/* harmony export */   \"TorusBufferGeometry\": () => (/* binding */ TorusGeometry),\n/* harmony export */   \"TorusGeometry\": () => (/* binding */ TorusGeometry),\n/* harmony export */   \"TorusKnotBufferGeometry\": () => (/* binding */ TorusKnotGeometry),\n/* harmony export */   \"TorusKnotGeometry\": () => (/* binding */ TorusKnotGeometry),\n/* harmony export */   \"Triangle\": () => (/* binding */ Triangle),\n/* harmony export */   \"TriangleFanDrawMode\": () => (/* binding */ TriangleFanDrawMode),\n/* harmony export */   \"TriangleStripDrawMode\": () => (/* binding */ TriangleStripDrawMode),\n/* harmony export */   \"TrianglesDrawMode\": () => (/* binding */ TrianglesDrawMode),\n/* harmony export */   \"TubeBufferGeometry\": () => (/* binding */ TubeGeometry),\n/* harmony export */   \"TubeGeometry\": () => (/* binding */ TubeGeometry),\n/* harmony export */   \"UVMapping\": () => (/* binding */ UVMapping),\n/* harmony export */   \"Uint16Attribute\": () => (/* binding */ Uint16Attribute),\n/* harmony export */   \"Uint16BufferAttribute\": () => (/* binding */ Uint16BufferAttribute),\n/* harmony export */   \"Uint32Attribute\": () => (/* binding */ Uint32Attribute),\n/* harmony export */   \"Uint32BufferAttribute\": () => (/* binding */ Uint32BufferAttribute),\n/* harmony export */   \"Uint8Attribute\": () => (/* binding */ Uint8Attribute),\n/* harmony export */   \"Uint8BufferAttribute\": () => (/* binding */ Uint8BufferAttribute),\n/* harmony export */   \"Uint8ClampedAttribute\": () => (/* binding */ Uint8ClampedAttribute),\n/* harmony export */   \"Uint8ClampedBufferAttribute\": () => (/* binding */ Uint8ClampedBufferAttribute),\n/* harmony export */   \"Uniform\": () => (/* binding */ Uniform),\n/* harmony export */   \"UniformsLib\": () => (/* binding */ UniformsLib),\n/* harmony export */   \"UniformsUtils\": () => (/* binding */ UniformsUtils),\n/* harmony export */   \"UnsignedByteType\": () => (/* binding */ UnsignedByteType),\n/* harmony export */   \"UnsignedInt248Type\": () => (/* binding */ UnsignedInt248Type),\n/* harmony export */   \"UnsignedIntType\": () => (/* binding */ UnsignedIntType),\n/* harmony export */   \"UnsignedShort4444Type\": () => (/* binding */ UnsignedShort4444Type),\n/* harmony export */   \"UnsignedShort5551Type\": () => (/* binding */ UnsignedShort5551Type),\n/* harmony export */   \"UnsignedShort565Type\": () => (/* binding */ UnsignedShort565Type),\n/* harmony export */   \"UnsignedShortType\": () => (/* binding */ UnsignedShortType),\n/* harmony export */   \"VSMShadowMap\": () => (/* binding */ VSMShadowMap),\n/* harmony export */   \"Vector2\": () => (/* binding */ Vector2),\n/* harmony export */   \"Vector3\": () => (/* binding */ Vector3),\n/* harmony export */   \"Vector4\": () => (/* binding */ Vector4),\n/* harmony export */   \"VectorKeyframeTrack\": () => (/* binding */ VectorKeyframeTrack),\n/* harmony export */   \"Vertex\": () => (/* binding */ Vertex),\n/* harmony export */   \"VertexColors\": () => (/* binding */ VertexColors),\n/* harmony export */   \"VideoTexture\": () => (/* binding */ VideoTexture),\n/* harmony export */   \"WebGL1Renderer\": () => (/* binding */ WebGL1Renderer),\n/* harmony export */   \"WebGLCubeRenderTarget\": () => (/* binding */ WebGLCubeRenderTarget),\n/* harmony export */   \"WebGLMultisampleRenderTarget\": () => (/* binding */ WebGLMultisampleRenderTarget),\n/* harmony export */   \"WebGLRenderTarget\": () => (/* binding */ WebGLRenderTarget),\n/* harmony export */   \"WebGLRenderTargetCube\": () => (/* binding */ WebGLRenderTargetCube),\n/* harmony export */   \"WebGLRenderer\": () => (/* binding */ WebGLRenderer),\n/* harmony export */   \"WebGLUtils\": () => (/* binding */ WebGLUtils),\n/* harmony export */   \"WireframeGeometry\": () => (/* binding */ WireframeGeometry),\n/* harmony export */   \"WireframeHelper\": () => (/* binding */ WireframeHelper),\n/* harmony export */   \"WrapAroundEnding\": () => (/* binding */ WrapAroundEnding),\n/* harmony export */   \"XHRLoader\": () => (/* binding */ XHRLoader),\n/* harmony export */   \"ZeroCurvatureEnding\": () => (/* binding */ ZeroCurvatureEnding),\n/* harmony export */   \"ZeroFactor\": () => (/* binding */ ZeroFactor),\n/* harmony export */   \"ZeroSlopeEnding\": () => (/* binding */ ZeroSlopeEnding),\n/* harmony export */   \"ZeroStencilOp\": () => (/* binding */ ZeroStencilOp),\n/* harmony export */   \"sRGBEncoding\": () => (/* binding */ sRGBEncoding)\n/* harmony export */ });\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n/**\n * @license\n * Copyright 2010-2021 Three.js Authors\n * SPDX-License-Identifier: MIT\n */\nconst REVISION = \"128\";\nconst MOUSE = {LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2};\nconst TOUCH = {ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3};\nconst CullFaceNone = 0;\nconst CullFaceBack = 1;\nconst CullFaceFront = 2;\nconst CullFaceFrontBack = 3;\nconst BasicShadowMap = 0;\nconst PCFShadowMap = 1;\nconst PCFSoftShadowMap = 2;\nconst VSMShadowMap = 3;\nconst FrontSide = 0;\nconst BackSide = 1;\nconst DoubleSide = 2;\nconst FlatShading = 1;\nconst SmoothShading = 2;\nconst NoBlending = 0;\nconst NormalBlending = 1;\nconst AdditiveBlending = 2;\nconst SubtractiveBlending = 3;\nconst MultiplyBlending = 4;\nconst CustomBlending = 5;\nconst AddEquation = 100;\nconst SubtractEquation = 101;\nconst ReverseSubtractEquation = 102;\nconst MinEquation = 103;\nconst MaxEquation = 104;\nconst ZeroFactor = 200;\nconst OneFactor = 201;\nconst SrcColorFactor = 202;\nconst OneMinusSrcColorFactor = 203;\nconst SrcAlphaFactor = 204;\nconst OneMinusSrcAlphaFactor = 205;\nconst DstAlphaFactor = 206;\nconst OneMinusDstAlphaFactor = 207;\nconst DstColorFactor = 208;\nconst OneMinusDstColorFactor = 209;\nconst SrcAlphaSaturateFactor = 210;\nconst NeverDepth = 0;\nconst AlwaysDepth = 1;\nconst LessDepth = 2;\nconst LessEqualDepth = 3;\nconst EqualDepth = 4;\nconst GreaterEqualDepth = 5;\nconst GreaterDepth = 6;\nconst NotEqualDepth = 7;\nconst MultiplyOperation = 0;\nconst MixOperation = 1;\nconst AddOperation = 2;\nconst NoToneMapping = 0;\nconst LinearToneMapping = 1;\nconst ReinhardToneMapping = 2;\nconst CineonToneMapping = 3;\nconst ACESFilmicToneMapping = 4;\nconst CustomToneMapping = 5;\nconst UVMapping = 300;\nconst CubeReflectionMapping = 301;\nconst CubeRefractionMapping = 302;\nconst EquirectangularReflectionMapping = 303;\nconst EquirectangularRefractionMapping = 304;\nconst CubeUVReflectionMapping = 306;\nconst CubeUVRefractionMapping = 307;\nconst RepeatWrapping = 1e3;\nconst ClampToEdgeWrapping = 1001;\nconst MirroredRepeatWrapping = 1002;\nconst NearestFilter = 1003;\nconst NearestMipmapNearestFilter = 1004;\nconst NearestMipMapNearestFilter = 1004;\nconst NearestMipmapLinearFilter = 1005;\nconst NearestMipMapLinearFilter = 1005;\nconst LinearFilter = 1006;\nconst LinearMipmapNearestFilter = 1007;\nconst LinearMipMapNearestFilter = 1007;\nconst LinearMipmapLinearFilter = 1008;\nconst LinearMipMapLinearFilter = 1008;\nconst UnsignedByteType = 1009;\nconst ByteType = 1010;\nconst ShortType = 1011;\nconst UnsignedShortType = 1012;\nconst IntType = 1013;\nconst UnsignedIntType = 1014;\nconst FloatType = 1015;\nconst HalfFloatType = 1016;\nconst UnsignedShort4444Type = 1017;\nconst UnsignedShort5551Type = 1018;\nconst UnsignedShort565Type = 1019;\nconst UnsignedInt248Type = 1020;\nconst AlphaFormat = 1021;\nconst RGBFormat = 1022;\nconst RGBAFormat = 1023;\nconst LuminanceFormat = 1024;\nconst LuminanceAlphaFormat = 1025;\nconst RGBEFormat = RGBAFormat;\nconst DepthFormat = 1026;\nconst DepthStencilFormat = 1027;\nconst RedFormat = 1028;\nconst RedIntegerFormat = 1029;\nconst RGFormat = 1030;\nconst RGIntegerFormat = 1031;\nconst RGBIntegerFormat = 1032;\nconst RGBAIntegerFormat = 1033;\nconst RGB_S3TC_DXT1_Format = 33776;\nconst RGBA_S3TC_DXT1_Format = 33777;\nconst RGBA_S3TC_DXT3_Format = 33778;\nconst RGBA_S3TC_DXT5_Format = 33779;\nconst RGB_PVRTC_4BPPV1_Format = 35840;\nconst RGB_PVRTC_2BPPV1_Format = 35841;\nconst RGBA_PVRTC_4BPPV1_Format = 35842;\nconst RGBA_PVRTC_2BPPV1_Format = 35843;\nconst RGB_ETC1_Format = 36196;\nconst RGB_ETC2_Format = 37492;\nconst RGBA_ETC2_EAC_Format = 37496;\nconst RGBA_ASTC_4x4_Format = 37808;\nconst RGBA_ASTC_5x4_Format = 37809;\nconst RGBA_ASTC_5x5_Format = 37810;\nconst RGBA_ASTC_6x5_Format = 37811;\nconst RGBA_ASTC_6x6_Format = 37812;\nconst RGBA_ASTC_8x5_Format = 37813;\nconst RGBA_ASTC_8x6_Format = 37814;\nconst RGBA_ASTC_8x8_Format = 37815;\nconst RGBA_ASTC_10x5_Format = 37816;\nconst RGBA_ASTC_10x6_Format = 37817;\nconst RGBA_ASTC_10x8_Format = 37818;\nconst RGBA_ASTC_10x10_Format = 37819;\nconst RGBA_ASTC_12x10_Format = 37820;\nconst RGBA_ASTC_12x12_Format = 37821;\nconst RGBA_BPTC_Format = 36492;\nconst SRGB8_ALPHA8_ASTC_4x4_Format = 37840;\nconst SRGB8_ALPHA8_ASTC_5x4_Format = 37841;\nconst SRGB8_ALPHA8_ASTC_5x5_Format = 37842;\nconst SRGB8_ALPHA8_ASTC_6x5_Format = 37843;\nconst SRGB8_ALPHA8_ASTC_6x6_Format = 37844;\nconst SRGB8_ALPHA8_ASTC_8x5_Format = 37845;\nconst SRGB8_ALPHA8_ASTC_8x6_Format = 37846;\nconst SRGB8_ALPHA8_ASTC_8x8_Format = 37847;\nconst SRGB8_ALPHA8_ASTC_10x5_Format = 37848;\nconst SRGB8_ALPHA8_ASTC_10x6_Format = 37849;\nconst SRGB8_ALPHA8_ASTC_10x8_Format = 37850;\nconst SRGB8_ALPHA8_ASTC_10x10_Format = 37851;\nconst SRGB8_ALPHA8_ASTC_12x10_Format = 37852;\nconst SRGB8_ALPHA8_ASTC_12x12_Format = 37853;\nconst LoopOnce = 2200;\nconst LoopRepeat = 2201;\nconst LoopPingPong = 2202;\nconst InterpolateDiscrete = 2300;\nconst InterpolateLinear = 2301;\nconst InterpolateSmooth = 2302;\nconst ZeroCurvatureEnding = 2400;\nconst ZeroSlopeEnding = 2401;\nconst WrapAroundEnding = 2402;\nconst NormalAnimationBlendMode = 2500;\nconst AdditiveAnimationBlendMode = 2501;\nconst TrianglesDrawMode = 0;\nconst TriangleStripDrawMode = 1;\nconst TriangleFanDrawMode = 2;\nconst LinearEncoding = 3e3;\nconst sRGBEncoding = 3001;\nconst GammaEncoding = 3007;\nconst RGBEEncoding = 3002;\nconst LogLuvEncoding = 3003;\nconst RGBM7Encoding = 3004;\nconst RGBM16Encoding = 3005;\nconst RGBDEncoding = 3006;\nconst BasicDepthPacking = 3200;\nconst RGBADepthPacking = 3201;\nconst TangentSpaceNormalMap = 0;\nconst ObjectSpaceNormalMap = 1;\nconst ZeroStencilOp = 0;\nconst KeepStencilOp = 7680;\nconst ReplaceStencilOp = 7681;\nconst IncrementStencilOp = 7682;\nconst DecrementStencilOp = 7683;\nconst IncrementWrapStencilOp = 34055;\nconst DecrementWrapStencilOp = 34056;\nconst InvertStencilOp = 5386;\nconst NeverStencilFunc = 512;\nconst LessStencilFunc = 513;\nconst EqualStencilFunc = 514;\nconst LessEqualStencilFunc = 515;\nconst GreaterStencilFunc = 516;\nconst NotEqualStencilFunc = 517;\nconst GreaterEqualStencilFunc = 518;\nconst AlwaysStencilFunc = 519;\nconst StaticDrawUsage = 35044;\nconst DynamicDrawUsage = 35048;\nconst StreamDrawUsage = 35040;\nconst StaticReadUsage = 35045;\nconst DynamicReadUsage = 35049;\nconst StreamReadUsage = 35041;\nconst StaticCopyUsage = 35046;\nconst DynamicCopyUsage = 35050;\nconst StreamCopyUsage = 35042;\nconst GLSL1 = \"100\";\nconst GLSL3 = \"300 es\";\nclass EventDispatcher {\n  addEventListener(type, listener) {\n    if (this._listeners === void 0)\n      this._listeners = {};\n    const listeners = this._listeners;\n    if (listeners[type] === void 0) {\n      listeners[type] = [];\n    }\n    if (listeners[type].indexOf(listener) === -1) {\n      listeners[type].push(listener);\n    }\n  }\n  hasEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return false;\n    const listeners = this._listeners;\n    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n  }\n  removeEventListener(type, listener) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[type];\n    if (listenerArray !== void 0) {\n      const index = listenerArray.indexOf(listener);\n      if (index !== -1) {\n        listenerArray.splice(index, 1);\n      }\n    }\n  }\n  dispatchEvent(event) {\n    if (this._listeners === void 0)\n      return;\n    const listeners = this._listeners;\n    const listenerArray = listeners[event.type];\n    if (listenerArray !== void 0) {\n      event.target = this;\n      const array = listenerArray.slice(0);\n      for (let i = 0, l = array.length; i < l; i++) {\n        array[i].call(this, event);\n      }\n      event.target = null;\n    }\n  }\n}\nconst _lut = [];\nfor (let i = 0; i < 256; i++) {\n  _lut[i] = (i < 16 ? \"0\" : \"\") + i.toString(16);\n}\nlet _seed = 1234567;\nconst DEG2RAD = Math.PI / 180;\nconst RAD2DEG = 180 / Math.PI;\nfunction generateUUID() {\n  const d0 = Math.random() * 4294967295 | 0;\n  const d1 = Math.random() * 4294967295 | 0;\n  const d2 = Math.random() * 4294967295 | 0;\n  const d3 = Math.random() * 4294967295 | 0;\n  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + \"-\" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + \"-\" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + \"-\" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + \"-\" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n  return uuid.toUpperCase();\n}\nfunction clamp(value, min, max) {\n  return Math.max(min, Math.min(max, value));\n}\nfunction euclideanModulo(n, m) {\n  return (n % m + m) % m;\n}\nfunction mapLinear(x, a1, a2, b1, b2) {\n  return b1 + (x - a1) * (b2 - b1) / (a2 - a1);\n}\nfunction inverseLerp(x, y, value) {\n  if (x !== y) {\n    return (value - x) / (y - x);\n  } else {\n    return 0;\n  }\n}\nfunction lerp(x, y, t) {\n  return (1 - t) * x + t * y;\n}\nfunction damp(x, y, lambda, dt) {\n  return lerp(x, y, 1 - Math.exp(-lambda * dt));\n}\nfunction pingpong(x, length = 1) {\n  return length - Math.abs(euclideanModulo(x, length * 2) - length);\n}\nfunction smoothstep(x, min, max) {\n  if (x <= min)\n    return 0;\n  if (x >= max)\n    return 1;\n  x = (x - min) / (max - min);\n  return x * x * (3 - 2 * x);\n}\nfunction smootherstep(x, min, max) {\n  if (x <= min)\n    return 0;\n  if (x >= max)\n    return 1;\n  x = (x - min) / (max - min);\n  return x * x * x * (x * (x * 6 - 15) + 10);\n}\nfunction randInt(low, high) {\n  return low + Math.floor(Math.random() * (high - low + 1));\n}\nfunction randFloat(low, high) {\n  return low + Math.random() * (high - low);\n}\nfunction randFloatSpread(range) {\n  return range * (0.5 - Math.random());\n}\nfunction seededRandom(s) {\n  if (s !== void 0)\n    _seed = s % 2147483647;\n  _seed = _seed * 16807 % 2147483647;\n  return (_seed - 1) / 2147483646;\n}\nfunction degToRad(degrees) {\n  return degrees * DEG2RAD;\n}\nfunction radToDeg(radians) {\n  return radians * RAD2DEG;\n}\nfunction isPowerOfTwo(value) {\n  return (value & value - 1) === 0 && value !== 0;\n}\nfunction ceilPowerOfTwo(value) {\n  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));\n}\nfunction floorPowerOfTwo(value) {\n  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));\n}\nfunction setQuaternionFromProperEuler(q, a, b, c, order) {\n  const cos = Math.cos;\n  const sin = Math.sin;\n  const c2 = cos(b / 2);\n  const s2 = sin(b / 2);\n  const c13 = cos((a + c) / 2);\n  const s13 = sin((a + c) / 2);\n  const c1_3 = cos((a - c) / 2);\n  const s1_3 = sin((a - c) / 2);\n  const c3_1 = cos((c - a) / 2);\n  const s3_1 = sin((c - a) / 2);\n  switch (order) {\n    case \"XYX\":\n      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);\n      break;\n    case \"YZY\":\n      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);\n      break;\n    case \"ZXZ\":\n      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);\n      break;\n    case \"XZX\":\n      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);\n      break;\n    case \"YXY\":\n      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);\n      break;\n    case \"ZYZ\":\n      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);\n      break;\n    default:\n      console.warn(\"THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: \" + order);\n  }\n}\nvar MathUtils = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  DEG2RAD,\n  RAD2DEG,\n  generateUUID,\n  clamp,\n  euclideanModulo,\n  mapLinear,\n  inverseLerp,\n  lerp,\n  damp,\n  pingpong,\n  smoothstep,\n  smootherstep,\n  randInt,\n  randFloat,\n  randFloatSpread,\n  seededRandom,\n  degToRad,\n  radToDeg,\n  isPowerOfTwo,\n  ceilPowerOfTwo,\n  floorPowerOfTwo,\n  setQuaternionFromProperEuler\n});\nclass Vector2 {\n  constructor(x = 0, y = 0) {\n    this.x = x;\n    this.y = y;\n  }\n  get width() {\n    return this.x;\n  }\n  set width(value) {\n    this.x = value;\n  }\n  get height() {\n    return this.y;\n  }\n  set height(value) {\n    this.y = value;\n  }\n  set(x, y) {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    return this;\n  }\n  add(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\");\n      return this.addVectors(v, w);\n    }\n    this.x += v.x;\n    this.y += v.y;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    return this;\n  }\n  sub(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\");\n      return this.subVectors(v, w);\n    }\n    this.x -= v.x;\n    this.y -= v.y;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    return this;\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  applyMatrix3(m) {\n    const x = this.x, y = this.y;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6];\n    this.y = e[1] * x + e[4] * y + e[7];\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    return this;\n  }\n  clamp(min, max) {\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    return this;\n  }\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y;\n  }\n  cross(v) {\n    return this.x * v.y - this.y * v.x;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  angle() {\n    const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n    return angle;\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x, dy = this.y - v.y;\n    return dx * dx + dy * dy;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    return array;\n  }\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== void 0) {\n      console.warn(\"THREE.Vector2: offset has been removed from .fromBufferAttribute().\");\n    }\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    return this;\n  }\n  rotateAround(center, angle) {\n    const c = Math.cos(angle), s = Math.sin(angle);\n    const x = this.x - center.x;\n    const y = this.y - center.y;\n    this.x = x * c - y * s + center.x;\n    this.y = x * s + y * c + center.y;\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    return this;\n  }\n}\nVector2.prototype.isVector2 = true;\nclass Matrix3 {\n  constructor() {\n    this.elements = [\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1\n    ];\n    if (arguments.length > 0) {\n      console.error(\"THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.\");\n    }\n  }\n  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n    const te = this.elements;\n    te[0] = n11;\n    te[1] = n21;\n    te[2] = n31;\n    te[3] = n12;\n    te[4] = n22;\n    te[5] = n32;\n    te[6] = n13;\n    te[7] = n23;\n    te[8] = n33;\n    return this;\n  }\n  identity() {\n    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);\n    return this;\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrix3Column(this, 0);\n    yAxis.setFromMatrix3Column(this, 1);\n    zAxis.setFromMatrix3Column(this, 2);\n    return this;\n  }\n  setFromMatrix4(m) {\n    const me = m.elements;\n    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);\n    return this;\n  }\n  multiply(m) {\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n    const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n    const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n    const b11 = be[0], b12 = be[3], b13 = be[6];\n    const b21 = be[1], b22 = be[4], b23 = be[7];\n    const b31 = be[2], b32 = be[5], b33 = be[8];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n    te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n    te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n    te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n    te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n    te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n    te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[3] *= s;\n    te[6] *= s;\n    te[1] *= s;\n    te[4] *= s;\n    te[7] *= s;\n    te[2] *= s;\n    te[5] *= s;\n    te[8] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];\n    return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\n  }\n  invert() {\n    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n    if (det === 0)\n      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n31 * n23 - n33 * n21) * detInv;\n    te[2] = (n32 * n21 - n31 * n22) * detInv;\n    te[3] = t12 * detInv;\n    te[4] = (n33 * n11 - n31 * n13) * detInv;\n    te[5] = (n31 * n12 - n32 * n11) * detInv;\n    te[6] = t13 * detInv;\n    te[7] = (n21 * n13 - n23 * n11) * detInv;\n    te[8] = (n22 * n11 - n21 * n12) * detInv;\n    return this;\n  }\n  transpose() {\n    let tmp2;\n    const m = this.elements;\n    tmp2 = m[1];\n    m[1] = m[3];\n    m[3] = tmp2;\n    tmp2 = m[2];\n    m[2] = m[6];\n    m[6] = tmp2;\n    tmp2 = m[5];\n    m[5] = m[7];\n    m[7] = tmp2;\n    return this;\n  }\n  getNormalMatrix(matrix4) {\n    return this.setFromMatrix4(matrix4).invert().transpose();\n  }\n  transposeIntoArray(r) {\n    const m = this.elements;\n    r[0] = m[0];\n    r[1] = m[3];\n    r[2] = m[6];\n    r[3] = m[1];\n    r[4] = m[4];\n    r[5] = m[7];\n    r[6] = m[2];\n    r[7] = m[5];\n    r[8] = m[8];\n    return this;\n  }\n  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n    const c = Math.cos(rotation);\n    const s = Math.sin(rotation);\n    this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);\n    return this;\n  }\n  scale(sx, sy) {\n    const te = this.elements;\n    te[0] *= sx;\n    te[3] *= sx;\n    te[6] *= sx;\n    te[1] *= sy;\n    te[4] *= sy;\n    te[7] *= sy;\n    return this;\n  }\n  rotate(theta) {\n    const c = Math.cos(theta);\n    const s = Math.sin(theta);\n    const te = this.elements;\n    const a11 = te[0], a12 = te[3], a13 = te[6];\n    const a21 = te[1], a22 = te[4], a23 = te[7];\n    te[0] = c * a11 + s * a21;\n    te[3] = c * a12 + s * a22;\n    te[6] = c * a13 + s * a23;\n    te[1] = -s * a11 + c * a21;\n    te[4] = -s * a12 + c * a22;\n    te[7] = -s * a13 + c * a23;\n    return this;\n  }\n  translate(tx, ty) {\n    const te = this.elements;\n    te[0] += tx * te[2];\n    te[3] += tx * te[5];\n    te[6] += tx * te[8];\n    te[1] += ty * te[2];\n    te[4] += ty * te[5];\n    te[7] += ty * te[8];\n    return this;\n  }\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 9; i++) {\n      if (te[i] !== me[i])\n        return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 9; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    return array;\n  }\n  clone() {\n    return new this.constructor().fromArray(this.elements);\n  }\n}\nMatrix3.prototype.isMatrix3 = true;\nlet _canvas;\nclass ImageUtils {\n  static getDataURL(image) {\n    if (/^data:/i.test(image.src)) {\n      return image.src;\n    }\n    if (typeof HTMLCanvasElement == \"undefined\") {\n      return image.src;\n    }\n    let canvas;\n    if (image instanceof HTMLCanvasElement) {\n      canvas = image;\n    } else {\n      if (_canvas === void 0)\n        _canvas = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n      _canvas.width = image.width;\n      _canvas.height = image.height;\n      const context = _canvas.getContext(\"2d\");\n      if (image instanceof ImageData) {\n        context.putImageData(image, 0, 0);\n      } else {\n        context.drawImage(image, 0, 0, image.width, image.height);\n      }\n      canvas = _canvas;\n    }\n    if (canvas.width > 2048 || canvas.height > 2048) {\n      console.warn(\"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\", image);\n      return canvas.toDataURL(\"image/jpeg\", 0.6);\n    } else {\n      return canvas.toDataURL(\"image/png\");\n    }\n  }\n}\nlet textureId = 0;\nclass Texture extends EventDispatcher {\n  constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding) {\n    super();\n    Object.defineProperty(this, \"id\", {value: textureId++});\n    this.uuid = generateUUID();\n    this.name = \"\";\n    this.image = image;\n    this.mipmaps = [];\n    this.mapping = mapping;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.magFilter = magFilter;\n    this.minFilter = minFilter;\n    this.anisotropy = anisotropy;\n    this.format = format;\n    this.internalFormat = null;\n    this.type = type;\n    this.offset = new Vector2(0, 0);\n    this.repeat = new Vector2(1, 1);\n    this.center = new Vector2(0, 0);\n    this.rotation = 0;\n    this.matrixAutoUpdate = true;\n    this.matrix = new Matrix3();\n    this.generateMipmaps = true;\n    this.premultiplyAlpha = false;\n    this.flipY = true;\n    this.unpackAlignment = 4;\n    this.encoding = encoding;\n    this.version = 0;\n    this.onUpdate = null;\n  }\n  updateMatrix() {\n    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.name = source.name;\n    this.image = source.image;\n    this.mipmaps = source.mipmaps.slice(0);\n    this.mapping = source.mapping;\n    this.wrapS = source.wrapS;\n    this.wrapT = source.wrapT;\n    this.magFilter = source.magFilter;\n    this.minFilter = source.minFilter;\n    this.anisotropy = source.anisotropy;\n    this.format = source.format;\n    this.internalFormat = source.internalFormat;\n    this.type = source.type;\n    this.offset.copy(source.offset);\n    this.repeat.copy(source.repeat);\n    this.center.copy(source.center);\n    this.rotation = source.rotation;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrix.copy(source.matrix);\n    this.generateMipmaps = source.generateMipmaps;\n    this.premultiplyAlpha = source.premultiplyAlpha;\n    this.flipY = source.flipY;\n    this.unpackAlignment = source.unpackAlignment;\n    this.encoding = source.encoding;\n    return this;\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void 0 || typeof meta === \"string\";\n    if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n      return meta.textures[this.uuid];\n    }\n    const output = {\n      metadata: {\n        version: 4.5,\n        type: \"Texture\",\n        generator: \"Texture.toJSON\"\n      },\n      uuid: this.uuid,\n      name: this.name,\n      mapping: this.mapping,\n      repeat: [this.repeat.x, this.repeat.y],\n      offset: [this.offset.x, this.offset.y],\n      center: [this.center.x, this.center.y],\n      rotation: this.rotation,\n      wrap: [this.wrapS, this.wrapT],\n      format: this.format,\n      type: this.type,\n      encoding: this.encoding,\n      minFilter: this.minFilter,\n      magFilter: this.magFilter,\n      anisotropy: this.anisotropy,\n      flipY: this.flipY,\n      premultiplyAlpha: this.premultiplyAlpha,\n      unpackAlignment: this.unpackAlignment\n    };\n    if (this.image !== void 0) {\n      const image = this.image;\n      if (image.uuid === void 0) {\n        image.uuid = generateUUID();\n      }\n      if (!isRootObject && meta.images[image.uuid] === void 0) {\n        let url;\n        if (Array.isArray(image)) {\n          url = [];\n          for (let i = 0, l = image.length; i < l; i++) {\n            if (image[i].isDataTexture) {\n              url.push(serializeImage(image[i].image));\n            } else {\n              url.push(serializeImage(image[i]));\n            }\n          }\n        } else {\n          url = serializeImage(image);\n        }\n        meta.images[image.uuid] = {\n          uuid: image.uuid,\n          url\n        };\n      }\n      output.image = image.uuid;\n    }\n    if (!isRootObject) {\n      meta.textures[this.uuid] = output;\n    }\n    return output;\n  }\n  dispose() {\n    this.dispatchEvent({type: \"dispose\"});\n  }\n  transformUv(uv) {\n    if (this.mapping !== UVMapping)\n      return uv;\n    uv.applyMatrix3(this.matrix);\n    if (uv.x < 0 || uv.x > 1) {\n      switch (this.wrapS) {\n        case RepeatWrapping:\n          uv.x = uv.x - Math.floor(uv.x);\n          break;\n        case ClampToEdgeWrapping:\n          uv.x = uv.x < 0 ? 0 : 1;\n          break;\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n            uv.x = Math.ceil(uv.x) - uv.x;\n          } else {\n            uv.x = uv.x - Math.floor(uv.x);\n          }\n          break;\n      }\n    }\n    if (uv.y < 0 || uv.y > 1) {\n      switch (this.wrapT) {\n        case RepeatWrapping:\n          uv.y = uv.y - Math.floor(uv.y);\n          break;\n        case ClampToEdgeWrapping:\n          uv.y = uv.y < 0 ? 0 : 1;\n          break;\n        case MirroredRepeatWrapping:\n          if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n            uv.y = Math.ceil(uv.y) - uv.y;\n          } else {\n            uv.y = uv.y - Math.floor(uv.y);\n          }\n          break;\n      }\n    }\n    if (this.flipY) {\n      uv.y = 1 - uv.y;\n    }\n    return uv;\n  }\n  set needsUpdate(value) {\n    if (value === true)\n      this.version++;\n  }\n}\nTexture.DEFAULT_IMAGE = void 0;\nTexture.DEFAULT_MAPPING = UVMapping;\nTexture.prototype.isTexture = true;\nfunction serializeImage(image) {\n  if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n    return ImageUtils.getDataURL(image);\n  } else {\n    if (image.data) {\n      return {\n        data: Array.prototype.slice.call(image.data),\n        width: image.width,\n        height: image.height,\n        type: image.data.constructor.name\n      };\n    } else {\n      console.warn(\"THREE.Texture: Unable to serialize Texture.\");\n      return {};\n    }\n  }\n}\nclass Vector4 {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n  }\n  get width() {\n    return this.z;\n  }\n  set width(value) {\n    this.z = value;\n  }\n  get height() {\n    return this.w;\n  }\n  set height(value) {\n    this.w = value;\n  }\n  set(x, y, z, w) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.w = w;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    this.w = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setW(w) {\n    this.w = w;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      case 3:\n        this.w = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      case 3:\n        return this.w;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z, this.w);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    this.w = v.w !== void 0 ? v.w : 1;\n    return this;\n  }\n  add(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\");\n      return this.addVectors(v, w);\n    }\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    this.w += v.w;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    this.w += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    this.w = a.w + b.w;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    this.w += v.w * s;\n    return this;\n  }\n  sub(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\");\n      return this.subVectors(v, w);\n    }\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    this.w -= v.w;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    this.w -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    this.w = a.w - b.w;\n    return this;\n  }\n  multiply(v) {\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    this.w *= v.w;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    this.w *= scalar;\n    return this;\n  }\n  applyMatrix4(m) {\n    const x = this.x, y = this.y, z = this.z, w = this.w;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;\n    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;\n    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;\n    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  setAxisAngleFromQuaternion(q) {\n    this.w = 2 * Math.acos(q.w);\n    const s = Math.sqrt(1 - q.w * q.w);\n    if (s < 1e-4) {\n      this.x = 1;\n      this.y = 0;\n      this.z = 0;\n    } else {\n      this.x = q.x / s;\n      this.y = q.y / s;\n      this.z = q.z / s;\n    }\n    return this;\n  }\n  setAxisAngleFromRotationMatrix(m) {\n    let angle, x, y, z;\n    const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n        this.set(1, 0, 0, 0);\n        return this;\n      }\n      angle = Math.PI;\n      const xx = (m11 + 1) / 2;\n      const yy = (m22 + 1) / 2;\n      const zz = (m33 + 1) / 2;\n      const xy = (m12 + m21) / 4;\n      const xz = (m13 + m31) / 4;\n      const yz = (m23 + m32) / 4;\n      if (xx > yy && xx > zz) {\n        if (xx < epsilon) {\n          x = 0;\n          y = 0.707106781;\n          z = 0.707106781;\n        } else {\n          x = Math.sqrt(xx);\n          y = xy / x;\n          z = xz / x;\n        }\n      } else if (yy > zz) {\n        if (yy < epsilon) {\n          x = 0.707106781;\n          y = 0;\n          z = 0.707106781;\n        } else {\n          y = Math.sqrt(yy);\n          x = xy / y;\n          z = yz / y;\n        }\n      } else {\n        if (zz < epsilon) {\n          x = 0.707106781;\n          y = 0.707106781;\n          z = 0;\n        } else {\n          z = Math.sqrt(zz);\n          x = xz / z;\n          y = yz / z;\n        }\n      }\n      this.set(x, y, z, angle);\n      return this;\n    }\n    let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n    if (Math.abs(s) < 1e-3)\n      s = 1;\n    this.x = (m32 - m23) / s;\n    this.y = (m13 - m31) / s;\n    this.z = (m21 - m12) / s;\n    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n    return this;\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    this.w = Math.min(this.w, v.w);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    this.w = Math.max(this.w, v.w);\n    return this;\n  }\n  clamp(min, max) {\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    this.w = Math.max(min.w, Math.min(max.w, this.w));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    this.w = Math.max(minVal, Math.min(maxVal, this.w));\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    this.w = Math.floor(this.w);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    this.w = Math.ceil(this.w);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    this.w = Math.round(this.w);\n    return this;\n  }\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    this.w = -this.w;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    this.w += (v.w - this.w) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    this.w = v1.w + (v2.w - v1.w) * alpha;\n    return this;\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    this.w = array[offset + 3];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    array[offset + 3] = this.w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== void 0) {\n      console.warn(\"THREE.Vector4: offset has been removed from .fromBufferAttribute().\");\n    }\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    this.w = attribute.getW(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    this.w = Math.random();\n    return this;\n  }\n}\nVector4.prototype.isVector4 = true;\nclass WebGLRenderTarget extends EventDispatcher {\n  constructor(width, height, options) {\n    super();\n    this.width = width;\n    this.height = height;\n    this.depth = 1;\n    this.scissor = new Vector4(0, 0, width, height);\n    this.scissorTest = false;\n    this.viewport = new Vector4(0, 0, width, height);\n    options = options || {};\n    this.texture = new Texture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n    this.texture.image = {};\n    this.texture.image.width = width;\n    this.texture.image.height = height;\n    this.texture.image.depth = 1;\n    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;\n    this.depthBuffer = options.depthBuffer !== void 0 ? options.depthBuffer : true;\n    this.stencilBuffer = options.stencilBuffer !== void 0 ? options.stencilBuffer : false;\n    this.depthTexture = options.depthTexture !== void 0 ? options.depthTexture : null;\n  }\n  setTexture(texture) {\n    texture.image = {\n      width: this.width,\n      height: this.height,\n      depth: this.depth\n    };\n    this.texture = texture;\n  }\n  setSize(width, height, depth = 1) {\n    if (this.width !== width || this.height !== height || this.depth !== depth) {\n      this.width = width;\n      this.height = height;\n      this.depth = depth;\n      this.texture.image.width = width;\n      this.texture.image.height = height;\n      this.texture.image.depth = depth;\n      this.dispose();\n    }\n    this.viewport.set(0, 0, width, height);\n    this.scissor.set(0, 0, width, height);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.width = source.width;\n    this.height = source.height;\n    this.depth = source.depth;\n    this.viewport.copy(source.viewport);\n    this.texture = source.texture.clone();\n    this.depthBuffer = source.depthBuffer;\n    this.stencilBuffer = source.stencilBuffer;\n    this.depthTexture = source.depthTexture;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({type: \"dispose\"});\n  }\n}\nWebGLRenderTarget.prototype.isWebGLRenderTarget = true;\nclass WebGLMultisampleRenderTarget extends WebGLRenderTarget {\n  constructor(width, height, options) {\n    super(width, height, options);\n    this.samples = 4;\n  }\n  copy(source) {\n    super.copy.call(this, source);\n    this.samples = source.samples;\n    return this;\n  }\n}\nWebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;\nclass Quaternion {\n  constructor(x = 0, y = 0, z = 0, w = 1) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n  }\n  static slerp(qa, qb, qm, t) {\n    console.warn(\"THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.\");\n    return qm.slerpQuaternions(qa, qb, t);\n  }\n  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n    if (t === 0) {\n      dst[dstOffset + 0] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n      return;\n    }\n    if (t === 1) {\n      dst[dstOffset + 0] = x1;\n      dst[dstOffset + 1] = y1;\n      dst[dstOffset + 2] = z1;\n      dst[dstOffset + 3] = w1;\n      return;\n    }\n    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n      let s = 1 - t;\n      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n      if (sqrSin > Number.EPSILON) {\n        const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n        s = Math.sin(s * len) / sin;\n        t = Math.sin(t * len) / sin;\n      }\n      const tDir = t * dir;\n      x0 = x0 * s + x1 * tDir;\n      y0 = y0 * s + y1 * tDir;\n      z0 = z0 * s + z1 * tDir;\n      w0 = w0 * s + w1 * tDir;\n      if (s === 1 - t) {\n        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n        x0 *= f;\n        y0 *= f;\n        z0 *= f;\n        w0 *= f;\n      }\n    }\n    dst[dstOffset] = x0;\n    dst[dstOffset + 1] = y0;\n    dst[dstOffset + 2] = z0;\n    dst[dstOffset + 3] = w0;\n  }\n  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n    const x0 = src0[srcOffset0];\n    const y0 = src0[srcOffset0 + 1];\n    const z0 = src0[srcOffset0 + 2];\n    const w0 = src0[srcOffset0 + 3];\n    const x1 = src1[srcOffset1];\n    const y1 = src1[srcOffset1 + 1];\n    const z1 = src1[srcOffset1 + 2];\n    const w1 = src1[srcOffset1 + 3];\n    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n    return dst;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get w() {\n    return this._w;\n  }\n  set w(value) {\n    this._w = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, w) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._w = w;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._w);\n  }\n  copy(quaternion) {\n    this._x = quaternion.x;\n    this._y = quaternion.y;\n    this._z = quaternion.z;\n    this._w = quaternion.w;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromEuler(euler, update) {\n    if (!(euler && euler.isEuler)) {\n      throw new Error(\"THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.\");\n    }\n    const x = euler._x, y = euler._y, z = euler._z, order = euler._order;\n    const cos = Math.cos;\n    const sin = Math.sin;\n    const c1 = cos(x / 2);\n    const c2 = cos(y / 2);\n    const c3 = cos(z / 2);\n    const s1 = sin(x / 2);\n    const s2 = sin(y / 2);\n    const s3 = sin(z / 2);\n    switch (order) {\n      case \"XYZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case \"YXZ\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case \"ZXY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case \"ZYX\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      case \"YZX\":\n        this._x = s1 * c2 * c3 + c1 * s2 * s3;\n        this._y = c1 * s2 * c3 + s1 * c2 * s3;\n        this._z = c1 * c2 * s3 - s1 * s2 * c3;\n        this._w = c1 * c2 * c3 - s1 * s2 * s3;\n        break;\n      case \"XZY\":\n        this._x = s1 * c2 * c3 - c1 * s2 * s3;\n        this._y = c1 * s2 * c3 - s1 * c2 * s3;\n        this._z = c1 * c2 * s3 + s1 * s2 * c3;\n        this._w = c1 * c2 * c3 + s1 * s2 * s3;\n        break;\n      default:\n        console.warn(\"THREE.Quaternion: .setFromEuler() encountered an unknown order: \" + order);\n    }\n    if (update !== false)\n      this._onChangeCallback();\n    return this;\n  }\n  setFromAxisAngle(axis, angle) {\n    const halfAngle = angle / 2, s = Math.sin(halfAngle);\n    this._x = axis.x * s;\n    this._y = axis.y * s;\n    this._z = axis.z * s;\n    this._w = Math.cos(halfAngle);\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m) {\n    const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n    if (trace > 0) {\n      const s = 0.5 / Math.sqrt(trace + 1);\n      this._w = 0.25 / s;\n      this._x = (m32 - m23) * s;\n      this._y = (m13 - m31) * s;\n      this._z = (m21 - m12) * s;\n    } else if (m11 > m22 && m11 > m33) {\n      const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n      this._w = (m32 - m23) / s;\n      this._x = 0.25 * s;\n      this._y = (m12 + m21) / s;\n      this._z = (m13 + m31) / s;\n    } else if (m22 > m33) {\n      const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n      this._w = (m13 - m31) / s;\n      this._x = (m12 + m21) / s;\n      this._y = 0.25 * s;\n      this._z = (m23 + m32) / s;\n    } else {\n      const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n      this._w = (m21 - m12) / s;\n      this._x = (m13 + m31) / s;\n      this._y = (m23 + m32) / s;\n      this._z = 0.25 * s;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  setFromUnitVectors(vFrom, vTo) {\n    let r = vFrom.dot(vTo) + 1;\n    if (r < Number.EPSILON) {\n      r = 0;\n      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n        this._x = -vFrom.y;\n        this._y = vFrom.x;\n        this._z = 0;\n        this._w = r;\n      } else {\n        this._x = 0;\n        this._y = -vFrom.z;\n        this._z = vFrom.y;\n        this._w = r;\n      }\n    } else {\n      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n      this._w = r;\n    }\n    return this.normalize();\n  }\n  angleTo(q) {\n    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n  }\n  rotateTowards(q, step) {\n    const angle = this.angleTo(q);\n    if (angle === 0)\n      return this;\n    const t = Math.min(1, step / angle);\n    this.slerp(q, t);\n    return this;\n  }\n  identity() {\n    return this.set(0, 0, 0, 1);\n  }\n  invert() {\n    return this.conjugate();\n  }\n  conjugate() {\n    this._x *= -1;\n    this._y *= -1;\n    this._z *= -1;\n    this._onChangeCallback();\n    return this;\n  }\n  dot(v) {\n    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n  }\n  lengthSq() {\n    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n  }\n  length() {\n    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n  }\n  normalize() {\n    let l = this.length();\n    if (l === 0) {\n      this._x = 0;\n      this._y = 0;\n      this._z = 0;\n      this._w = 1;\n    } else {\n      l = 1 / l;\n      this._x = this._x * l;\n      this._y = this._y * l;\n      this._z = this._z * l;\n      this._w = this._w * l;\n    }\n    this._onChangeCallback();\n    return this;\n  }\n  multiply(q, p) {\n    if (p !== void 0) {\n      console.warn(\"THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.\");\n      return this.multiplyQuaternions(q, p);\n    }\n    return this.multiplyQuaternions(this, q);\n  }\n  premultiply(q) {\n    return this.multiplyQuaternions(q, this);\n  }\n  multiplyQuaternions(a, b) {\n    const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n    const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n    this._onChangeCallback();\n    return this;\n  }\n  slerp(qb, t) {\n    if (t === 0)\n      return this;\n    if (t === 1)\n      return this.copy(qb);\n    const x = this._x, y = this._y, z = this._z, w = this._w;\n    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\n    if (cosHalfTheta < 0) {\n      this._w = -qb._w;\n      this._x = -qb._x;\n      this._y = -qb._y;\n      this._z = -qb._z;\n      cosHalfTheta = -cosHalfTheta;\n    } else {\n      this.copy(qb);\n    }\n    if (cosHalfTheta >= 1) {\n      this._w = w;\n      this._x = x;\n      this._y = y;\n      this._z = z;\n      return this;\n    }\n    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n    if (sqrSinHalfTheta <= Number.EPSILON) {\n      const s = 1 - t;\n      this._w = s * w + t * this._w;\n      this._x = s * x + t * this._x;\n      this._y = s * y + t * this._y;\n      this._z = s * z + t * this._z;\n      this.normalize();\n      this._onChangeCallback();\n      return this;\n    }\n    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n    this._w = w * ratioA + this._w * ratioB;\n    this._x = x * ratioA + this._x * ratioB;\n    this._y = y * ratioA + this._y * ratioB;\n    this._z = z * ratioA + this._z * ratioB;\n    this._onChangeCallback();\n    return this;\n  }\n  slerpQuaternions(qa, qb, t) {\n    this.copy(qa).slerp(qb, t);\n  }\n  equals(quaternion) {\n    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n  }\n  fromArray(array, offset = 0) {\n    this._x = array[offset];\n    this._y = array[offset + 1];\n    this._z = array[offset + 2];\n    this._w = array[offset + 3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._w;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this._x = attribute.getX(index);\n    this._y = attribute.getY(index);\n    this._z = attribute.getZ(index);\n    this._w = attribute.getW(index);\n    return this;\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {\n  }\n}\nQuaternion.prototype.isQuaternion = true;\nclass Vector3 {\n  constructor(x = 0, y = 0, z = 0) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n  }\n  set(x, y, z) {\n    if (z === void 0)\n      z = this.z;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    return this;\n  }\n  setScalar(scalar) {\n    this.x = scalar;\n    this.y = scalar;\n    this.z = scalar;\n    return this;\n  }\n  setX(x) {\n    this.x = x;\n    return this;\n  }\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n  setZ(z) {\n    this.z = z;\n    return this;\n  }\n  setComponent(index, value) {\n    switch (index) {\n      case 0:\n        this.x = value;\n        break;\n      case 1:\n        this.y = value;\n        break;\n      case 2:\n        this.z = value;\n        break;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n    return this;\n  }\n  getComponent(index) {\n    switch (index) {\n      case 0:\n        return this.x;\n      case 1:\n        return this.y;\n      case 2:\n        return this.z;\n      default:\n        throw new Error(\"index is out of range: \" + index);\n    }\n  }\n  clone() {\n    return new this.constructor(this.x, this.y, this.z);\n  }\n  copy(v) {\n    this.x = v.x;\n    this.y = v.y;\n    this.z = v.z;\n    return this;\n  }\n  add(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.\");\n      return this.addVectors(v, w);\n    }\n    this.x += v.x;\n    this.y += v.y;\n    this.z += v.z;\n    return this;\n  }\n  addScalar(s) {\n    this.x += s;\n    this.y += s;\n    this.z += s;\n    return this;\n  }\n  addVectors(a, b) {\n    this.x = a.x + b.x;\n    this.y = a.y + b.y;\n    this.z = a.z + b.z;\n    return this;\n  }\n  addScaledVector(v, s) {\n    this.x += v.x * s;\n    this.y += v.y * s;\n    this.z += v.z * s;\n    return this;\n  }\n  sub(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.\");\n      return this.subVectors(v, w);\n    }\n    this.x -= v.x;\n    this.y -= v.y;\n    this.z -= v.z;\n    return this;\n  }\n  subScalar(s) {\n    this.x -= s;\n    this.y -= s;\n    this.z -= s;\n    return this;\n  }\n  subVectors(a, b) {\n    this.x = a.x - b.x;\n    this.y = a.y - b.y;\n    this.z = a.z - b.z;\n    return this;\n  }\n  multiply(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.\");\n      return this.multiplyVectors(v, w);\n    }\n    this.x *= v.x;\n    this.y *= v.y;\n    this.z *= v.z;\n    return this;\n  }\n  multiplyScalar(scalar) {\n    this.x *= scalar;\n    this.y *= scalar;\n    this.z *= scalar;\n    return this;\n  }\n  multiplyVectors(a, b) {\n    this.x = a.x * b.x;\n    this.y = a.y * b.y;\n    this.z = a.z * b.z;\n    return this;\n  }\n  applyEuler(euler) {\n    if (!(euler && euler.isEuler)) {\n      console.error(\"THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.\");\n    }\n    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n  }\n  applyAxisAngle(axis, angle) {\n    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n  }\n  applyMatrix3(m) {\n    const x = this.x, y = this.y, z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[3] * y + e[6] * z;\n    this.y = e[1] * x + e[4] * y + e[7] * z;\n    this.z = e[2] * x + e[5] * y + e[8] * z;\n    return this;\n  }\n  applyNormalMatrix(m) {\n    return this.applyMatrix3(m).normalize();\n  }\n  applyMatrix4(m) {\n    const x = this.x, y = this.y, z = this.z;\n    const e = m.elements;\n    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);\n    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;\n    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;\n    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;\n    return this;\n  }\n  applyQuaternion(q) {\n    const x = this.x, y = this.y, z = this.z;\n    const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n    const ix = qw * x + qy * z - qz * y;\n    const iy = qw * y + qz * x - qx * z;\n    const iz = qw * z + qx * y - qy * x;\n    const iw = -qx * x - qy * y - qz * z;\n    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return this;\n  }\n  project(camera) {\n    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n  }\n  unproject(camera) {\n    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n  }\n  transformDirection(m) {\n    const x = this.x, y = this.y, z = this.z;\n    const e = m.elements;\n    this.x = e[0] * x + e[4] * y + e[8] * z;\n    this.y = e[1] * x + e[5] * y + e[9] * z;\n    this.z = e[2] * x + e[6] * y + e[10] * z;\n    return this.normalize();\n  }\n  divide(v) {\n    this.x /= v.x;\n    this.y /= v.y;\n    this.z /= v.z;\n    return this;\n  }\n  divideScalar(scalar) {\n    return this.multiplyScalar(1 / scalar);\n  }\n  min(v) {\n    this.x = Math.min(this.x, v.x);\n    this.y = Math.min(this.y, v.y);\n    this.z = Math.min(this.z, v.z);\n    return this;\n  }\n  max(v) {\n    this.x = Math.max(this.x, v.x);\n    this.y = Math.max(this.y, v.y);\n    this.z = Math.max(this.z, v.z);\n    return this;\n  }\n  clamp(min, max) {\n    this.x = Math.max(min.x, Math.min(max.x, this.x));\n    this.y = Math.max(min.y, Math.min(max.y, this.y));\n    this.z = Math.max(min.z, Math.min(max.z, this.z));\n    return this;\n  }\n  clampScalar(minVal, maxVal) {\n    this.x = Math.max(minVal, Math.min(maxVal, this.x));\n    this.y = Math.max(minVal, Math.min(maxVal, this.y));\n    this.z = Math.max(minVal, Math.min(maxVal, this.z));\n    return this;\n  }\n  clampLength(min, max) {\n    const length = this.length();\n    return this.divideScalar(length || 1).multiplyScalar(Math.max(min, Math.min(max, length)));\n  }\n  floor() {\n    this.x = Math.floor(this.x);\n    this.y = Math.floor(this.y);\n    this.z = Math.floor(this.z);\n    return this;\n  }\n  ceil() {\n    this.x = Math.ceil(this.x);\n    this.y = Math.ceil(this.y);\n    this.z = Math.ceil(this.z);\n    return this;\n  }\n  round() {\n    this.x = Math.round(this.x);\n    this.y = Math.round(this.y);\n    this.z = Math.round(this.z);\n    return this;\n  }\n  roundToZero() {\n    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x);\n    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y);\n    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z);\n    return this;\n  }\n  negate() {\n    this.x = -this.x;\n    this.y = -this.y;\n    this.z = -this.z;\n    return this;\n  }\n  dot(v) {\n    return this.x * v.x + this.y * v.y + this.z * v.z;\n  }\n  lengthSq() {\n    return this.x * this.x + this.y * this.y + this.z * this.z;\n  }\n  length() {\n    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n  }\n  manhattanLength() {\n    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n  }\n  normalize() {\n    return this.divideScalar(this.length() || 1);\n  }\n  setLength(length) {\n    return this.normalize().multiplyScalar(length);\n  }\n  lerp(v, alpha) {\n    this.x += (v.x - this.x) * alpha;\n    this.y += (v.y - this.y) * alpha;\n    this.z += (v.z - this.z) * alpha;\n    return this;\n  }\n  lerpVectors(v1, v2, alpha) {\n    this.x = v1.x + (v2.x - v1.x) * alpha;\n    this.y = v1.y + (v2.y - v1.y) * alpha;\n    this.z = v1.z + (v2.z - v1.z) * alpha;\n    return this;\n  }\n  cross(v, w) {\n    if (w !== void 0) {\n      console.warn(\"THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.\");\n      return this.crossVectors(v, w);\n    }\n    return this.crossVectors(this, v);\n  }\n  crossVectors(a, b) {\n    const ax = a.x, ay = a.y, az = a.z;\n    const bx = b.x, by = b.y, bz = b.z;\n    this.x = ay * bz - az * by;\n    this.y = az * bx - ax * bz;\n    this.z = ax * by - ay * bx;\n    return this;\n  }\n  projectOnVector(v) {\n    const denominator = v.lengthSq();\n    if (denominator === 0)\n      return this.set(0, 0, 0);\n    const scalar = v.dot(this) / denominator;\n    return this.copy(v).multiplyScalar(scalar);\n  }\n  projectOnPlane(planeNormal) {\n    _vector$c.copy(this).projectOnVector(planeNormal);\n    return this.sub(_vector$c);\n  }\n  reflect(normal) {\n    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n  }\n  angleTo(v) {\n    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n    if (denominator === 0)\n      return Math.PI / 2;\n    const theta = this.dot(v) / denominator;\n    return Math.acos(clamp(theta, -1, 1));\n  }\n  distanceTo(v) {\n    return Math.sqrt(this.distanceToSquared(v));\n  }\n  distanceToSquared(v) {\n    const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n    return dx * dx + dy * dy + dz * dz;\n  }\n  manhattanDistanceTo(v) {\n    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n  }\n  setFromSpherical(s) {\n    return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n  }\n  setFromSphericalCoords(radius, phi, theta) {\n    const sinPhiRadius = Math.sin(phi) * radius;\n    this.x = sinPhiRadius * Math.sin(theta);\n    this.y = Math.cos(phi) * radius;\n    this.z = sinPhiRadius * Math.cos(theta);\n    return this;\n  }\n  setFromCylindrical(c) {\n    return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n  }\n  setFromCylindricalCoords(radius, theta, y) {\n    this.x = radius * Math.sin(theta);\n    this.y = y;\n    this.z = radius * Math.cos(theta);\n    return this;\n  }\n  setFromMatrixPosition(m) {\n    const e = m.elements;\n    this.x = e[12];\n    this.y = e[13];\n    this.z = e[14];\n    return this;\n  }\n  setFromMatrixScale(m) {\n    const sx = this.setFromMatrixColumn(m, 0).length();\n    const sy = this.setFromMatrixColumn(m, 1).length();\n    const sz = this.setFromMatrixColumn(m, 2).length();\n    this.x = sx;\n    this.y = sy;\n    this.z = sz;\n    return this;\n  }\n  setFromMatrixColumn(m, index) {\n    return this.fromArray(m.elements, index * 4);\n  }\n  setFromMatrix3Column(m, index) {\n    return this.fromArray(m.elements, index * 3);\n  }\n  equals(v) {\n    return v.x === this.x && v.y === this.y && v.z === this.z;\n  }\n  fromArray(array, offset = 0) {\n    this.x = array[offset];\n    this.y = array[offset + 1];\n    this.z = array[offset + 2];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.x;\n    array[offset + 1] = this.y;\n    array[offset + 2] = this.z;\n    return array;\n  }\n  fromBufferAttribute(attribute, index, offset) {\n    if (offset !== void 0) {\n      console.warn(\"THREE.Vector3: offset has been removed from .fromBufferAttribute().\");\n    }\n    this.x = attribute.getX(index);\n    this.y = attribute.getY(index);\n    this.z = attribute.getZ(index);\n    return this;\n  }\n  random() {\n    this.x = Math.random();\n    this.y = Math.random();\n    this.z = Math.random();\n    return this;\n  }\n}\nVector3.prototype.isVector3 = true;\nconst _vector$c = /* @__PURE__ */ new Vector3();\nconst _quaternion$4 = /* @__PURE__ */ new Quaternion();\nclass Box3 {\n  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {\n    this.min = min;\n    this.max = max;\n  }\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  }\n  setFromArray(array) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let minZ = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      if (x < minX)\n        minX = x;\n      if (y < minY)\n        minY = y;\n      if (z < minZ)\n        minZ = z;\n      if (x > maxX)\n        maxX = x;\n      if (y > maxY)\n        maxY = y;\n      if (z > maxZ)\n        maxZ = z;\n    }\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n  setFromBufferAttribute(attribute) {\n    let minX = Infinity;\n    let minY = Infinity;\n    let minZ = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let maxZ = -Infinity;\n    for (let i = 0, l = attribute.count; i < l; i++) {\n      const x = attribute.getX(i);\n      const y = attribute.getY(i);\n      const z = attribute.getZ(i);\n      if (x < minX)\n        minX = x;\n      if (y < minY)\n        minY = y;\n      if (z < minZ)\n        minZ = z;\n      if (x > maxX)\n        maxX = x;\n      if (y > maxY)\n        maxY = y;\n      if (z > maxZ)\n        maxZ = z;\n    }\n    this.min.set(minX, minY, minZ);\n    this.max.set(maxX, maxY, maxZ);\n    return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n  setFromObject(object) {\n    this.makeEmpty();\n    return this.expandByObject(object);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n  makeEmpty() {\n    this.min.x = this.min.y = this.min.z = Infinity;\n    this.max.x = this.max.y = this.max.z = -Infinity;\n    return this;\n  }\n  isEmpty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n  }\n  getCenter(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box3: .getCenter() target is now required\");\n      target = new Vector3();\n    }\n    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box3: .getSize() target is now required\");\n      target = new Vector3();\n    }\n    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n  expandByObject(object) {\n    object.updateWorldMatrix(false, false);\n    const geometry = object.geometry;\n    if (geometry !== void 0) {\n      if (geometry.boundingBox === null) {\n        geometry.computeBoundingBox();\n      }\n      _box$3.copy(geometry.boundingBox);\n      _box$3.applyMatrix4(object.matrixWorld);\n      this.union(_box$3);\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      this.expandByObject(children[i]);\n    }\n    return this;\n  }\n  containsPoint(point) {\n    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y || point.z < this.min.z || point.z > this.max.z ? false : true;\n  }\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n  }\n  getParameter(point, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box3: .getParameter() target is now required\");\n      target = new Vector3();\n    }\n    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));\n  }\n  intersectsBox(box) {\n    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y || box.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n  }\n  intersectsSphere(sphere) {\n    this.clampPoint(sphere.center, _vector$b);\n    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  intersectsPlane(plane) {\n    let min, max;\n    if (plane.normal.x > 0) {\n      min = plane.normal.x * this.min.x;\n      max = plane.normal.x * this.max.x;\n    } else {\n      min = plane.normal.x * this.max.x;\n      max = plane.normal.x * this.min.x;\n    }\n    if (plane.normal.y > 0) {\n      min += plane.normal.y * this.min.y;\n      max += plane.normal.y * this.max.y;\n    } else {\n      min += plane.normal.y * this.max.y;\n      max += plane.normal.y * this.min.y;\n    }\n    if (plane.normal.z > 0) {\n      min += plane.normal.z * this.min.z;\n      max += plane.normal.z * this.max.z;\n    } else {\n      min += plane.normal.z * this.max.z;\n      max += plane.normal.z * this.min.z;\n    }\n    return min <= -plane.constant && max >= -plane.constant;\n  }\n  intersectsTriangle(triangle) {\n    if (this.isEmpty()) {\n      return false;\n    }\n    this.getCenter(_center);\n    _extents.subVectors(this.max, _center);\n    _v0$2.subVectors(triangle.a, _center);\n    _v1$7.subVectors(triangle.b, _center);\n    _v2$3.subVectors(triangle.c, _center);\n    _f0.subVectors(_v1$7, _v0$2);\n    _f1.subVectors(_v2$3, _v1$7);\n    _f2.subVectors(_v0$2, _v2$3);\n    let axes = [\n      0,\n      -_f0.z,\n      _f0.y,\n      0,\n      -_f1.z,\n      _f1.y,\n      0,\n      -_f2.z,\n      _f2.y,\n      _f0.z,\n      0,\n      -_f0.x,\n      _f1.z,\n      0,\n      -_f1.x,\n      _f2.z,\n      0,\n      -_f2.x,\n      -_f0.y,\n      _f0.x,\n      0,\n      -_f1.y,\n      _f1.x,\n      0,\n      -_f2.y,\n      _f2.x,\n      0\n    ];\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n      return false;\n    }\n    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    if (!satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents)) {\n      return false;\n    }\n    _triangleNormal.crossVectors(_f0, _f1);\n    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n    return satForAxes(axes, _v0$2, _v1$7, _v2$3, _extents);\n  }\n  clampPoint(point, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box3: .clampPoint() target is now required\");\n      target = new Vector3();\n    }\n    return target.copy(point).clamp(this.min, this.max);\n  }\n  distanceToPoint(point) {\n    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max);\n    return clampedPoint.sub(point).length();\n  }\n  getBoundingSphere(target) {\n    if (target === void 0) {\n      console.error(\"THREE.Box3: .getBoundingSphere() target is now required\");\n    }\n    this.getCenter(target.center);\n    target.radius = this.getSize(_vector$b).length() * 0.5;\n    return target;\n  }\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n    if (this.isEmpty())\n      this.makeEmpty();\n    return this;\n  }\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n  applyMatrix4(matrix) {\n    if (this.isEmpty())\n      return this;\n    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n    this.setFromPoints(_points);\n    return this;\n  }\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\nBox3.prototype.isBox3 = true;\nconst _points = [\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3(),\n  /* @__PURE__ */ new Vector3()\n];\nconst _vector$b = /* @__PURE__ */ new Vector3();\nconst _box$3 = /* @__PURE__ */ new Box3();\nconst _v0$2 = /* @__PURE__ */ new Vector3();\nconst _v1$7 = /* @__PURE__ */ new Vector3();\nconst _v2$3 = /* @__PURE__ */ new Vector3();\nconst _f0 = /* @__PURE__ */ new Vector3();\nconst _f1 = /* @__PURE__ */ new Vector3();\nconst _f2 = /* @__PURE__ */ new Vector3();\nconst _center = /* @__PURE__ */ new Vector3();\nconst _extents = /* @__PURE__ */ new Vector3();\nconst _triangleNormal = /* @__PURE__ */ new Vector3();\nconst _testAxis = /* @__PURE__ */ new Vector3();\nfunction satForAxes(axes, v0, v1, v2, extents) {\n  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {\n    _testAxis.fromArray(axes, i);\n    const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n    const p0 = v0.dot(_testAxis);\n    const p1 = v1.dot(_testAxis);\n    const p2 = v2.dot(_testAxis);\n    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n      return false;\n    }\n  }\n  return true;\n}\nconst _box$2 = /* @__PURE__ */ new Box3();\nconst _v1$6 = /* @__PURE__ */ new Vector3();\nconst _toFarthestPoint = /* @__PURE__ */ new Vector3();\nconst _toPoint = /* @__PURE__ */ new Vector3();\nclass Sphere {\n  constructor(center = new Vector3(), radius = -1) {\n    this.center = center;\n    this.radius = radius;\n  }\n  set(center, radius) {\n    this.center.copy(center);\n    this.radius = radius;\n    return this;\n  }\n  setFromPoints(points, optionalCenter) {\n    const center = this.center;\n    if (optionalCenter !== void 0) {\n      center.copy(optionalCenter);\n    } else {\n      _box$2.setFromPoints(points).getCenter(center);\n    }\n    let maxRadiusSq = 0;\n    for (let i = 0, il = points.length; i < il; i++) {\n      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));\n    }\n    this.radius = Math.sqrt(maxRadiusSq);\n    return this;\n  }\n  copy(sphere) {\n    this.center.copy(sphere.center);\n    this.radius = sphere.radius;\n    return this;\n  }\n  isEmpty() {\n    return this.radius < 0;\n  }\n  makeEmpty() {\n    this.center.set(0, 0, 0);\n    this.radius = -1;\n    return this;\n  }\n  containsPoint(point) {\n    return point.distanceToSquared(this.center) <= this.radius * this.radius;\n  }\n  distanceToPoint(point) {\n    return point.distanceTo(this.center) - this.radius;\n  }\n  intersectsSphere(sphere) {\n    const radiusSum = this.radius + sphere.radius;\n    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n  }\n  intersectsBox(box) {\n    return box.intersectsSphere(this);\n  }\n  intersectsPlane(plane) {\n    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n  }\n  clampPoint(point, target) {\n    const deltaLengthSq = this.center.distanceToSquared(point);\n    if (target === void 0) {\n      console.warn(\"THREE.Sphere: .clampPoint() target is now required\");\n      target = new Vector3();\n    }\n    target.copy(point);\n    if (deltaLengthSq > this.radius * this.radius) {\n      target.sub(this.center).normalize();\n      target.multiplyScalar(this.radius).add(this.center);\n    }\n    return target;\n  }\n  getBoundingBox(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Sphere: .getBoundingBox() target is now required\");\n      target = new Box3();\n    }\n    if (this.isEmpty()) {\n      target.makeEmpty();\n      return target;\n    }\n    target.set(this.center, this.center);\n    target.expandByScalar(this.radius);\n    return target;\n  }\n  applyMatrix4(matrix) {\n    this.center.applyMatrix4(matrix);\n    this.radius = this.radius * matrix.getMaxScaleOnAxis();\n    return this;\n  }\n  translate(offset) {\n    this.center.add(offset);\n    return this;\n  }\n  expandByPoint(point) {\n    _toPoint.subVectors(point, this.center);\n    const lengthSq = _toPoint.lengthSq();\n    if (lengthSq > this.radius * this.radius) {\n      const length = Math.sqrt(lengthSq);\n      const missingRadiusHalf = (length - this.radius) * 0.5;\n      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length));\n      this.radius += missingRadiusHalf;\n    }\n    return this;\n  }\n  union(sphere) {\n    _toFarthestPoint.subVectors(sphere.center, this.center).normalize().multiplyScalar(sphere.radius);\n    this.expandByPoint(_v1$6.copy(sphere.center).add(_toFarthestPoint));\n    this.expandByPoint(_v1$6.copy(sphere.center).sub(_toFarthestPoint));\n    return this;\n  }\n  equals(sphere) {\n    return sphere.center.equals(this.center) && sphere.radius === this.radius;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _vector$a = /* @__PURE__ */ new Vector3();\nconst _segCenter = /* @__PURE__ */ new Vector3();\nconst _segDir = /* @__PURE__ */ new Vector3();\nconst _diff = /* @__PURE__ */ new Vector3();\nconst _edge1 = /* @__PURE__ */ new Vector3();\nconst _edge2 = /* @__PURE__ */ new Vector3();\nconst _normal$1 = /* @__PURE__ */ new Vector3();\nclass Ray {\n  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n    this.origin = origin;\n    this.direction = direction;\n  }\n  set(origin, direction) {\n    this.origin.copy(origin);\n    this.direction.copy(direction);\n    return this;\n  }\n  copy(ray) {\n    this.origin.copy(ray.origin);\n    this.direction.copy(ray.direction);\n    return this;\n  }\n  at(t, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Ray: .at() target is now required\");\n      target = new Vector3();\n    }\n    return target.copy(this.direction).multiplyScalar(t).add(this.origin);\n  }\n  lookAt(v) {\n    this.direction.copy(v).sub(this.origin).normalize();\n    return this;\n  }\n  recast(t) {\n    this.origin.copy(this.at(t, _vector$a));\n    return this;\n  }\n  closestPointToPoint(point, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Ray: .closestPointToPoint() target is now required\");\n      target = new Vector3();\n    }\n    target.subVectors(point, this.origin);\n    const directionDistance = target.dot(this.direction);\n    if (directionDistance < 0) {\n      return target.copy(this.origin);\n    }\n    return target.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n  }\n  distanceToPoint(point) {\n    return Math.sqrt(this.distanceSqToPoint(point));\n  }\n  distanceSqToPoint(point) {\n    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n    if (directionDistance < 0) {\n      return this.origin.distanceToSquared(point);\n    }\n    _vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);\n    return _vector$a.distanceToSquared(point);\n  }\n  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n    _segDir.copy(v1).sub(v0).normalize();\n    _diff.copy(this.origin).sub(_segCenter);\n    const segExtent = v0.distanceTo(v1) * 0.5;\n    const a01 = -this.direction.dot(_segDir);\n    const b0 = _diff.dot(this.direction);\n    const b1 = -_diff.dot(_segDir);\n    const c = _diff.lengthSq();\n    const det = Math.abs(1 - a01 * a01);\n    let s0, s1, sqrDist, extDet;\n    if (det > 0) {\n      s0 = a01 * b1 - b0;\n      s1 = a01 * b0 - b1;\n      extDet = segExtent * det;\n      if (s0 >= 0) {\n        if (s1 >= -extDet) {\n          if (s1 <= extDet) {\n            const invDet = 1 / det;\n            s0 *= invDet;\n            s1 *= invDet;\n            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n          } else {\n            s1 = segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          s1 = -segExtent;\n          s0 = Math.max(0, -(a01 * s1 + b0));\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      } else {\n        if (s1 <= -extDet) {\n          s0 = Math.max(0, -(-a01 * segExtent + b0));\n          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        } else if (s1 <= extDet) {\n          s0 = 0;\n          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = s1 * (s1 + 2 * b1) + c;\n        } else {\n          s0 = Math.max(0, -(a01 * segExtent + b0));\n          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n        }\n      }\n    } else {\n      s1 = a01 > 0 ? -segExtent : segExtent;\n      s0 = Math.max(0, -(a01 * s1 + b0));\n      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n    }\n    if (optionalPointOnRay) {\n      optionalPointOnRay.copy(this.direction).multiplyScalar(s0).add(this.origin);\n    }\n    if (optionalPointOnSegment) {\n      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter);\n    }\n    return sqrDist;\n  }\n  intersectSphere(sphere, target) {\n    _vector$a.subVectors(sphere.center, this.origin);\n    const tca = _vector$a.dot(this.direction);\n    const d2 = _vector$a.dot(_vector$a) - tca * tca;\n    const radius2 = sphere.radius * sphere.radius;\n    if (d2 > radius2)\n      return null;\n    const thc = Math.sqrt(radius2 - d2);\n    const t0 = tca - thc;\n    const t1 = tca + thc;\n    if (t0 < 0 && t1 < 0)\n      return null;\n    if (t0 < 0)\n      return this.at(t1, target);\n    return this.at(t0, target);\n  }\n  intersectsSphere(sphere) {\n    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n  }\n  distanceToPlane(plane) {\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator === 0) {\n      if (plane.distanceToPoint(this.origin) === 0) {\n        return 0;\n      }\n      return null;\n    }\n    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n    return t >= 0 ? t : null;\n  }\n  intersectPlane(plane, target) {\n    const t = this.distanceToPlane(plane);\n    if (t === null) {\n      return null;\n    }\n    return this.at(t, target);\n  }\n  intersectsPlane(plane) {\n    const distToPoint = plane.distanceToPoint(this.origin);\n    if (distToPoint === 0) {\n      return true;\n    }\n    const denominator = plane.normal.dot(this.direction);\n    if (denominator * distToPoint < 0) {\n      return true;\n    }\n    return false;\n  }\n  intersectBox(box, target) {\n    let tmin, tmax, tymin, tymax, tzmin, tzmax;\n    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n    const origin = this.origin;\n    if (invdirx >= 0) {\n      tmin = (box.min.x - origin.x) * invdirx;\n      tmax = (box.max.x - origin.x) * invdirx;\n    } else {\n      tmin = (box.max.x - origin.x) * invdirx;\n      tmax = (box.min.x - origin.x) * invdirx;\n    }\n    if (invdiry >= 0) {\n      tymin = (box.min.y - origin.y) * invdiry;\n      tymax = (box.max.y - origin.y) * invdiry;\n    } else {\n      tymin = (box.max.y - origin.y) * invdiry;\n      tymax = (box.min.y - origin.y) * invdiry;\n    }\n    if (tmin > tymax || tymin > tmax)\n      return null;\n    if (tymin > tmin || tmin !== tmin)\n      tmin = tymin;\n    if (tymax < tmax || tmax !== tmax)\n      tmax = tymax;\n    if (invdirz >= 0) {\n      tzmin = (box.min.z - origin.z) * invdirz;\n      tzmax = (box.max.z - origin.z) * invdirz;\n    } else {\n      tzmin = (box.max.z - origin.z) * invdirz;\n      tzmax = (box.min.z - origin.z) * invdirz;\n    }\n    if (tmin > tzmax || tzmin > tmax)\n      return null;\n    if (tzmin > tmin || tmin !== tmin)\n      tmin = tzmin;\n    if (tzmax < tmax || tmax !== tmax)\n      tmax = tzmax;\n    if (tmax < 0)\n      return null;\n    return this.at(tmin >= 0 ? tmin : tmax, target);\n  }\n  intersectsBox(box) {\n    return this.intersectBox(box, _vector$a) !== null;\n  }\n  intersectTriangle(a, b, c, backfaceCulling, target) {\n    _edge1.subVectors(b, a);\n    _edge2.subVectors(c, a);\n    _normal$1.crossVectors(_edge1, _edge2);\n    let DdN = this.direction.dot(_normal$1);\n    let sign2;\n    if (DdN > 0) {\n      if (backfaceCulling)\n        return null;\n      sign2 = 1;\n    } else if (DdN < 0) {\n      sign2 = -1;\n      DdN = -DdN;\n    } else {\n      return null;\n    }\n    _diff.subVectors(this.origin, a);\n    const DdQxE2 = sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n    if (DdQxE2 < 0) {\n      return null;\n    }\n    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff));\n    if (DdE1xQ < 0) {\n      return null;\n    }\n    if (DdQxE2 + DdE1xQ > DdN) {\n      return null;\n    }\n    const QdN = -sign2 * _diff.dot(_normal$1);\n    if (QdN < 0) {\n      return null;\n    }\n    return this.at(QdN / DdN, target);\n  }\n  applyMatrix4(matrix4) {\n    this.origin.applyMatrix4(matrix4);\n    this.direction.transformDirection(matrix4);\n    return this;\n  }\n  equals(ray) {\n    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass Matrix4 {\n  constructor() {\n    this.elements = [\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1\n    ];\n    if (arguments.length > 0) {\n      console.error(\"THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.\");\n    }\n  }\n  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n    const te = this.elements;\n    te[0] = n11;\n    te[4] = n12;\n    te[8] = n13;\n    te[12] = n14;\n    te[1] = n21;\n    te[5] = n22;\n    te[9] = n23;\n    te[13] = n24;\n    te[2] = n31;\n    te[6] = n32;\n    te[10] = n33;\n    te[14] = n34;\n    te[3] = n41;\n    te[7] = n42;\n    te[11] = n43;\n    te[15] = n44;\n    return this;\n  }\n  identity() {\n    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  clone() {\n    return new Matrix4().fromArray(this.elements);\n  }\n  copy(m) {\n    const te = this.elements;\n    const me = m.elements;\n    te[0] = me[0];\n    te[1] = me[1];\n    te[2] = me[2];\n    te[3] = me[3];\n    te[4] = me[4];\n    te[5] = me[5];\n    te[6] = me[6];\n    te[7] = me[7];\n    te[8] = me[8];\n    te[9] = me[9];\n    te[10] = me[10];\n    te[11] = me[11];\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    te[15] = me[15];\n    return this;\n  }\n  copyPosition(m) {\n    const te = this.elements, me = m.elements;\n    te[12] = me[12];\n    te[13] = me[13];\n    te[14] = me[14];\n    return this;\n  }\n  setFromMatrix3(m) {\n    const me = m.elements;\n    this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);\n    return this;\n  }\n  extractBasis(xAxis, yAxis, zAxis) {\n    xAxis.setFromMatrixColumn(this, 0);\n    yAxis.setFromMatrixColumn(this, 1);\n    zAxis.setFromMatrixColumn(this, 2);\n    return this;\n  }\n  makeBasis(xAxis, yAxis, zAxis) {\n    this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);\n    return this;\n  }\n  extractRotation(m) {\n    const te = this.elements;\n    const me = m.elements;\n    const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n    const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n    te[0] = me[0] * scaleX;\n    te[1] = me[1] * scaleX;\n    te[2] = me[2] * scaleX;\n    te[3] = 0;\n    te[4] = me[4] * scaleY;\n    te[5] = me[5] * scaleY;\n    te[6] = me[6] * scaleY;\n    te[7] = 0;\n    te[8] = me[8] * scaleZ;\n    te[9] = me[9] * scaleZ;\n    te[10] = me[10] * scaleZ;\n    te[11] = 0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromEuler(euler) {\n    if (!(euler && euler.isEuler)) {\n      console.error(\"THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.\");\n    }\n    const te = this.elements;\n    const x = euler.x, y = euler.y, z = euler.z;\n    const a = Math.cos(x), b = Math.sin(x);\n    const c = Math.cos(y), d = Math.sin(y);\n    const e = Math.cos(z), f = Math.sin(z);\n    if (euler.order === \"XYZ\") {\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\n      te[0] = c * e;\n      te[4] = -c * f;\n      te[8] = d;\n      te[1] = af + be * d;\n      te[5] = ae - bf * d;\n      te[9] = -b * c;\n      te[2] = bf - ae * d;\n      te[6] = be + af * d;\n      te[10] = a * c;\n    } else if (euler.order === \"YXZ\") {\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\n      te[0] = ce + df * b;\n      te[4] = de * b - cf;\n      te[8] = a * d;\n      te[1] = a * f;\n      te[5] = a * e;\n      te[9] = -b;\n      te[2] = cf * b - de;\n      te[6] = df + ce * b;\n      te[10] = a * c;\n    } else if (euler.order === \"ZXY\") {\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\n      te[0] = ce - df * b;\n      te[4] = -a * f;\n      te[8] = de + cf * b;\n      te[1] = cf + de * b;\n      te[5] = a * e;\n      te[9] = df - ce * b;\n      te[2] = -a * d;\n      te[6] = b;\n      te[10] = a * c;\n    } else if (euler.order === \"ZYX\") {\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\n      te[0] = c * e;\n      te[4] = be * d - af;\n      te[8] = ae * d + bf;\n      te[1] = c * f;\n      te[5] = bf * d + ae;\n      te[9] = af * d - be;\n      te[2] = -d;\n      te[6] = b * c;\n      te[10] = a * c;\n    } else if (euler.order === \"YZX\") {\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n      te[0] = c * e;\n      te[4] = bd - ac * f;\n      te[8] = bc * f + ad;\n      te[1] = f;\n      te[5] = a * e;\n      te[9] = -b * e;\n      te[2] = -d * e;\n      te[6] = ad * f + bc;\n      te[10] = ac - bd * f;\n    } else if (euler.order === \"XZY\") {\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n      te[0] = c * e;\n      te[4] = -f;\n      te[8] = d * e;\n      te[1] = ac * f + bd;\n      te[5] = a * e;\n      te[9] = ad * f - bc;\n      te[2] = bc * f - ad;\n      te[6] = b * e;\n      te[10] = bd * f + ac;\n    }\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[12] = 0;\n    te[13] = 0;\n    te[14] = 0;\n    te[15] = 1;\n    return this;\n  }\n  makeRotationFromQuaternion(q) {\n    return this.compose(_zero, q, _one);\n  }\n  lookAt(eye, target, up) {\n    const te = this.elements;\n    _z.subVectors(eye, target);\n    if (_z.lengthSq() === 0) {\n      _z.z = 1;\n    }\n    _z.normalize();\n    _x.crossVectors(up, _z);\n    if (_x.lengthSq() === 0) {\n      if (Math.abs(up.z) === 1) {\n        _z.x += 1e-4;\n      } else {\n        _z.z += 1e-4;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n    }\n    _x.normalize();\n    _y.crossVectors(_z, _x);\n    te[0] = _x.x;\n    te[4] = _y.x;\n    te[8] = _z.x;\n    te[1] = _x.y;\n    te[5] = _y.y;\n    te[9] = _z.y;\n    te[2] = _x.z;\n    te[6] = _y.z;\n    te[10] = _z.z;\n    return this;\n  }\n  multiply(m, n) {\n    if (n !== void 0) {\n      console.warn(\"THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.\");\n      return this.multiplyMatrices(m, n);\n    }\n    return this.multiplyMatrices(this, m);\n  }\n  premultiply(m) {\n    return this.multiplyMatrices(m, this);\n  }\n  multiplyMatrices(a, b) {\n    const ae = a.elements;\n    const be = b.elements;\n    const te = this.elements;\n    const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n    const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n    const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n    const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n    const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n    const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n    const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n    const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n    return this;\n  }\n  multiplyScalar(s) {\n    const te = this.elements;\n    te[0] *= s;\n    te[4] *= s;\n    te[8] *= s;\n    te[12] *= s;\n    te[1] *= s;\n    te[5] *= s;\n    te[9] *= s;\n    te[13] *= s;\n    te[2] *= s;\n    te[6] *= s;\n    te[10] *= s;\n    te[14] *= s;\n    te[3] *= s;\n    te[7] *= s;\n    te[11] *= s;\n    te[15] *= s;\n    return this;\n  }\n  determinant() {\n    const te = this.elements;\n    const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n    const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n    const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n    const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n    return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n  }\n  transpose() {\n    const te = this.elements;\n    let tmp2;\n    tmp2 = te[1];\n    te[1] = te[4];\n    te[4] = tmp2;\n    tmp2 = te[2];\n    te[2] = te[8];\n    te[8] = tmp2;\n    tmp2 = te[6];\n    te[6] = te[9];\n    te[9] = tmp2;\n    tmp2 = te[3];\n    te[3] = te[12];\n    te[12] = tmp2;\n    tmp2 = te[7];\n    te[7] = te[13];\n    te[13] = tmp2;\n    tmp2 = te[11];\n    te[11] = te[14];\n    te[14] = tmp2;\n    return this;\n  }\n  setPosition(x, y, z) {\n    const te = this.elements;\n    if (x.isVector3) {\n      te[12] = x.x;\n      te[13] = x.y;\n      te[14] = x.z;\n    } else {\n      te[12] = x;\n      te[13] = y;\n      te[14] = z;\n    }\n    return this;\n  }\n  invert() {\n    const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n    if (det === 0)\n      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    const detInv = 1 / det;\n    te[0] = t11 * detInv;\n    te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n    te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n    te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n    te[4] = t12 * detInv;\n    te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n    te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n    te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n    te[8] = t13 * detInv;\n    te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n    te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n    te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n    te[12] = t14 * detInv;\n    te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n    te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n    te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n    return this;\n  }\n  scale(v) {\n    const te = this.elements;\n    const x = v.x, y = v.y, z = v.z;\n    te[0] *= x;\n    te[4] *= y;\n    te[8] *= z;\n    te[1] *= x;\n    te[5] *= y;\n    te[9] *= z;\n    te[2] *= x;\n    te[6] *= y;\n    te[10] *= z;\n    te[3] *= x;\n    te[7] *= y;\n    te[11] *= z;\n    return this;\n  }\n  getMaxScaleOnAxis() {\n    const te = this.elements;\n    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n  }\n  makeTranslation(x, y, z) {\n    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationX(theta) {\n    const c = Math.cos(theta), s = Math.sin(theta);\n    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationY(theta) {\n    const c = Math.cos(theta), s = Math.sin(theta);\n    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationZ(theta) {\n    const c = Math.cos(theta), s = Math.sin(theta);\n    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeRotationAxis(axis, angle) {\n    const c = Math.cos(angle);\n    const s = Math.sin(angle);\n    const t = 1 - c;\n    const x = axis.x, y = axis.y, z = axis.z;\n    const tx = t * x, ty = t * y;\n    this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeScale(x, y, z) {\n    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);\n    return this;\n  }\n  makeShear(x, y, z) {\n    this.set(1, y, z, 0, x, 1, z, 0, x, y, 1, 0, 0, 0, 0, 1);\n    return this;\n  }\n  compose(position, quaternion, scale) {\n    const te = this.elements;\n    const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n    const x2 = x + x, y2 = y + y, z2 = z + z;\n    const xx = x * x2, xy = x * y2, xz = x * z2;\n    const yy = y * y2, yz = y * z2, zz = z * z2;\n    const wx = w * x2, wy = w * y2, wz = w * z2;\n    const sx = scale.x, sy = scale.y, sz = scale.z;\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n    te[12] = position.x;\n    te[13] = position.y;\n    te[14] = position.z;\n    te[15] = 1;\n    return this;\n  }\n  decompose(position, quaternion, scale) {\n    const te = this.elements;\n    let sx = _v1$5.set(te[0], te[1], te[2]).length();\n    const sy = _v1$5.set(te[4], te[5], te[6]).length();\n    const sz = _v1$5.set(te[8], te[9], te[10]).length();\n    const det = this.determinant();\n    if (det < 0)\n      sx = -sx;\n    position.x = te[12];\n    position.y = te[13];\n    position.z = te[14];\n    _m1$2.copy(this);\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n    _m1$2.elements[0] *= invSX;\n    _m1$2.elements[1] *= invSX;\n    _m1$2.elements[2] *= invSX;\n    _m1$2.elements[4] *= invSY;\n    _m1$2.elements[5] *= invSY;\n    _m1$2.elements[6] *= invSY;\n    _m1$2.elements[8] *= invSZ;\n    _m1$2.elements[9] *= invSZ;\n    _m1$2.elements[10] *= invSZ;\n    quaternion.setFromRotationMatrix(_m1$2);\n    scale.x = sx;\n    scale.y = sy;\n    scale.z = sz;\n    return this;\n  }\n  makePerspective(left, right, top, bottom, near, far) {\n    if (far === void 0) {\n      console.warn(\"THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.\");\n    }\n    const te = this.elements;\n    const x = 2 * near / (right - left);\n    const y = 2 * near / (top - bottom);\n    const a = (right + left) / (right - left);\n    const b = (top + bottom) / (top - bottom);\n    const c = -(far + near) / (far - near);\n    const d = -2 * far * near / (far - near);\n    te[0] = x;\n    te[4] = 0;\n    te[8] = a;\n    te[12] = 0;\n    te[1] = 0;\n    te[5] = y;\n    te[9] = b;\n    te[13] = 0;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = c;\n    te[14] = d;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = -1;\n    te[15] = 0;\n    return this;\n  }\n  makeOrthographic(left, right, top, bottom, near, far) {\n    const te = this.elements;\n    const w = 1 / (right - left);\n    const h = 1 / (top - bottom);\n    const p = 1 / (far - near);\n    const x = (right + left) * w;\n    const y = (top + bottom) * h;\n    const z = (far + near) * p;\n    te[0] = 2 * w;\n    te[4] = 0;\n    te[8] = 0;\n    te[12] = -x;\n    te[1] = 0;\n    te[5] = 2 * h;\n    te[9] = 0;\n    te[13] = -y;\n    te[2] = 0;\n    te[6] = 0;\n    te[10] = -2 * p;\n    te[14] = -z;\n    te[3] = 0;\n    te[7] = 0;\n    te[11] = 0;\n    te[15] = 1;\n    return this;\n  }\n  equals(matrix) {\n    const te = this.elements;\n    const me = matrix.elements;\n    for (let i = 0; i < 16; i++) {\n      if (te[i] !== me[i])\n        return false;\n    }\n    return true;\n  }\n  fromArray(array, offset = 0) {\n    for (let i = 0; i < 16; i++) {\n      this.elements[i] = array[i + offset];\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const te = this.elements;\n    array[offset] = te[0];\n    array[offset + 1] = te[1];\n    array[offset + 2] = te[2];\n    array[offset + 3] = te[3];\n    array[offset + 4] = te[4];\n    array[offset + 5] = te[5];\n    array[offset + 6] = te[6];\n    array[offset + 7] = te[7];\n    array[offset + 8] = te[8];\n    array[offset + 9] = te[9];\n    array[offset + 10] = te[10];\n    array[offset + 11] = te[11];\n    array[offset + 12] = te[12];\n    array[offset + 13] = te[13];\n    array[offset + 14] = te[14];\n    array[offset + 15] = te[15];\n    return array;\n  }\n}\nMatrix4.prototype.isMatrix4 = true;\nconst _v1$5 = /* @__PURE__ */ new Vector3();\nconst _m1$2 = /* @__PURE__ */ new Matrix4();\nconst _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\nconst _one = /* @__PURE__ */ new Vector3(1, 1, 1);\nconst _x = /* @__PURE__ */ new Vector3();\nconst _y = /* @__PURE__ */ new Vector3();\nconst _z = /* @__PURE__ */ new Vector3();\nconst _matrix$1 = /* @__PURE__ */ new Matrix4();\nconst _quaternion$3 = /* @__PURE__ */ new Quaternion();\nclass Euler {\n  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order;\n  }\n  get x() {\n    return this._x;\n  }\n  set x(value) {\n    this._x = value;\n    this._onChangeCallback();\n  }\n  get y() {\n    return this._y;\n  }\n  set y(value) {\n    this._y = value;\n    this._onChangeCallback();\n  }\n  get z() {\n    return this._z;\n  }\n  set z(value) {\n    this._z = value;\n    this._onChangeCallback();\n  }\n  get order() {\n    return this._order;\n  }\n  set order(value) {\n    this._order = value;\n    this._onChangeCallback();\n  }\n  set(x, y, z, order) {\n    this._x = x;\n    this._y = y;\n    this._z = z;\n    this._order = order || this._order;\n    this._onChangeCallback();\n    return this;\n  }\n  clone() {\n    return new this.constructor(this._x, this._y, this._z, this._order);\n  }\n  copy(euler) {\n    this._x = euler._x;\n    this._y = euler._y;\n    this._z = euler._z;\n    this._order = euler._order;\n    this._onChangeCallback();\n    return this;\n  }\n  setFromRotationMatrix(m, order, update) {\n    const te = m.elements;\n    const m11 = te[0], m12 = te[4], m13 = te[8];\n    const m21 = te[1], m22 = te[5], m23 = te[9];\n    const m31 = te[2], m32 = te[6], m33 = te[10];\n    order = order || this._order;\n    switch (order) {\n      case \"XYZ\":\n        this._y = Math.asin(clamp(m13, -1, 1));\n        if (Math.abs(m13) < 0.9999999) {\n          this._x = Math.atan2(-m23, m33);\n          this._z = Math.atan2(-m12, m11);\n        } else {\n          this._x = Math.atan2(m32, m22);\n          this._z = 0;\n        }\n        break;\n      case \"YXZ\":\n        this._x = Math.asin(-clamp(m23, -1, 1));\n        if (Math.abs(m23) < 0.9999999) {\n          this._y = Math.atan2(m13, m33);\n          this._z = Math.atan2(m21, m22);\n        } else {\n          this._y = Math.atan2(-m31, m11);\n          this._z = 0;\n        }\n        break;\n      case \"ZXY\":\n        this._x = Math.asin(clamp(m32, -1, 1));\n        if (Math.abs(m32) < 0.9999999) {\n          this._y = Math.atan2(-m31, m33);\n          this._z = Math.atan2(-m12, m22);\n        } else {\n          this._y = 0;\n          this._z = Math.atan2(m21, m11);\n        }\n        break;\n      case \"ZYX\":\n        this._y = Math.asin(-clamp(m31, -1, 1));\n        if (Math.abs(m31) < 0.9999999) {\n          this._x = Math.atan2(m32, m33);\n          this._z = Math.atan2(m21, m11);\n        } else {\n          this._x = 0;\n          this._z = Math.atan2(-m12, m22);\n        }\n        break;\n      case \"YZX\":\n        this._z = Math.asin(clamp(m21, -1, 1));\n        if (Math.abs(m21) < 0.9999999) {\n          this._x = Math.atan2(-m23, m22);\n          this._y = Math.atan2(-m31, m11);\n        } else {\n          this._x = 0;\n          this._y = Math.atan2(m13, m33);\n        }\n        break;\n      case \"XZY\":\n        this._z = Math.asin(-clamp(m12, -1, 1));\n        if (Math.abs(m12) < 0.9999999) {\n          this._x = Math.atan2(m32, m22);\n          this._y = Math.atan2(m13, m11);\n        } else {\n          this._x = Math.atan2(-m23, m33);\n          this._y = 0;\n        }\n        break;\n      default:\n        console.warn(\"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: \" + order);\n    }\n    this._order = order;\n    if (update !== false)\n      this._onChangeCallback();\n    return this;\n  }\n  setFromQuaternion(q, order, update) {\n    _matrix$1.makeRotationFromQuaternion(q);\n    return this.setFromRotationMatrix(_matrix$1, order, update);\n  }\n  setFromVector3(v, order) {\n    return this.set(v.x, v.y, v.z, order || this._order);\n  }\n  reorder(newOrder) {\n    _quaternion$3.setFromEuler(this);\n    return this.setFromQuaternion(_quaternion$3, newOrder);\n  }\n  equals(euler) {\n    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n  }\n  fromArray(array) {\n    this._x = array[0];\n    this._y = array[1];\n    this._z = array[2];\n    if (array[3] !== void 0)\n      this._order = array[3];\n    this._onChangeCallback();\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this._x;\n    array[offset + 1] = this._y;\n    array[offset + 2] = this._z;\n    array[offset + 3] = this._order;\n    return array;\n  }\n  toVector3(optionalResult) {\n    if (optionalResult) {\n      return optionalResult.set(this._x, this._y, this._z);\n    } else {\n      return new Vector3(this._x, this._y, this._z);\n    }\n  }\n  _onChange(callback) {\n    this._onChangeCallback = callback;\n    return this;\n  }\n  _onChangeCallback() {\n  }\n}\nEuler.prototype.isEuler = true;\nEuler.DefaultOrder = \"XYZ\";\nEuler.RotationOrders = [\"XYZ\", \"YZX\", \"ZXY\", \"XZY\", \"YXZ\", \"ZYX\"];\nclass Layers {\n  constructor() {\n    this.mask = 1 | 0;\n  }\n  set(channel) {\n    this.mask = 1 << channel | 0;\n  }\n  enable(channel) {\n    this.mask |= 1 << channel | 0;\n  }\n  enableAll() {\n    this.mask = 4294967295 | 0;\n  }\n  toggle(channel) {\n    this.mask ^= 1 << channel | 0;\n  }\n  disable(channel) {\n    this.mask &= ~(1 << channel | 0);\n  }\n  disableAll() {\n    this.mask = 0;\n  }\n  test(layers) {\n    return (this.mask & layers.mask) !== 0;\n  }\n}\nlet _object3DId = 0;\nconst _v1$4 = new Vector3();\nconst _q1 = new Quaternion();\nconst _m1$1 = new Matrix4();\nconst _target = new Vector3();\nconst _position$3 = new Vector3();\nconst _scale$2 = new Vector3();\nconst _quaternion$2 = new Quaternion();\nconst _xAxis = new Vector3(1, 0, 0);\nconst _yAxis = new Vector3(0, 1, 0);\nconst _zAxis = new Vector3(0, 0, 1);\nconst _addedEvent = {type: \"added\"};\nconst _removedEvent = {type: \"removed\"};\nclass Object3D extends EventDispatcher {\n  constructor() {\n    super();\n    Object.defineProperty(this, \"id\", {value: _object3DId++});\n    this.uuid = generateUUID();\n    this.name = \"\";\n    this.type = \"Object3D\";\n    this.parent = null;\n    this.children = [];\n    this.up = Object3D.DefaultUp.clone();\n    const position = new Vector3();\n    const rotation = new Euler();\n    const quaternion = new Quaternion();\n    const scale = new Vector3(1, 1, 1);\n    function onRotationChange() {\n      quaternion.setFromEuler(rotation, false);\n    }\n    function onQuaternionChange() {\n      rotation.setFromQuaternion(quaternion, void 0, false);\n    }\n    rotation._onChange(onRotationChange);\n    quaternion._onChange(onQuaternionChange);\n    Object.defineProperties(this, {\n      position: {\n        configurable: true,\n        enumerable: true,\n        value: position\n      },\n      rotation: {\n        configurable: true,\n        enumerable: true,\n        value: rotation\n      },\n      quaternion: {\n        configurable: true,\n        enumerable: true,\n        value: quaternion\n      },\n      scale: {\n        configurable: true,\n        enumerable: true,\n        value: scale\n      },\n      modelViewMatrix: {\n        value: new Matrix4()\n      },\n      normalMatrix: {\n        value: new Matrix3()\n      }\n    });\n    this.matrix = new Matrix4();\n    this.matrixWorld = new Matrix4();\n    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = false;\n    this.layers = new Layers();\n    this.visible = true;\n    this.castShadow = false;\n    this.receiveShadow = false;\n    this.frustumCulled = true;\n    this.renderOrder = 0;\n    this.animations = [];\n    this.userData = {};\n  }\n  onBeforeRender() {\n  }\n  onAfterRender() {\n  }\n  applyMatrix4(matrix) {\n    if (this.matrixAutoUpdate)\n      this.updateMatrix();\n    this.matrix.premultiply(matrix);\n    this.matrix.decompose(this.position, this.quaternion, this.scale);\n  }\n  applyQuaternion(q) {\n    this.quaternion.premultiply(q);\n    return this;\n  }\n  setRotationFromAxisAngle(axis, angle) {\n    this.quaternion.setFromAxisAngle(axis, angle);\n  }\n  setRotationFromEuler(euler) {\n    this.quaternion.setFromEuler(euler, true);\n  }\n  setRotationFromMatrix(m) {\n    this.quaternion.setFromRotationMatrix(m);\n  }\n  setRotationFromQuaternion(q) {\n    this.quaternion.copy(q);\n  }\n  rotateOnAxis(axis, angle) {\n    _q1.setFromAxisAngle(axis, angle);\n    this.quaternion.multiply(_q1);\n    return this;\n  }\n  rotateOnWorldAxis(axis, angle) {\n    _q1.setFromAxisAngle(axis, angle);\n    this.quaternion.premultiply(_q1);\n    return this;\n  }\n  rotateX(angle) {\n    return this.rotateOnAxis(_xAxis, angle);\n  }\n  rotateY(angle) {\n    return this.rotateOnAxis(_yAxis, angle);\n  }\n  rotateZ(angle) {\n    return this.rotateOnAxis(_zAxis, angle);\n  }\n  translateOnAxis(axis, distance) {\n    _v1$4.copy(axis).applyQuaternion(this.quaternion);\n    this.position.add(_v1$4.multiplyScalar(distance));\n    return this;\n  }\n  translateX(distance) {\n    return this.translateOnAxis(_xAxis, distance);\n  }\n  translateY(distance) {\n    return this.translateOnAxis(_yAxis, distance);\n  }\n  translateZ(distance) {\n    return this.translateOnAxis(_zAxis, distance);\n  }\n  localToWorld(vector) {\n    return vector.applyMatrix4(this.matrixWorld);\n  }\n  worldToLocal(vector) {\n    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n  }\n  lookAt(x, y, z) {\n    if (x.isVector3) {\n      _target.copy(x);\n    } else {\n      _target.set(x, y, z);\n    }\n    const parent = this.parent;\n    this.updateWorldMatrix(true, false);\n    _position$3.setFromMatrixPosition(this.matrixWorld);\n    if (this.isCamera || this.isLight) {\n      _m1$1.lookAt(_position$3, _target, this.up);\n    } else {\n      _m1$1.lookAt(_target, _position$3, this.up);\n    }\n    this.quaternion.setFromRotationMatrix(_m1$1);\n    if (parent) {\n      _m1$1.extractRotation(parent.matrixWorld);\n      _q1.setFromRotationMatrix(_m1$1);\n      this.quaternion.premultiply(_q1.invert());\n    }\n  }\n  add(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n      return this;\n    }\n    if (object === this) {\n      console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n      return this;\n    }\n    if (object && object.isObject3D) {\n      if (object.parent !== null) {\n        object.parent.remove(object);\n      }\n      object.parent = this;\n      this.children.push(object);\n      object.dispatchEvent(_addedEvent);\n    } else {\n      console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\n    }\n    return this;\n  }\n  remove(object) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.remove(arguments[i]);\n      }\n      return this;\n    }\n    const index = this.children.indexOf(object);\n    if (index !== -1) {\n      object.parent = null;\n      this.children.splice(index, 1);\n      object.dispatchEvent(_removedEvent);\n    }\n    return this;\n  }\n  clear() {\n    for (let i = 0; i < this.children.length; i++) {\n      const object = this.children[i];\n      object.parent = null;\n      object.dispatchEvent(_removedEvent);\n    }\n    this.children.length = 0;\n    return this;\n  }\n  attach(object) {\n    this.updateWorldMatrix(true, false);\n    _m1$1.copy(this.matrixWorld).invert();\n    if (object.parent !== null) {\n      object.parent.updateWorldMatrix(true, false);\n      _m1$1.multiply(object.parent.matrixWorld);\n    }\n    object.applyMatrix4(_m1$1);\n    this.add(object);\n    object.updateWorldMatrix(false, true);\n    return this;\n  }\n  getObjectById(id) {\n    return this.getObjectByProperty(\"id\", id);\n  }\n  getObjectByName(name) {\n    return this.getObjectByProperty(\"name\", name);\n  }\n  getObjectByProperty(name, value) {\n    if (this[name] === value)\n      return this;\n    for (let i = 0, l = this.children.length; i < l; i++) {\n      const child = this.children[i];\n      const object = child.getObjectByProperty(name, value);\n      if (object !== void 0) {\n        return object;\n      }\n    }\n    return void 0;\n  }\n  getWorldPosition(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Object3D: .getWorldPosition() target is now required\");\n      target = new Vector3();\n    }\n    this.updateWorldMatrix(true, false);\n    return target.setFromMatrixPosition(this.matrixWorld);\n  }\n  getWorldQuaternion(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Object3D: .getWorldQuaternion() target is now required\");\n      target = new Quaternion();\n    }\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, target, _scale$2);\n    return target;\n  }\n  getWorldScale(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Object3D: .getWorldScale() target is now required\");\n      target = new Vector3();\n    }\n    this.updateWorldMatrix(true, false);\n    this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n    return target;\n  }\n  getWorldDirection(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Object3D: .getWorldDirection() target is now required\");\n      target = new Vector3();\n    }\n    this.updateWorldMatrix(true, false);\n    const e = this.matrixWorld.elements;\n    return target.set(e[8], e[9], e[10]).normalize();\n  }\n  raycast() {\n  }\n  traverse(callback) {\n    callback(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverse(callback);\n    }\n  }\n  traverseVisible(callback) {\n    if (this.visible === false)\n      return;\n    callback(this);\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].traverseVisible(callback);\n    }\n  }\n  traverseAncestors(callback) {\n    const parent = this.parent;\n    if (parent !== null) {\n      callback(parent);\n      parent.traverseAncestors(callback);\n    }\n  }\n  updateMatrix() {\n    this.matrix.compose(this.position, this.quaternion, this.scale);\n    this.matrixWorldNeedsUpdate = true;\n  }\n  updateMatrixWorld(force) {\n    if (this.matrixAutoUpdate)\n      this.updateMatrix();\n    if (this.matrixWorldNeedsUpdate || force) {\n      if (this.parent === null) {\n        this.matrixWorld.copy(this.matrix);\n      } else {\n        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n      }\n      this.matrixWorldNeedsUpdate = false;\n      force = true;\n    }\n    const children = this.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      children[i].updateMatrixWorld(force);\n    }\n  }\n  updateWorldMatrix(updateParents, updateChildren) {\n    const parent = this.parent;\n    if (updateParents === true && parent !== null) {\n      parent.updateWorldMatrix(true, false);\n    }\n    if (this.matrixAutoUpdate)\n      this.updateMatrix();\n    if (this.parent === null) {\n      this.matrixWorld.copy(this.matrix);\n    } else {\n      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n    }\n    if (updateChildren === true) {\n      const children = this.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateWorldMatrix(false, true);\n      }\n    }\n  }\n  toJSON(meta) {\n    const isRootObject = meta === void 0 || typeof meta === \"string\";\n    const output = {};\n    if (isRootObject) {\n      meta = {\n        geometries: {},\n        materials: {},\n        textures: {},\n        images: {},\n        shapes: {},\n        skeletons: {},\n        animations: {}\n      };\n      output.metadata = {\n        version: 4.5,\n        type: \"Object\",\n        generator: \"Object3D.toJSON\"\n      };\n    }\n    const object = {};\n    object.uuid = this.uuid;\n    object.type = this.type;\n    if (this.name !== \"\")\n      object.name = this.name;\n    if (this.castShadow === true)\n      object.castShadow = true;\n    if (this.receiveShadow === true)\n      object.receiveShadow = true;\n    if (this.visible === false)\n      object.visible = false;\n    if (this.frustumCulled === false)\n      object.frustumCulled = false;\n    if (this.renderOrder !== 0)\n      object.renderOrder = this.renderOrder;\n    if (JSON.stringify(this.userData) !== \"{}\")\n      object.userData = this.userData;\n    object.layers = this.layers.mask;\n    object.matrix = this.matrix.toArray();\n    if (this.matrixAutoUpdate === false)\n      object.matrixAutoUpdate = false;\n    if (this.isInstancedMesh) {\n      object.type = \"InstancedMesh\";\n      object.count = this.count;\n      object.instanceMatrix = this.instanceMatrix.toJSON();\n      if (this.instanceColor !== null)\n        object.instanceColor = this.instanceColor.toJSON();\n    }\n    function serialize(library, element) {\n      if (library[element.uuid] === void 0) {\n        library[element.uuid] = element.toJSON(meta);\n      }\n      return element.uuid;\n    }\n    if (this.isMesh || this.isLine || this.isPoints) {\n      object.geometry = serialize(meta.geometries, this.geometry);\n      const parameters = this.geometry.parameters;\n      if (parameters !== void 0 && parameters.shapes !== void 0) {\n        const shapes = parameters.shapes;\n        if (Array.isArray(shapes)) {\n          for (let i = 0, l = shapes.length; i < l; i++) {\n            const shape = shapes[i];\n            serialize(meta.shapes, shape);\n          }\n        } else {\n          serialize(meta.shapes, shapes);\n        }\n      }\n    }\n    if (this.isSkinnedMesh) {\n      object.bindMode = this.bindMode;\n      object.bindMatrix = this.bindMatrix.toArray();\n      if (this.skeleton !== void 0) {\n        serialize(meta.skeletons, this.skeleton);\n        object.skeleton = this.skeleton.uuid;\n      }\n    }\n    if (this.material !== void 0) {\n      if (Array.isArray(this.material)) {\n        const uuids = [];\n        for (let i = 0, l = this.material.length; i < l; i++) {\n          uuids.push(serialize(meta.materials, this.material[i]));\n        }\n        object.material = uuids;\n      } else {\n        object.material = serialize(meta.materials, this.material);\n      }\n    }\n    if (this.children.length > 0) {\n      object.children = [];\n      for (let i = 0; i < this.children.length; i++) {\n        object.children.push(this.children[i].toJSON(meta).object);\n      }\n    }\n    if (this.animations.length > 0) {\n      object.animations = [];\n      for (let i = 0; i < this.animations.length; i++) {\n        const animation = this.animations[i];\n        object.animations.push(serialize(meta.animations, animation));\n      }\n    }\n    if (isRootObject) {\n      const geometries = extractFromCache(meta.geometries);\n      const materials = extractFromCache(meta.materials);\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      const shapes = extractFromCache(meta.shapes);\n      const skeletons = extractFromCache(meta.skeletons);\n      const animations = extractFromCache(meta.animations);\n      if (geometries.length > 0)\n        output.geometries = geometries;\n      if (materials.length > 0)\n        output.materials = materials;\n      if (textures.length > 0)\n        output.textures = textures;\n      if (images.length > 0)\n        output.images = images;\n      if (shapes.length > 0)\n        output.shapes = shapes;\n      if (skeletons.length > 0)\n        output.skeletons = skeletons;\n      if (animations.length > 0)\n        output.animations = animations;\n    }\n    output.object = object;\n    return output;\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data = cache[key];\n        delete data.metadata;\n        values.push(data);\n      }\n      return values;\n    }\n  }\n  clone(recursive) {\n    return new this.constructor().copy(this, recursive);\n  }\n  copy(source, recursive = true) {\n    this.name = source.name;\n    this.up.copy(source.up);\n    this.position.copy(source.position);\n    this.rotation.order = source.rotation.order;\n    this.quaternion.copy(source.quaternion);\n    this.scale.copy(source.scale);\n    this.matrix.copy(source.matrix);\n    this.matrixWorld.copy(source.matrixWorld);\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n    this.layers.mask = source.layers.mask;\n    this.visible = source.visible;\n    this.castShadow = source.castShadow;\n    this.receiveShadow = source.receiveShadow;\n    this.frustumCulled = source.frustumCulled;\n    this.renderOrder = source.renderOrder;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    if (recursive === true) {\n      for (let i = 0; i < source.children.length; i++) {\n        const child = source.children[i];\n        this.add(child.clone());\n      }\n    }\n    return this;\n  }\n}\nObject3D.DefaultUp = new Vector3(0, 1, 0);\nObject3D.DefaultMatrixAutoUpdate = true;\nObject3D.prototype.isObject3D = true;\nconst _vector1 = /* @__PURE__ */ new Vector3();\nconst _vector2$1 = /* @__PURE__ */ new Vector3();\nconst _normalMatrix = /* @__PURE__ */ new Matrix3();\nclass Plane {\n  constructor(normal = new Vector3(1, 0, 0), constant = 0) {\n    this.normal = normal;\n    this.constant = constant;\n  }\n  set(normal, constant) {\n    this.normal.copy(normal);\n    this.constant = constant;\n    return this;\n  }\n  setComponents(x, y, z, w) {\n    this.normal.set(x, y, z);\n    this.constant = w;\n    return this;\n  }\n  setFromNormalAndCoplanarPoint(normal, point) {\n    this.normal.copy(normal);\n    this.constant = -point.dot(this.normal);\n    return this;\n  }\n  setFromCoplanarPoints(a, b, c) {\n    const normal = _vector1.subVectors(c, b).cross(_vector2$1.subVectors(a, b)).normalize();\n    this.setFromNormalAndCoplanarPoint(normal, a);\n    return this;\n  }\n  copy(plane) {\n    this.normal.copy(plane.normal);\n    this.constant = plane.constant;\n    return this;\n  }\n  normalize() {\n    const inverseNormalLength = 1 / this.normal.length();\n    this.normal.multiplyScalar(inverseNormalLength);\n    this.constant *= inverseNormalLength;\n    return this;\n  }\n  negate() {\n    this.constant *= -1;\n    this.normal.negate();\n    return this;\n  }\n  distanceToPoint(point) {\n    return this.normal.dot(point) + this.constant;\n  }\n  distanceToSphere(sphere) {\n    return this.distanceToPoint(sphere.center) - sphere.radius;\n  }\n  projectPoint(point, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Plane: .projectPoint() target is now required\");\n      target = new Vector3();\n    }\n    return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point);\n  }\n  intersectLine(line, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Plane: .intersectLine() target is now required\");\n      target = new Vector3();\n    }\n    const direction = line.delta(_vector1);\n    const denominator = this.normal.dot(direction);\n    if (denominator === 0) {\n      if (this.distanceToPoint(line.start) === 0) {\n        return target.copy(line.start);\n      }\n      return null;\n    }\n    const t = -(line.start.dot(this.normal) + this.constant) / denominator;\n    if (t < 0 || t > 1) {\n      return null;\n    }\n    return target.copy(direction).multiplyScalar(t).add(line.start);\n  }\n  intersectsLine(line) {\n    const startSign = this.distanceToPoint(line.start);\n    const endSign = this.distanceToPoint(line.end);\n    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;\n  }\n  intersectsBox(box) {\n    return box.intersectsPlane(this);\n  }\n  intersectsSphere(sphere) {\n    return sphere.intersectsPlane(this);\n  }\n  coplanarPoint(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Plane: .coplanarPoint() target is now required\");\n      target = new Vector3();\n    }\n    return target.copy(this.normal).multiplyScalar(-this.constant);\n  }\n  applyMatrix4(matrix, optionalNormalMatrix) {\n    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);\n    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);\n    const normal = this.normal.applyMatrix3(normalMatrix).normalize();\n    this.constant = -referencePoint.dot(normal);\n    return this;\n  }\n  translate(offset) {\n    this.constant -= offset.dot(this.normal);\n    return this;\n  }\n  equals(plane) {\n    return plane.normal.equals(this.normal) && plane.constant === this.constant;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nPlane.prototype.isPlane = true;\nconst _v0$1 = /* @__PURE__ */ new Vector3();\nconst _v1$3 = /* @__PURE__ */ new Vector3();\nconst _v2$2 = /* @__PURE__ */ new Vector3();\nconst _v3$1 = /* @__PURE__ */ new Vector3();\nconst _vab = /* @__PURE__ */ new Vector3();\nconst _vac = /* @__PURE__ */ new Vector3();\nconst _vbc = /* @__PURE__ */ new Vector3();\nconst _vap = /* @__PURE__ */ new Vector3();\nconst _vbp = /* @__PURE__ */ new Vector3();\nconst _vcp = /* @__PURE__ */ new Vector3();\nclass Triangle {\n  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n  }\n  static getNormal(a, b, c, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Triangle: .getNormal() target is now required\");\n      target = new Vector3();\n    }\n    target.subVectors(c, b);\n    _v0$1.subVectors(a, b);\n    target.cross(_v0$1);\n    const targetLengthSq = target.lengthSq();\n    if (targetLengthSq > 0) {\n      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n    }\n    return target.set(0, 0, 0);\n  }\n  static getBarycoord(point, a, b, c, target) {\n    _v0$1.subVectors(c, a);\n    _v1$3.subVectors(b, a);\n    _v2$2.subVectors(point, a);\n    const dot00 = _v0$1.dot(_v0$1);\n    const dot01 = _v0$1.dot(_v1$3);\n    const dot02 = _v0$1.dot(_v2$2);\n    const dot11 = _v1$3.dot(_v1$3);\n    const dot12 = _v1$3.dot(_v2$2);\n    const denom = dot00 * dot11 - dot01 * dot01;\n    if (target === void 0) {\n      console.warn(\"THREE.Triangle: .getBarycoord() target is now required\");\n      target = new Vector3();\n    }\n    if (denom === 0) {\n      return target.set(-2, -1, -1);\n    }\n    const invDenom = 1 / denom;\n    const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    return target.set(1 - u - v, v, u);\n  }\n  static containsPoint(point, a, b, c) {\n    this.getBarycoord(point, a, b, c, _v3$1);\n    return _v3$1.x >= 0 && _v3$1.y >= 0 && _v3$1.x + _v3$1.y <= 1;\n  }\n  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {\n    this.getBarycoord(point, p1, p2, p3, _v3$1);\n    target.set(0, 0);\n    target.addScaledVector(uv1, _v3$1.x);\n    target.addScaledVector(uv2, _v3$1.y);\n    target.addScaledVector(uv3, _v3$1.z);\n    return target;\n  }\n  static isFrontFacing(a, b, c, direction) {\n    _v0$1.subVectors(c, b);\n    _v1$3.subVectors(a, b);\n    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n  }\n  set(a, b, c) {\n    this.a.copy(a);\n    this.b.copy(b);\n    this.c.copy(c);\n    return this;\n  }\n  setFromPointsAndIndices(points, i0, i1, i2) {\n    this.a.copy(points[i0]);\n    this.b.copy(points[i1]);\n    this.c.copy(points[i2]);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(triangle) {\n    this.a.copy(triangle.a);\n    this.b.copy(triangle.b);\n    this.c.copy(triangle.c);\n    return this;\n  }\n  getArea() {\n    _v0$1.subVectors(this.c, this.b);\n    _v1$3.subVectors(this.a, this.b);\n    return _v0$1.cross(_v1$3).length() * 0.5;\n  }\n  getMidpoint(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Triangle: .getMidpoint() target is now required\");\n      target = new Vector3();\n    }\n    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n  }\n  getNormal(target) {\n    return Triangle.getNormal(this.a, this.b, this.c, target);\n  }\n  getPlane(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Triangle: .getPlane() target is now required\");\n      target = new Plane();\n    }\n    return target.setFromCoplanarPoints(this.a, this.b, this.c);\n  }\n  getBarycoord(point, target) {\n    return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n  }\n  getUV(point, uv1, uv2, uv3, target) {\n    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target);\n  }\n  containsPoint(point) {\n    return Triangle.containsPoint(point, this.a, this.b, this.c);\n  }\n  isFrontFacing(direction) {\n    return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n  }\n  intersectsBox(box) {\n    return box.intersectsTriangle(this);\n  }\n  closestPointToPoint(p, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Triangle: .closestPointToPoint() target is now required\");\n      target = new Vector3();\n    }\n    const a = this.a, b = this.b, c = this.c;\n    let v, w;\n    _vab.subVectors(b, a);\n    _vac.subVectors(c, a);\n    _vap.subVectors(p, a);\n    const d1 = _vab.dot(_vap);\n    const d2 = _vac.dot(_vap);\n    if (d1 <= 0 && d2 <= 0) {\n      return target.copy(a);\n    }\n    _vbp.subVectors(p, b);\n    const d3 = _vab.dot(_vbp);\n    const d4 = _vac.dot(_vbp);\n    if (d3 >= 0 && d4 <= d3) {\n      return target.copy(b);\n    }\n    const vc = d1 * d4 - d3 * d2;\n    if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n      v = d1 / (d1 - d3);\n      return target.copy(a).addScaledVector(_vab, v);\n    }\n    _vcp.subVectors(p, c);\n    const d5 = _vab.dot(_vcp);\n    const d6 = _vac.dot(_vcp);\n    if (d6 >= 0 && d5 <= d6) {\n      return target.copy(c);\n    }\n    const vb = d5 * d2 - d1 * d6;\n    if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n      w = d2 / (d2 - d6);\n      return target.copy(a).addScaledVector(_vac, w);\n    }\n    const va = d3 * d6 - d5 * d4;\n    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n      _vbc.subVectors(c, b);\n      w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n      return target.copy(b).addScaledVector(_vbc, w);\n    }\n    const denom = 1 / (va + vb + vc);\n    v = vb * denom;\n    w = vc * denom;\n    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n  }\n  equals(triangle) {\n    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n  }\n}\nlet materialId = 0;\nfunction Material() {\n  Object.defineProperty(this, \"id\", {value: materialId++});\n  this.uuid = generateUUID();\n  this.name = \"\";\n  this.type = \"Material\";\n  this.fog = true;\n  this.blending = NormalBlending;\n  this.side = FrontSide;\n  this.vertexColors = false;\n  this.opacity = 1;\n  this.transparent = false;\n  this.blendSrc = SrcAlphaFactor;\n  this.blendDst = OneMinusSrcAlphaFactor;\n  this.blendEquation = AddEquation;\n  this.blendSrcAlpha = null;\n  this.blendDstAlpha = null;\n  this.blendEquationAlpha = null;\n  this.depthFunc = LessEqualDepth;\n  this.depthTest = true;\n  this.depthWrite = true;\n  this.stencilWriteMask = 255;\n  this.stencilFunc = AlwaysStencilFunc;\n  this.stencilRef = 0;\n  this.stencilFuncMask = 255;\n  this.stencilFail = KeepStencilOp;\n  this.stencilZFail = KeepStencilOp;\n  this.stencilZPass = KeepStencilOp;\n  this.stencilWrite = false;\n  this.clippingPlanes = null;\n  this.clipIntersection = false;\n  this.clipShadows = false;\n  this.shadowSide = null;\n  this.colorWrite = true;\n  this.precision = null;\n  this.polygonOffset = false;\n  this.polygonOffsetFactor = 0;\n  this.polygonOffsetUnits = 0;\n  this.dithering = false;\n  this.alphaTest = 0;\n  this.alphaToCoverage = false;\n  this.premultipliedAlpha = false;\n  this.visible = true;\n  this.toneMapped = true;\n  this.userData = {};\n  this.version = 0;\n}\nMaterial.prototype = Object.assign(Object.create(EventDispatcher.prototype), {\n  constructor: Material,\n  isMaterial: true,\n  onBuild: function() {\n  },\n  onBeforeCompile: function() {\n  },\n  customProgramCacheKey: function() {\n    return this.onBeforeCompile.toString();\n  },\n  setValues: function(values) {\n    if (values === void 0)\n      return;\n    for (const key in values) {\n      const newValue = values[key];\n      if (newValue === void 0) {\n        console.warn(\"THREE.Material: '\" + key + \"' parameter is undefined.\");\n        continue;\n      }\n      if (key === \"shading\") {\n        console.warn(\"THREE.\" + this.type + \": .shading has been removed. Use the boolean .flatShading instead.\");\n        this.flatShading = newValue === FlatShading ? true : false;\n        continue;\n      }\n      const currentValue = this[key];\n      if (currentValue === void 0) {\n        console.warn(\"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\");\n        continue;\n      }\n      if (currentValue && currentValue.isColor) {\n        currentValue.set(newValue);\n      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n        currentValue.copy(newValue);\n      } else {\n        this[key] = newValue;\n      }\n    }\n  },\n  toJSON: function(meta) {\n    const isRoot = meta === void 0 || typeof meta === \"string\";\n    if (isRoot) {\n      meta = {\n        textures: {},\n        images: {}\n      };\n    }\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Material\",\n        generator: \"Material.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\")\n      data.name = this.name;\n    if (this.color && this.color.isColor)\n      data.color = this.color.getHex();\n    if (this.roughness !== void 0)\n      data.roughness = this.roughness;\n    if (this.metalness !== void 0)\n      data.metalness = this.metalness;\n    if (this.sheen && this.sheen.isColor)\n      data.sheen = this.sheen.getHex();\n    if (this.emissive && this.emissive.isColor)\n      data.emissive = this.emissive.getHex();\n    if (this.emissiveIntensity && this.emissiveIntensity !== 1)\n      data.emissiveIntensity = this.emissiveIntensity;\n    if (this.specular && this.specular.isColor)\n      data.specular = this.specular.getHex();\n    if (this.shininess !== void 0)\n      data.shininess = this.shininess;\n    if (this.clearcoat !== void 0)\n      data.clearcoat = this.clearcoat;\n    if (this.clearcoatRoughness !== void 0)\n      data.clearcoatRoughness = this.clearcoatRoughness;\n    if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n    }\n    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n    }\n    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n    }\n    if (this.map && this.map.isTexture)\n      data.map = this.map.toJSON(meta).uuid;\n    if (this.matcap && this.matcap.isTexture)\n      data.matcap = this.matcap.toJSON(meta).uuid;\n    if (this.alphaMap && this.alphaMap.isTexture)\n      data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n    if (this.lightMap && this.lightMap.isTexture) {\n      data.lightMap = this.lightMap.toJSON(meta).uuid;\n      data.lightMapIntensity = this.lightMapIntensity;\n    }\n    if (this.aoMap && this.aoMap.isTexture) {\n      data.aoMap = this.aoMap.toJSON(meta).uuid;\n      data.aoMapIntensity = this.aoMapIntensity;\n    }\n    if (this.bumpMap && this.bumpMap.isTexture) {\n      data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n      data.bumpScale = this.bumpScale;\n    }\n    if (this.normalMap && this.normalMap.isTexture) {\n      data.normalMap = this.normalMap.toJSON(meta).uuid;\n      data.normalMapType = this.normalMapType;\n      data.normalScale = this.normalScale.toArray();\n    }\n    if (this.displacementMap && this.displacementMap.isTexture) {\n      data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n      data.displacementScale = this.displacementScale;\n      data.displacementBias = this.displacementBias;\n    }\n    if (this.roughnessMap && this.roughnessMap.isTexture)\n      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n    if (this.metalnessMap && this.metalnessMap.isTexture)\n      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n    if (this.emissiveMap && this.emissiveMap.isTexture)\n      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n    if (this.specularMap && this.specularMap.isTexture)\n      data.specularMap = this.specularMap.toJSON(meta).uuid;\n    if (this.envMap && this.envMap.isTexture) {\n      data.envMap = this.envMap.toJSON(meta).uuid;\n      if (this.combine !== void 0)\n        data.combine = this.combine;\n    }\n    if (this.envMapIntensity !== void 0)\n      data.envMapIntensity = this.envMapIntensity;\n    if (this.reflectivity !== void 0)\n      data.reflectivity = this.reflectivity;\n    if (this.refractionRatio !== void 0)\n      data.refractionRatio = this.refractionRatio;\n    if (this.gradientMap && this.gradientMap.isTexture) {\n      data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n    }\n    if (this.size !== void 0)\n      data.size = this.size;\n    if (this.shadowSide !== null)\n      data.shadowSide = this.shadowSide;\n    if (this.sizeAttenuation !== void 0)\n      data.sizeAttenuation = this.sizeAttenuation;\n    if (this.blending !== NormalBlending)\n      data.blending = this.blending;\n    if (this.side !== FrontSide)\n      data.side = this.side;\n    if (this.vertexColors)\n      data.vertexColors = true;\n    if (this.opacity < 1)\n      data.opacity = this.opacity;\n    if (this.transparent === true)\n      data.transparent = this.transparent;\n    data.depthFunc = this.depthFunc;\n    data.depthTest = this.depthTest;\n    data.depthWrite = this.depthWrite;\n    data.colorWrite = this.colorWrite;\n    data.stencilWrite = this.stencilWrite;\n    data.stencilWriteMask = this.stencilWriteMask;\n    data.stencilFunc = this.stencilFunc;\n    data.stencilRef = this.stencilRef;\n    data.stencilFuncMask = this.stencilFuncMask;\n    data.stencilFail = this.stencilFail;\n    data.stencilZFail = this.stencilZFail;\n    data.stencilZPass = this.stencilZPass;\n    if (this.rotation && this.rotation !== 0)\n      data.rotation = this.rotation;\n    if (this.polygonOffset === true)\n      data.polygonOffset = true;\n    if (this.polygonOffsetFactor !== 0)\n      data.polygonOffsetFactor = this.polygonOffsetFactor;\n    if (this.polygonOffsetUnits !== 0)\n      data.polygonOffsetUnits = this.polygonOffsetUnits;\n    if (this.linewidth && this.linewidth !== 1)\n      data.linewidth = this.linewidth;\n    if (this.dashSize !== void 0)\n      data.dashSize = this.dashSize;\n    if (this.gapSize !== void 0)\n      data.gapSize = this.gapSize;\n    if (this.scale !== void 0)\n      data.scale = this.scale;\n    if (this.dithering === true)\n      data.dithering = true;\n    if (this.alphaTest > 0)\n      data.alphaTest = this.alphaTest;\n    if (this.alphaToCoverage === true)\n      data.alphaToCoverage = this.alphaToCoverage;\n    if (this.premultipliedAlpha === true)\n      data.premultipliedAlpha = this.premultipliedAlpha;\n    if (this.wireframe === true)\n      data.wireframe = this.wireframe;\n    if (this.wireframeLinewidth > 1)\n      data.wireframeLinewidth = this.wireframeLinewidth;\n    if (this.wireframeLinecap !== \"round\")\n      data.wireframeLinecap = this.wireframeLinecap;\n    if (this.wireframeLinejoin !== \"round\")\n      data.wireframeLinejoin = this.wireframeLinejoin;\n    if (this.morphTargets === true)\n      data.morphTargets = true;\n    if (this.morphNormals === true)\n      data.morphNormals = true;\n    if (this.skinning === true)\n      data.skinning = true;\n    if (this.flatShading === true)\n      data.flatShading = this.flatShading;\n    if (this.visible === false)\n      data.visible = false;\n    if (this.toneMapped === false)\n      data.toneMapped = false;\n    if (JSON.stringify(this.userData) !== \"{}\")\n      data.userData = this.userData;\n    function extractFromCache(cache) {\n      const values = [];\n      for (const key in cache) {\n        const data2 = cache[key];\n        delete data2.metadata;\n        values.push(data2);\n      }\n      return values;\n    }\n    if (isRoot) {\n      const textures = extractFromCache(meta.textures);\n      const images = extractFromCache(meta.images);\n      if (textures.length > 0)\n        data.textures = textures;\n      if (images.length > 0)\n        data.images = images;\n    }\n    return data;\n  },\n  clone: function() {\n    return new this.constructor().copy(this);\n  },\n  copy: function(source) {\n    this.name = source.name;\n    this.fog = source.fog;\n    this.blending = source.blending;\n    this.side = source.side;\n    this.vertexColors = source.vertexColors;\n    this.opacity = source.opacity;\n    this.transparent = source.transparent;\n    this.blendSrc = source.blendSrc;\n    this.blendDst = source.blendDst;\n    this.blendEquation = source.blendEquation;\n    this.blendSrcAlpha = source.blendSrcAlpha;\n    this.blendDstAlpha = source.blendDstAlpha;\n    this.blendEquationAlpha = source.blendEquationAlpha;\n    this.depthFunc = source.depthFunc;\n    this.depthTest = source.depthTest;\n    this.depthWrite = source.depthWrite;\n    this.stencilWriteMask = source.stencilWriteMask;\n    this.stencilFunc = source.stencilFunc;\n    this.stencilRef = source.stencilRef;\n    this.stencilFuncMask = source.stencilFuncMask;\n    this.stencilFail = source.stencilFail;\n    this.stencilZFail = source.stencilZFail;\n    this.stencilZPass = source.stencilZPass;\n    this.stencilWrite = source.stencilWrite;\n    const srcPlanes = source.clippingPlanes;\n    let dstPlanes = null;\n    if (srcPlanes !== null) {\n      const n = srcPlanes.length;\n      dstPlanes = new Array(n);\n      for (let i = 0; i !== n; ++i) {\n        dstPlanes[i] = srcPlanes[i].clone();\n      }\n    }\n    this.clippingPlanes = dstPlanes;\n    this.clipIntersection = source.clipIntersection;\n    this.clipShadows = source.clipShadows;\n    this.shadowSide = source.shadowSide;\n    this.colorWrite = source.colorWrite;\n    this.precision = source.precision;\n    this.polygonOffset = source.polygonOffset;\n    this.polygonOffsetFactor = source.polygonOffsetFactor;\n    this.polygonOffsetUnits = source.polygonOffsetUnits;\n    this.dithering = source.dithering;\n    this.alphaTest = source.alphaTest;\n    this.alphaToCoverage = source.alphaToCoverage;\n    this.premultipliedAlpha = source.premultipliedAlpha;\n    this.visible = source.visible;\n    this.toneMapped = source.toneMapped;\n    this.userData = JSON.parse(JSON.stringify(source.userData));\n    return this;\n  },\n  dispose: function() {\n    this.dispatchEvent({type: \"dispose\"});\n  }\n});\nObject.defineProperty(Material.prototype, \"needsUpdate\", {\n  set: function(value) {\n    if (value === true)\n      this.version++;\n  }\n});\nconst _colorKeywords = {\n  \"aliceblue\": 15792383,\n  \"antiquewhite\": 16444375,\n  \"aqua\": 65535,\n  \"aquamarine\": 8388564,\n  \"azure\": 15794175,\n  \"beige\": 16119260,\n  \"bisque\": 16770244,\n  \"black\": 0,\n  \"blanchedalmond\": 16772045,\n  \"blue\": 255,\n  \"blueviolet\": 9055202,\n  \"brown\": 10824234,\n  \"burlywood\": 14596231,\n  \"cadetblue\": 6266528,\n  \"chartreuse\": 8388352,\n  \"chocolate\": 13789470,\n  \"coral\": 16744272,\n  \"cornflowerblue\": 6591981,\n  \"cornsilk\": 16775388,\n  \"crimson\": 14423100,\n  \"cyan\": 65535,\n  \"darkblue\": 139,\n  \"darkcyan\": 35723,\n  \"darkgoldenrod\": 12092939,\n  \"darkgray\": 11119017,\n  \"darkgreen\": 25600,\n  \"darkgrey\": 11119017,\n  \"darkkhaki\": 12433259,\n  \"darkmagenta\": 9109643,\n  \"darkolivegreen\": 5597999,\n  \"darkorange\": 16747520,\n  \"darkorchid\": 10040012,\n  \"darkred\": 9109504,\n  \"darksalmon\": 15308410,\n  \"darkseagreen\": 9419919,\n  \"darkslateblue\": 4734347,\n  \"darkslategray\": 3100495,\n  \"darkslategrey\": 3100495,\n  \"darkturquoise\": 52945,\n  \"darkviolet\": 9699539,\n  \"deeppink\": 16716947,\n  \"deepskyblue\": 49151,\n  \"dimgray\": 6908265,\n  \"dimgrey\": 6908265,\n  \"dodgerblue\": 2003199,\n  \"firebrick\": 11674146,\n  \"floralwhite\": 16775920,\n  \"forestgreen\": 2263842,\n  \"fuchsia\": 16711935,\n  \"gainsboro\": 14474460,\n  \"ghostwhite\": 16316671,\n  \"gold\": 16766720,\n  \"goldenrod\": 14329120,\n  \"gray\": 8421504,\n  \"green\": 32768,\n  \"greenyellow\": 11403055,\n  \"grey\": 8421504,\n  \"honeydew\": 15794160,\n  \"hotpink\": 16738740,\n  \"indianred\": 13458524,\n  \"indigo\": 4915330,\n  \"ivory\": 16777200,\n  \"khaki\": 15787660,\n  \"lavender\": 15132410,\n  \"lavenderblush\": 16773365,\n  \"lawngreen\": 8190976,\n  \"lemonchiffon\": 16775885,\n  \"lightblue\": 11393254,\n  \"lightcoral\": 15761536,\n  \"lightcyan\": 14745599,\n  \"lightgoldenrodyellow\": 16448210,\n  \"lightgray\": 13882323,\n  \"lightgreen\": 9498256,\n  \"lightgrey\": 13882323,\n  \"lightpink\": 16758465,\n  \"lightsalmon\": 16752762,\n  \"lightseagreen\": 2142890,\n  \"lightskyblue\": 8900346,\n  \"lightslategray\": 7833753,\n  \"lightslategrey\": 7833753,\n  \"lightsteelblue\": 11584734,\n  \"lightyellow\": 16777184,\n  \"lime\": 65280,\n  \"limegreen\": 3329330,\n  \"linen\": 16445670,\n  \"magenta\": 16711935,\n  \"maroon\": 8388608,\n  \"mediumaquamarine\": 6737322,\n  \"mediumblue\": 205,\n  \"mediumorchid\": 12211667,\n  \"mediumpurple\": 9662683,\n  \"mediumseagreen\": 3978097,\n  \"mediumslateblue\": 8087790,\n  \"mediumspringgreen\": 64154,\n  \"mediumturquoise\": 4772300,\n  \"mediumvioletred\": 13047173,\n  \"midnightblue\": 1644912,\n  \"mintcream\": 16121850,\n  \"mistyrose\": 16770273,\n  \"moccasin\": 16770229,\n  \"navajowhite\": 16768685,\n  \"navy\": 128,\n  \"oldlace\": 16643558,\n  \"olive\": 8421376,\n  \"olivedrab\": 7048739,\n  \"orange\": 16753920,\n  \"orangered\": 16729344,\n  \"orchid\": 14315734,\n  \"palegoldenrod\": 15657130,\n  \"palegreen\": 10025880,\n  \"paleturquoise\": 11529966,\n  \"palevioletred\": 14381203,\n  \"papayawhip\": 16773077,\n  \"peachpuff\": 16767673,\n  \"peru\": 13468991,\n  \"pink\": 16761035,\n  \"plum\": 14524637,\n  \"powderblue\": 11591910,\n  \"purple\": 8388736,\n  \"rebeccapurple\": 6697881,\n  \"red\": 16711680,\n  \"rosybrown\": 12357519,\n  \"royalblue\": 4286945,\n  \"saddlebrown\": 9127187,\n  \"salmon\": 16416882,\n  \"sandybrown\": 16032864,\n  \"seagreen\": 3050327,\n  \"seashell\": 16774638,\n  \"sienna\": 10506797,\n  \"silver\": 12632256,\n  \"skyblue\": 8900331,\n  \"slateblue\": 6970061,\n  \"slategray\": 7372944,\n  \"slategrey\": 7372944,\n  \"snow\": 16775930,\n  \"springgreen\": 65407,\n  \"steelblue\": 4620980,\n  \"tan\": 13808780,\n  \"teal\": 32896,\n  \"thistle\": 14204888,\n  \"tomato\": 16737095,\n  \"turquoise\": 4251856,\n  \"violet\": 15631086,\n  \"wheat\": 16113331,\n  \"white\": 16777215,\n  \"whitesmoke\": 16119285,\n  \"yellow\": 16776960,\n  \"yellowgreen\": 10145074\n};\nconst _hslA = {h: 0, s: 0, l: 0};\nconst _hslB = {h: 0, s: 0, l: 0};\nfunction hue2rgb(p, q, t) {\n  if (t < 0)\n    t += 1;\n  if (t > 1)\n    t -= 1;\n  if (t < 1 / 6)\n    return p + (q - p) * 6 * t;\n  if (t < 1 / 2)\n    return q;\n  if (t < 2 / 3)\n    return p + (q - p) * 6 * (2 / 3 - t);\n  return p;\n}\nfunction SRGBToLinear(c) {\n  return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n}\nfunction LinearToSRGB(c) {\n  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n}\nclass Color {\n  constructor(r, g, b) {\n    if (g === void 0 && b === void 0) {\n      return this.set(r);\n    }\n    return this.setRGB(r, g, b);\n  }\n  set(value) {\n    if (value && value.isColor) {\n      this.copy(value);\n    } else if (typeof value === \"number\") {\n      this.setHex(value);\n    } else if (typeof value === \"string\") {\n      this.setStyle(value);\n    }\n    return this;\n  }\n  setScalar(scalar) {\n    this.r = scalar;\n    this.g = scalar;\n    this.b = scalar;\n    return this;\n  }\n  setHex(hex) {\n    hex = Math.floor(hex);\n    this.r = (hex >> 16 & 255) / 255;\n    this.g = (hex >> 8 & 255) / 255;\n    this.b = (hex & 255) / 255;\n    return this;\n  }\n  setRGB(r, g, b) {\n    this.r = r;\n    this.g = g;\n    this.b = b;\n    return this;\n  }\n  setHSL(h, s, l) {\n    h = euclideanModulo(h, 1);\n    s = clamp(s, 0, 1);\n    l = clamp(l, 0, 1);\n    if (s === 0) {\n      this.r = this.g = this.b = l;\n    } else {\n      const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n      const q = 2 * l - p;\n      this.r = hue2rgb(q, p, h + 1 / 3);\n      this.g = hue2rgb(q, p, h);\n      this.b = hue2rgb(q, p, h - 1 / 3);\n    }\n    return this;\n  }\n  setStyle(style) {\n    function handleAlpha(string) {\n      if (string === void 0)\n        return;\n      if (parseFloat(string) < 1) {\n        console.warn(\"THREE.Color: Alpha component of \" + style + \" will be ignored.\");\n      }\n    }\n    let m;\n    if (m = /^((?:rgb|hsl)a?)\\(([^\\)]*)\\)/.exec(style)) {\n      let color;\n      const name = m[1];\n      const components = m[2];\n      switch (name) {\n        case \"rgb\":\n        case \"rgba\":\n          if (color = /^\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            this.r = Math.min(255, parseInt(color[1], 10)) / 255;\n            this.g = Math.min(255, parseInt(color[2], 10)) / 255;\n            this.b = Math.min(255, parseInt(color[3], 10)) / 255;\n            handleAlpha(color[4]);\n            return this;\n          }\n          if (color = /^\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            this.r = Math.min(100, parseInt(color[1], 10)) / 100;\n            this.g = Math.min(100, parseInt(color[2], 10)) / 100;\n            this.b = Math.min(100, parseInt(color[3], 10)) / 100;\n            handleAlpha(color[4]);\n            return this;\n          }\n          break;\n        case \"hsl\":\n        case \"hsla\":\n          if (color = /^\\s*(\\d*\\.?\\d+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(?:,\\s*(\\d*\\.?\\d+)\\s*)?$/.exec(components)) {\n            const h = parseFloat(color[1]) / 360;\n            const s = parseInt(color[2], 10) / 100;\n            const l = parseInt(color[3], 10) / 100;\n            handleAlpha(color[4]);\n            return this.setHSL(h, s, l);\n          }\n          break;\n      }\n    } else if (m = /^\\#([A-Fa-f\\d]+)$/.exec(style)) {\n      const hex = m[1];\n      const size = hex.length;\n      if (size === 3) {\n        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;\n        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;\n        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;\n        return this;\n      } else if (size === 6) {\n        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;\n        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;\n        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;\n        return this;\n      }\n    }\n    if (style && style.length > 0) {\n      return this.setColorName(style);\n    }\n    return this;\n  }\n  setColorName(style) {\n    const hex = _colorKeywords[style.toLowerCase()];\n    if (hex !== void 0) {\n      this.setHex(hex);\n    } else {\n      console.warn(\"THREE.Color: Unknown color \" + style);\n    }\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.r, this.g, this.b);\n  }\n  copy(color) {\n    this.r = color.r;\n    this.g = color.g;\n    this.b = color.b;\n    return this;\n  }\n  copyGammaToLinear(color, gammaFactor = 2) {\n    this.r = Math.pow(color.r, gammaFactor);\n    this.g = Math.pow(color.g, gammaFactor);\n    this.b = Math.pow(color.b, gammaFactor);\n    return this;\n  }\n  copyLinearToGamma(color, gammaFactor = 2) {\n    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;\n    this.r = Math.pow(color.r, safeInverse);\n    this.g = Math.pow(color.g, safeInverse);\n    this.b = Math.pow(color.b, safeInverse);\n    return this;\n  }\n  convertGammaToLinear(gammaFactor) {\n    this.copyGammaToLinear(this, gammaFactor);\n    return this;\n  }\n  convertLinearToGamma(gammaFactor) {\n    this.copyLinearToGamma(this, gammaFactor);\n    return this;\n  }\n  copySRGBToLinear(color) {\n    this.r = SRGBToLinear(color.r);\n    this.g = SRGBToLinear(color.g);\n    this.b = SRGBToLinear(color.b);\n    return this;\n  }\n  copyLinearToSRGB(color) {\n    this.r = LinearToSRGB(color.r);\n    this.g = LinearToSRGB(color.g);\n    this.b = LinearToSRGB(color.b);\n    return this;\n  }\n  convertSRGBToLinear() {\n    this.copySRGBToLinear(this);\n    return this;\n  }\n  convertLinearToSRGB() {\n    this.copyLinearToSRGB(this);\n    return this;\n  }\n  getHex() {\n    return this.r * 255 << 16 ^ this.g * 255 << 8 ^ this.b * 255 << 0;\n  }\n  getHexString() {\n    return (\"000000\" + this.getHex().toString(16)).slice(-6);\n  }\n  getHSL(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Color: .getHSL() target is now required\");\n      target = {h: 0, s: 0, l: 0};\n    }\n    const r = this.r, g = this.g, b = this.b;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let hue, saturation;\n    const lightness = (min + max) / 2;\n    if (min === max) {\n      hue = 0;\n      saturation = 0;\n    } else {\n      const delta = max - min;\n      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);\n      switch (max) {\n        case r:\n          hue = (g - b) / delta + (g < b ? 6 : 0);\n          break;\n        case g:\n          hue = (b - r) / delta + 2;\n          break;\n        case b:\n          hue = (r - g) / delta + 4;\n          break;\n      }\n      hue /= 6;\n    }\n    target.h = hue;\n    target.s = saturation;\n    target.l = lightness;\n    return target;\n  }\n  getStyle() {\n    return \"rgb(\" + (this.r * 255 | 0) + \",\" + (this.g * 255 | 0) + \",\" + (this.b * 255 | 0) + \")\";\n  }\n  offsetHSL(h, s, l) {\n    this.getHSL(_hslA);\n    _hslA.h += h;\n    _hslA.s += s;\n    _hslA.l += l;\n    this.setHSL(_hslA.h, _hslA.s, _hslA.l);\n    return this;\n  }\n  add(color) {\n    this.r += color.r;\n    this.g += color.g;\n    this.b += color.b;\n    return this;\n  }\n  addColors(color1, color2) {\n    this.r = color1.r + color2.r;\n    this.g = color1.g + color2.g;\n    this.b = color1.b + color2.b;\n    return this;\n  }\n  addScalar(s) {\n    this.r += s;\n    this.g += s;\n    this.b += s;\n    return this;\n  }\n  sub(color) {\n    this.r = Math.max(0, this.r - color.r);\n    this.g = Math.max(0, this.g - color.g);\n    this.b = Math.max(0, this.b - color.b);\n    return this;\n  }\n  multiply(color) {\n    this.r *= color.r;\n    this.g *= color.g;\n    this.b *= color.b;\n    return this;\n  }\n  multiplyScalar(s) {\n    this.r *= s;\n    this.g *= s;\n    this.b *= s;\n    return this;\n  }\n  lerp(color, alpha) {\n    this.r += (color.r - this.r) * alpha;\n    this.g += (color.g - this.g) * alpha;\n    this.b += (color.b - this.b) * alpha;\n    return this;\n  }\n  lerpColors(color1, color2, alpha) {\n    this.r = color1.r + (color2.r - color1.r) * alpha;\n    this.g = color1.g + (color2.g - color1.g) * alpha;\n    this.b = color1.b + (color2.b - color1.b) * alpha;\n    return this;\n  }\n  lerpHSL(color, alpha) {\n    this.getHSL(_hslA);\n    color.getHSL(_hslB);\n    const h = lerp(_hslA.h, _hslB.h, alpha);\n    const s = lerp(_hslA.s, _hslB.s, alpha);\n    const l = lerp(_hslA.l, _hslB.l, alpha);\n    this.setHSL(h, s, l);\n    return this;\n  }\n  equals(c) {\n    return c.r === this.r && c.g === this.g && c.b === this.b;\n  }\n  fromArray(array, offset = 0) {\n    this.r = array[offset];\n    this.g = array[offset + 1];\n    this.b = array[offset + 2];\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    array[offset] = this.r;\n    array[offset + 1] = this.g;\n    array[offset + 2] = this.b;\n    return array;\n  }\n  fromBufferAttribute(attribute, index) {\n    this.r = attribute.getX(index);\n    this.g = attribute.getY(index);\n    this.b = attribute.getZ(index);\n    if (attribute.normalized === true) {\n      this.r /= 255;\n      this.g /= 255;\n      this.b /= 255;\n    }\n    return this;\n  }\n  toJSON() {\n    return this.getHex();\n  }\n}\nColor.NAMES = _colorKeywords;\nColor.prototype.isColor = true;\nColor.prototype.r = 1;\nColor.prototype.g = 1;\nColor.prototype.b = 1;\nclass MeshBasicMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"MeshBasicMaterial\";\n    this.color = new Color(16777215);\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.skinning = false;\n    this.morphTargets = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    return this;\n  }\n}\nMeshBasicMaterial.prototype.isMeshBasicMaterial = true;\nconst _vector$9 = new Vector3();\nconst _vector2 = new Vector2();\nclass BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    if (Array.isArray(array)) {\n      throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\n    }\n    this.name = \"\";\n    this.array = array;\n    this.itemSize = itemSize;\n    this.count = array !== void 0 ? array.length / itemSize : 0;\n    this.normalized = normalized === true;\n    this.usage = StaticDrawUsage;\n    this.updateRange = {offset: 0, count: -1};\n    this.version = 0;\n    this.onUploadCallback = function() {\n    };\n  }\n  set needsUpdate(value) {\n    if (value === true)\n      this.version++;\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  copy(source) {\n    this.name = source.name;\n    this.array = new source.array.constructor(source.array);\n    this.itemSize = source.itemSize;\n    this.count = source.count;\n    this.normalized = source.normalized;\n    this.usage = source.usage;\n    return this;\n  }\n  copyAt(index1, attribute, index2) {\n    index1 *= this.itemSize;\n    index2 *= attribute.itemSize;\n    for (let i = 0, l = this.itemSize; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n    return this;\n  }\n  copyArray(array) {\n    this.array.set(array);\n    return this;\n  }\n  copyColorsArray(colors) {\n    const array = this.array;\n    let offset = 0;\n    for (let i = 0, l = colors.length; i < l; i++) {\n      let color = colors[i];\n      if (color === void 0) {\n        console.warn(\"THREE.BufferAttribute.copyColorsArray(): color is undefined\", i);\n        color = new Color();\n      }\n      array[offset++] = color.r;\n      array[offset++] = color.g;\n      array[offset++] = color.b;\n    }\n    return this;\n  }\n  copyVector2sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n      if (vector === void 0) {\n        console.warn(\"THREE.BufferAttribute.copyVector2sArray(): vector is undefined\", i);\n        vector = new Vector2();\n      }\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n    }\n    return this;\n  }\n  copyVector3sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n      if (vector === void 0) {\n        console.warn(\"THREE.BufferAttribute.copyVector3sArray(): vector is undefined\", i);\n        vector = new Vector3();\n      }\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n    }\n    return this;\n  }\n  copyVector4sArray(vectors) {\n    const array = this.array;\n    let offset = 0;\n    for (let i = 0, l = vectors.length; i < l; i++) {\n      let vector = vectors[i];\n      if (vector === void 0) {\n        console.warn(\"THREE.BufferAttribute.copyVector4sArray(): vector is undefined\", i);\n        vector = new Vector4();\n      }\n      array[offset++] = vector.x;\n      array[offset++] = vector.y;\n      array[offset++] = vector.z;\n      array[offset++] = vector.w;\n    }\n    return this;\n  }\n  applyMatrix3(m) {\n    if (this.itemSize === 2) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector2.fromBufferAttribute(this, i);\n        _vector2.applyMatrix3(m);\n        this.setXY(i, _vector2.x, _vector2.y);\n      }\n    } else if (this.itemSize === 3) {\n      for (let i = 0, l = this.count; i < l; i++) {\n        _vector$9.fromBufferAttribute(this, i);\n        _vector$9.applyMatrix3(m);\n        this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n    }\n    return this;\n  }\n  applyMatrix4(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n      _vector$9.applyMatrix4(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n      _vector$9.applyNormalMatrix(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$9.x = this.getX(i);\n      _vector$9.y = this.getY(i);\n      _vector$9.z = this.getZ(i);\n      _vector$9.transformDirection(m);\n      this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);\n    }\n    return this;\n  }\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  getX(index) {\n    return this.array[index * this.itemSize];\n  }\n  setX(index, x) {\n    this.array[index * this.itemSize] = x;\n    return this;\n  }\n  getY(index) {\n    return this.array[index * this.itemSize + 1];\n  }\n  setY(index, y) {\n    this.array[index * this.itemSize + 1] = y;\n    return this;\n  }\n  getZ(index) {\n    return this.array[index * this.itemSize + 2];\n  }\n  setZ(index, z) {\n    this.array[index * this.itemSize + 2] = z;\n    return this;\n  }\n  getW(index) {\n    return this.array[index * this.itemSize + 3];\n  }\n  setW(index, w) {\n    this.array[index * this.itemSize + 3] = w;\n    return this;\n  }\n  setXY(index, x, y) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    return this;\n  }\n  setXYZ(index, x, y, z) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    return this;\n  }\n  setXYZW(index, x, y, z, w) {\n    index *= this.itemSize;\n    this.array[index + 0] = x;\n    this.array[index + 1] = y;\n    this.array[index + 2] = z;\n    this.array[index + 3] = w;\n    return this;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n  clone() {\n    return new this.constructor(this.array, this.itemSize).copy(this);\n  }\n  toJSON() {\n    const data = {\n      itemSize: this.itemSize,\n      type: this.array.constructor.name,\n      array: Array.prototype.slice.call(this.array),\n      normalized: this.normalized\n    };\n    if (this.name !== \"\")\n      data.name = this.name;\n    if (this.usage !== StaticDrawUsage)\n      data.usage = this.usage;\n    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)\n      data.updateRange = this.updateRange;\n    return data;\n  }\n}\nBufferAttribute.prototype.isBufferAttribute = true;\nclass Int8BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Int8Array(array), itemSize, normalized);\n  }\n}\nclass Uint8BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint8Array(array), itemSize, normalized);\n  }\n}\nclass Uint8ClampedBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint8ClampedArray(array), itemSize, normalized);\n  }\n}\nclass Int16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Int16Array(array), itemSize, normalized);\n  }\n}\nclass Uint16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n}\nclass Int32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Int32Array(array), itemSize, normalized);\n  }\n}\nclass Uint32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint32Array(array), itemSize, normalized);\n  }\n}\nclass Float16BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Uint16Array(array), itemSize, normalized);\n  }\n}\nFloat16BufferAttribute.prototype.isFloat16BufferAttribute = true;\nclass Float32BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Float32Array(array), itemSize, normalized);\n  }\n}\nclass Float64BufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized) {\n    super(new Float64Array(array), itemSize, normalized);\n  }\n}\nfunction arrayMax(array) {\n  if (array.length === 0)\n    return -Infinity;\n  let max = array[0];\n  for (let i = 1, l = array.length; i < l; ++i) {\n    if (array[i] > max)\n      max = array[i];\n  }\n  return max;\n}\nconst TYPED_ARRAYS = {\n  Int8Array,\n  Uint8Array,\n  Uint8ClampedArray,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array\n};\nfunction getTypedArray(type, buffer) {\n  return new TYPED_ARRAYS[type](buffer);\n}\nlet _id = 0;\nconst _m1 = new Matrix4();\nconst _obj = new Object3D();\nconst _offset = new Vector3();\nconst _box$1 = new Box3();\nconst _boxMorphTargets = new Box3();\nconst _vector$8 = new Vector3();\nclass BufferGeometry extends EventDispatcher {\n  constructor() {\n    super();\n    Object.defineProperty(this, \"id\", {value: _id++});\n    this.uuid = generateUUID();\n    this.name = \"\";\n    this.type = \"BufferGeometry\";\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.morphTargetsRelative = false;\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    this.drawRange = {start: 0, count: Infinity};\n    this.userData = {};\n  }\n  getIndex() {\n    return this.index;\n  }\n  setIndex(index) {\n    if (Array.isArray(index)) {\n      this.index = new (arrayMax(index) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n    } else {\n      this.index = index;\n    }\n    return this;\n  }\n  getAttribute(name) {\n    return this.attributes[name];\n  }\n  setAttribute(name, attribute) {\n    this.attributes[name] = attribute;\n    return this;\n  }\n  deleteAttribute(name) {\n    delete this.attributes[name];\n    return this;\n  }\n  hasAttribute(name) {\n    return this.attributes[name] !== void 0;\n  }\n  addGroup(start, count, materialIndex = 0) {\n    this.groups.push({\n      start,\n      count,\n      materialIndex\n    });\n  }\n  clearGroups() {\n    this.groups = [];\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  applyMatrix4(matrix) {\n    const position = this.attributes.position;\n    if (position !== void 0) {\n      position.applyMatrix4(matrix);\n      position.needsUpdate = true;\n    }\n    const normal = this.attributes.normal;\n    if (normal !== void 0) {\n      const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n      normal.applyNormalMatrix(normalMatrix);\n      normal.needsUpdate = true;\n    }\n    const tangent = this.attributes.tangent;\n    if (tangent !== void 0) {\n      tangent.transformDirection(matrix);\n      tangent.needsUpdate = true;\n    }\n    if (this.boundingBox !== null) {\n      this.computeBoundingBox();\n    }\n    if (this.boundingSphere !== null) {\n      this.computeBoundingSphere();\n    }\n    return this;\n  }\n  rotateX(angle) {\n    _m1.makeRotationX(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateY(angle) {\n    _m1.makeRotationY(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  rotateZ(angle) {\n    _m1.makeRotationZ(angle);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  translate(x, y, z) {\n    _m1.makeTranslation(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  scale(x, y, z) {\n    _m1.makeScale(x, y, z);\n    this.applyMatrix4(_m1);\n    return this;\n  }\n  lookAt(vector) {\n    _obj.lookAt(vector);\n    _obj.updateMatrix();\n    this.applyMatrix4(_obj.matrix);\n    return this;\n  }\n  center() {\n    this.computeBoundingBox();\n    this.boundingBox.getCenter(_offset).negate();\n    this.translate(_offset.x, _offset.y, _offset.z);\n    return this;\n  }\n  setFromPoints(points) {\n    const position = [];\n    for (let i = 0, l = points.length; i < l; i++) {\n      const point = points[i];\n      position.push(point.x, point.y, point.z || 0);\n    }\n    this.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n    return this;\n  }\n  computeBoundingBox() {\n    if (this.boundingBox === null) {\n      this.boundingBox = new Box3();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(Infinity, Infinity, Infinity));\n      return;\n    }\n    if (position !== void 0) {\n      this.boundingBox.setFromBufferAttribute(position);\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _box$1.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(this.boundingBox.min, _box$1.min);\n            this.boundingBox.expandByPoint(_vector$8);\n            _vector$8.addVectors(this.boundingBox.max, _box$1.max);\n            this.boundingBox.expandByPoint(_vector$8);\n          } else {\n            this.boundingBox.expandByPoint(_box$1.min);\n            this.boundingBox.expandByPoint(_box$1.max);\n          }\n        }\n      }\n    } else {\n      this.boundingBox.makeEmpty();\n    }\n    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n      console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n    }\n  }\n  computeBoundingSphere() {\n    if (this.boundingSphere === null) {\n      this.boundingSphere = new Sphere();\n    }\n    const position = this.attributes.position;\n    const morphAttributesPosition = this.morphAttributes.position;\n    if (position && position.isGLBufferAttribute) {\n      console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this);\n      this.boundingSphere.set(new Vector3(), Infinity);\n      return;\n    }\n    if (position) {\n      const center = this.boundingSphere.center;\n      _box$1.setFromBufferAttribute(position);\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n          if (this.morphTargetsRelative) {\n            _vector$8.addVectors(_box$1.min, _boxMorphTargets.min);\n            _box$1.expandByPoint(_vector$8);\n            _vector$8.addVectors(_box$1.max, _boxMorphTargets.max);\n            _box$1.expandByPoint(_vector$8);\n          } else {\n            _box$1.expandByPoint(_boxMorphTargets.min);\n            _box$1.expandByPoint(_boxMorphTargets.max);\n          }\n        }\n      }\n      _box$1.getCenter(center);\n      let maxRadiusSq = 0;\n      for (let i = 0, il = position.count; i < il; i++) {\n        _vector$8.fromBufferAttribute(position, i);\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n      }\n      if (morphAttributesPosition) {\n        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {\n          const morphAttribute = morphAttributesPosition[i];\n          const morphTargetsRelative = this.morphTargetsRelative;\n          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n            _vector$8.fromBufferAttribute(morphAttribute, j);\n            if (morphTargetsRelative) {\n              _offset.fromBufferAttribute(position, j);\n              _vector$8.add(_offset);\n            }\n            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n          }\n        }\n      }\n      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n      if (isNaN(this.boundingSphere.radius)) {\n        console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n  }\n  computeFaceNormals() {\n  }\n  computeTangents() {\n    const index = this.index;\n    const attributes = this.attributes;\n    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n      console.error(\"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\");\n      return;\n    }\n    const indices = index.array;\n    const positions = attributes.position.array;\n    const normals = attributes.normal.array;\n    const uvs = attributes.uv.array;\n    const nVertices = positions.length / 3;\n    if (attributes.tangent === void 0) {\n      this.setAttribute(\"tangent\", new BufferAttribute(new Float32Array(4 * nVertices), 4));\n    }\n    const tangents = attributes.tangent.array;\n    const tan1 = [], tan2 = [];\n    for (let i = 0; i < nVertices; i++) {\n      tan1[i] = new Vector3();\n      tan2[i] = new Vector3();\n    }\n    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n    function handleTriangle(a, b, c) {\n      vA.fromArray(positions, a * 3);\n      vB.fromArray(positions, b * 3);\n      vC.fromArray(positions, c * 3);\n      uvA.fromArray(uvs, a * 2);\n      uvB.fromArray(uvs, b * 2);\n      uvC.fromArray(uvs, c * 2);\n      vB.sub(vA);\n      vC.sub(vA);\n      uvB.sub(uvA);\n      uvC.sub(uvA);\n      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n      if (!isFinite(r))\n        return;\n      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n      tan1[a].add(sdir);\n      tan1[b].add(sdir);\n      tan1[c].add(sdir);\n      tan2[a].add(tdir);\n      tan2[b].add(tdir);\n      tan2[c].add(tdir);\n    }\n    let groups = this.groups;\n    if (groups.length === 0) {\n      groups = [{\n        start: 0,\n        count: indices.length\n      }];\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2]);\n      }\n    }\n    const tmp2 = new Vector3(), tmp22 = new Vector3();\n    const n = new Vector3(), n2 = new Vector3();\n    function handleVertex(v) {\n      n.fromArray(normals, v * 3);\n      n2.copy(n);\n      const t = tan1[v];\n      tmp2.copy(t);\n      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize();\n      tmp22.crossVectors(n2, t);\n      const test = tmp22.dot(tan2[v]);\n      const w = test < 0 ? -1 : 1;\n      tangents[v * 4] = tmp2.x;\n      tangents[v * 4 + 1] = tmp2.y;\n      tangents[v * 4 + 2] = tmp2.z;\n      tangents[v * 4 + 3] = w;\n    }\n    for (let i = 0, il = groups.length; i < il; ++i) {\n      const group = groups[i];\n      const start = group.start;\n      const count = group.count;\n      for (let j = start, jl = start + count; j < jl; j += 3) {\n        handleVertex(indices[j + 0]);\n        handleVertex(indices[j + 1]);\n        handleVertex(indices[j + 2]);\n      }\n    }\n  }\n  computeVertexNormals() {\n    const index = this.index;\n    const positionAttribute = this.getAttribute(\"position\");\n    if (positionAttribute !== void 0) {\n      let normalAttribute = this.getAttribute(\"normal\");\n      if (normalAttribute === void 0) {\n        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n        this.setAttribute(\"normal\", normalAttribute);\n      } else {\n        for (let i = 0, il = normalAttribute.count; i < il; i++) {\n          normalAttribute.setXYZ(i, 0, 0, 0);\n        }\n      }\n      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n      const cb = new Vector3(), ab = new Vector3();\n      if (index) {\n        for (let i = 0, il = index.count; i < il; i += 3) {\n          const vA = index.getX(i + 0);\n          const vB = index.getX(i + 1);\n          const vC = index.getX(i + 2);\n          pA.fromBufferAttribute(positionAttribute, vA);\n          pB.fromBufferAttribute(positionAttribute, vB);\n          pC.fromBufferAttribute(positionAttribute, vC);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          nA.fromBufferAttribute(normalAttribute, vA);\n          nB.fromBufferAttribute(normalAttribute, vB);\n          nC.fromBufferAttribute(normalAttribute, vC);\n          nA.add(cb);\n          nB.add(cb);\n          nC.add(cb);\n          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n        }\n      } else {\n        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {\n          pA.fromBufferAttribute(positionAttribute, i + 0);\n          pB.fromBufferAttribute(positionAttribute, i + 1);\n          pC.fromBufferAttribute(positionAttribute, i + 2);\n          cb.subVectors(pC, pB);\n          ab.subVectors(pA, pB);\n          cb.cross(ab);\n          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z);\n          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z);\n        }\n      }\n      this.normalizeNormals();\n      normalAttribute.needsUpdate = true;\n    }\n  }\n  merge(geometry, offset) {\n    if (!(geometry && geometry.isBufferGeometry)) {\n      console.error(\"THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.\", geometry);\n      return;\n    }\n    if (offset === void 0) {\n      offset = 0;\n      console.warn(\"THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.\");\n    }\n    const attributes = this.attributes;\n    for (const key in attributes) {\n      if (geometry.attributes[key] === void 0)\n        continue;\n      const attribute1 = attributes[key];\n      const attributeArray1 = attribute1.array;\n      const attribute2 = geometry.attributes[key];\n      const attributeArray2 = attribute2.array;\n      const attributeOffset = attribute2.itemSize * offset;\n      const length = Math.min(attributeArray2.length, attributeArray1.length - attributeOffset);\n      for (let i = 0, j = attributeOffset; i < length; i++, j++) {\n        attributeArray1[j] = attributeArray2[i];\n      }\n    }\n    return this;\n  }\n  normalizeNormals() {\n    const normals = this.attributes.normal;\n    for (let i = 0, il = normals.count; i < il; i++) {\n      _vector$8.fromBufferAttribute(normals, i);\n      _vector$8.normalize();\n      normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);\n    }\n  }\n  toNonIndexed() {\n    function convertBufferAttribute(attribute, indices2) {\n      const array = attribute.array;\n      const itemSize = attribute.itemSize;\n      const normalized = attribute.normalized;\n      const array2 = new array.constructor(indices2.length * itemSize);\n      let index = 0, index2 = 0;\n      for (let i = 0, l = indices2.length; i < l; i++) {\n        index = indices2[i] * itemSize;\n        for (let j = 0; j < itemSize; j++) {\n          array2[index2++] = array[index++];\n        }\n      }\n      return new BufferAttribute(array2, itemSize, normalized);\n    }\n    if (this.index === null) {\n      console.warn(\"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.\");\n      return this;\n    }\n    const geometry2 = new BufferGeometry();\n    const indices = this.index.array;\n    const attributes = this.attributes;\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      const newAttribute = convertBufferAttribute(attribute, indices);\n      geometry2.setAttribute(name, newAttribute);\n    }\n    const morphAttributes = this.morphAttributes;\n    for (const name in morphAttributes) {\n      const morphArray = [];\n      const morphAttribute = morphAttributes[name];\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const attribute = morphAttribute[i];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        morphArray.push(newAttribute);\n      }\n      geometry2.morphAttributes[name] = morphArray;\n    }\n    geometry2.morphTargetsRelative = this.morphTargetsRelative;\n    const groups = this.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      geometry2.addGroup(group.start, group.count, group.materialIndex);\n    }\n    return geometry2;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"BufferGeometry\",\n        generator: \"BufferGeometry.toJSON\"\n      }\n    };\n    data.uuid = this.uuid;\n    data.type = this.type;\n    if (this.name !== \"\")\n      data.name = this.name;\n    if (Object.keys(this.userData).length > 0)\n      data.userData = this.userData;\n    if (this.parameters !== void 0) {\n      const parameters = this.parameters;\n      for (const key in parameters) {\n        if (parameters[key] !== void 0)\n          data[key] = parameters[key];\n      }\n      return data;\n    }\n    data.data = {attributes: {}};\n    const index = this.index;\n    if (index !== null) {\n      data.data.index = {\n        type: index.array.constructor.name,\n        array: Array.prototype.slice.call(index.array)\n      };\n    }\n    const attributes = this.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      data.data.attributes[key] = attribute.toJSON(data.data);\n    }\n    const morphAttributes = {};\n    let hasMorphAttributes = false;\n    for (const key in this.morphAttributes) {\n      const attributeArray = this.morphAttributes[key];\n      const array = [];\n      for (let i = 0, il = attributeArray.length; i < il; i++) {\n        const attribute = attributeArray[i];\n        array.push(attribute.toJSON(data.data));\n      }\n      if (array.length > 0) {\n        morphAttributes[key] = array;\n        hasMorphAttributes = true;\n      }\n    }\n    if (hasMorphAttributes) {\n      data.data.morphAttributes = morphAttributes;\n      data.data.morphTargetsRelative = this.morphTargetsRelative;\n    }\n    const groups = this.groups;\n    if (groups.length > 0) {\n      data.data.groups = JSON.parse(JSON.stringify(groups));\n    }\n    const boundingSphere = this.boundingSphere;\n    if (boundingSphere !== null) {\n      data.data.boundingSphere = {\n        center: boundingSphere.center.toArray(),\n        radius: boundingSphere.radius\n      };\n    }\n    return data;\n  }\n  clone() {\n    return new BufferGeometry().copy(this);\n  }\n  copy(source) {\n    this.index = null;\n    this.attributes = {};\n    this.morphAttributes = {};\n    this.groups = [];\n    this.boundingBox = null;\n    this.boundingSphere = null;\n    const data = {};\n    this.name = source.name;\n    const index = source.index;\n    if (index !== null) {\n      this.setIndex(index.clone(data));\n    }\n    const attributes = source.attributes;\n    for (const name in attributes) {\n      const attribute = attributes[name];\n      this.setAttribute(name, attribute.clone(data));\n    }\n    const morphAttributes = source.morphAttributes;\n    for (const name in morphAttributes) {\n      const array = [];\n      const morphAttribute = morphAttributes[name];\n      for (let i = 0, l = morphAttribute.length; i < l; i++) {\n        array.push(morphAttribute[i].clone(data));\n      }\n      this.morphAttributes[name] = array;\n    }\n    this.morphTargetsRelative = source.morphTargetsRelative;\n    const groups = source.groups;\n    for (let i = 0, l = groups.length; i < l; i++) {\n      const group = groups[i];\n      this.addGroup(group.start, group.count, group.materialIndex);\n    }\n    const boundingBox = source.boundingBox;\n    if (boundingBox !== null) {\n      this.boundingBox = boundingBox.clone();\n    }\n    const boundingSphere = source.boundingSphere;\n    if (boundingSphere !== null) {\n      this.boundingSphere = boundingSphere.clone();\n    }\n    this.drawRange.start = source.drawRange.start;\n    this.drawRange.count = source.drawRange.count;\n    this.userData = source.userData;\n    return this;\n  }\n  dispose() {\n    this.dispatchEvent({type: \"dispose\"});\n  }\n}\nBufferGeometry.prototype.isBufferGeometry = true;\nconst _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();\nconst _ray$2 = /* @__PURE__ */ new Ray();\nconst _sphere$3 = /* @__PURE__ */ new Sphere();\nconst _vA$1 = /* @__PURE__ */ new Vector3();\nconst _vB$1 = /* @__PURE__ */ new Vector3();\nconst _vC$1 = /* @__PURE__ */ new Vector3();\nconst _tempA = /* @__PURE__ */ new Vector3();\nconst _tempB = /* @__PURE__ */ new Vector3();\nconst _tempC = /* @__PURE__ */ new Vector3();\nconst _morphA = /* @__PURE__ */ new Vector3();\nconst _morphB = /* @__PURE__ */ new Vector3();\nconst _morphC = /* @__PURE__ */ new Vector3();\nconst _uvA$1 = /* @__PURE__ */ new Vector2();\nconst _uvB$1 = /* @__PURE__ */ new Vector2();\nconst _uvC$1 = /* @__PURE__ */ new Vector2();\nconst _intersectionPoint = /* @__PURE__ */ new Vector3();\nconst _intersectionPointWorld = /* @__PURE__ */ new Vector3();\nclass Mesh extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n    super();\n    this.type = \"Mesh\";\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source) {\n    super.copy(source);\n    if (source.morphTargetInfluences !== void 0) {\n      this.morphTargetInfluences = source.morphTargetInfluences.slice();\n    }\n    if (source.morphTargetDictionary !== void 0) {\n      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n    }\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n      if (morphTargets !== void 0 && morphTargets.length > 0) {\n        console.error(\"THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      }\n    }\n  }\n  raycast(raycaster, intersects2) {\n    const geometry = this.geometry;\n    const material = this.material;\n    const matrixWorld = this.matrixWorld;\n    if (material === void 0)\n      return;\n    if (geometry.boundingSphere === null)\n      geometry.computeBoundingSphere();\n    _sphere$3.copy(geometry.boundingSphere);\n    _sphere$3.applyMatrix4(matrixWorld);\n    if (raycaster.ray.intersectsSphere(_sphere$3) === false)\n      return;\n    _inverseMatrix$2.copy(matrixWorld).invert();\n    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);\n    if (geometry.boundingBox !== null) {\n      if (_ray$2.intersectsBox(geometry.boundingBox) === false)\n        return;\n    }\n    let intersection;\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      const uv = geometry.attributes.uv;\n      const uv2 = geometry.attributes.uv2;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n      if (index !== null) {\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects2.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = index.getX(i);\n            const b = index.getX(i + 1);\n            const c = index.getX(i + 2);\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3);\n              intersects2.push(intersection);\n            }\n          }\n        }\n      } else if (position !== void 0) {\n        if (Array.isArray(material)) {\n          for (let i = 0, il = groups.length; i < il; i++) {\n            const group = groups[i];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(group.start + group.count, drawRange.start + drawRange.count);\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkBufferGeometryIntersection(this, groupMaterial, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects2.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n          for (let i = start, il = end; i < il; i += 3) {\n            const a = i;\n            const b = i + 1;\n            const c = i + 2;\n            intersection = checkBufferGeometryIntersection(this, material, raycaster, _ray$2, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i / 3);\n              intersects2.push(intersection);\n            }\n          }\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\"THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n    }\n  }\n}\nMesh.prototype.isMesh = true;\nfunction checkIntersection(object, material, raycaster, ray, pA, pB, pC, point) {\n  let intersect;\n  if (material.side === BackSide) {\n    intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n  } else {\n    intersect = ray.intersectTriangle(pA, pB, pC, material.side !== DoubleSide, point);\n  }\n  if (intersect === null)\n    return null;\n  _intersectionPointWorld.copy(point);\n  _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n  if (distance < raycaster.near || distance > raycaster.far)\n    return null;\n  return {\n    distance,\n    point: _intersectionPointWorld.clone(),\n    object\n  };\n}\nfunction checkBufferGeometryIntersection(object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c) {\n  _vA$1.fromBufferAttribute(position, a);\n  _vB$1.fromBufferAttribute(position, b);\n  _vC$1.fromBufferAttribute(position, c);\n  const morphInfluences = object.morphTargetInfluences;\n  if (material.morphTargets && morphPosition && morphInfluences) {\n    _morphA.set(0, 0, 0);\n    _morphB.set(0, 0, 0);\n    _morphC.set(0, 0, 0);\n    for (let i = 0, il = morphPosition.length; i < il; i++) {\n      const influence = morphInfluences[i];\n      const morphAttribute = morphPosition[i];\n      if (influence === 0)\n        continue;\n      _tempA.fromBufferAttribute(morphAttribute, a);\n      _tempB.fromBufferAttribute(morphAttribute, b);\n      _tempC.fromBufferAttribute(morphAttribute, c);\n      if (morphTargetsRelative) {\n        _morphA.addScaledVector(_tempA, influence);\n        _morphB.addScaledVector(_tempB, influence);\n        _morphC.addScaledVector(_tempC, influence);\n      } else {\n        _morphA.addScaledVector(_tempA.sub(_vA$1), influence);\n        _morphB.addScaledVector(_tempB.sub(_vB$1), influence);\n        _morphC.addScaledVector(_tempC.sub(_vC$1), influence);\n      }\n    }\n    _vA$1.add(_morphA);\n    _vB$1.add(_morphB);\n    _vC$1.add(_morphC);\n  }\n  if (object.isSkinnedMesh && material.skinning) {\n    object.boneTransform(a, _vA$1);\n    object.boneTransform(b, _vB$1);\n    object.boneTransform(c, _vC$1);\n  }\n  const intersection = checkIntersection(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n  if (intersection) {\n    if (uv) {\n      _uvA$1.fromBufferAttribute(uv, a);\n      _uvB$1.fromBufferAttribute(uv, b);\n      _uvC$1.fromBufferAttribute(uv, c);\n      intersection.uv = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n    }\n    if (uv2) {\n      _uvA$1.fromBufferAttribute(uv2, a);\n      _uvB$1.fromBufferAttribute(uv2, b);\n      _uvC$1.fromBufferAttribute(uv2, c);\n      intersection.uv2 = Triangle.getUV(_intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA$1, _uvB$1, _uvC$1, new Vector2());\n    }\n    const face = {\n      a,\n      b,\n      c,\n      normal: new Vector3(),\n      materialIndex: 0\n    };\n    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n    intersection.face = face;\n  }\n  return intersection;\n}\nclass BoxGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {\n    super();\n    this.type = \"BoxGeometry\";\n    this.parameters = {\n      width,\n      height,\n      depth,\n      widthSegments,\n      heightSegments,\n      depthSegments\n    };\n    const scope = this;\n    widthSegments = Math.floor(widthSegments);\n    heightSegments = Math.floor(heightSegments);\n    depthSegments = Math.floor(depthSegments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    let numberOfVertices = 0;\n    let groupStart = 0;\n    buildPlane(\"z\", \"y\", \"x\", -1, -1, depth, height, width, depthSegments, heightSegments, 0);\n    buildPlane(\"z\", \"y\", \"x\", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);\n    buildPlane(\"x\", \"z\", \"y\", 1, 1, width, depth, height, widthSegments, depthSegments, 2);\n    buildPlane(\"x\", \"z\", \"y\", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);\n    buildPlane(\"x\", \"y\", \"z\", 1, -1, width, height, depth, widthSegments, heightSegments, 4);\n    buildPlane(\"x\", \"y\", \"z\", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function buildPlane(u, v, w, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {\n      const segmentWidth = width2 / gridX;\n      const segmentHeight = height2 / gridY;\n      const widthHalf = width2 / 2;\n      const heightHalf = height2 / 2;\n      const depthHalf = depth2 / 2;\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      let vertexCounter = 0;\n      let groupCount = 0;\n      const vector = new Vector3();\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segmentHeight - heightHalf;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x = ix * segmentWidth - widthHalf;\n          vector[u] = x * udir;\n          vector[v] = y * vdir;\n          vector[w] = depthHalf;\n          vertices.push(vector.x, vector.y, vector.z);\n          vector[u] = 0;\n          vector[v] = 0;\n          vector[w] = depth2 > 0 ? 1 : -1;\n          normals.push(vector.x, vector.y, vector.z);\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n          vertexCounter += 1;\n        }\n      }\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = numberOfVertices + ix + gridX1 * iy;\n          const b = numberOfVertices + ix + gridX1 * (iy + 1);\n          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);\n          const d = numberOfVertices + (ix + 1) + gridX1 * iy;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n          groupCount += 6;\n        }\n      }\n      scope.addGroup(groupStart, groupCount, materialIndex);\n      groupStart += groupCount;\n      numberOfVertices += vertexCounter;\n    }\n  }\n}\nfunction cloneUniforms(src) {\n  const dst = {};\n  for (const u in src) {\n    dst[u] = {};\n    for (const p in src[u]) {\n      const property = src[u][p];\n      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n        dst[u][p] = property.clone();\n      } else if (Array.isArray(property)) {\n        dst[u][p] = property.slice();\n      } else {\n        dst[u][p] = property;\n      }\n    }\n  }\n  return dst;\n}\nfunction mergeUniforms(uniforms) {\n  const merged = {};\n  for (let u = 0; u < uniforms.length; u++) {\n    const tmp2 = cloneUniforms(uniforms[u]);\n    for (const p in tmp2) {\n      merged[p] = tmp2[p];\n    }\n  }\n  return merged;\n}\nconst UniformsUtils = {clone: cloneUniforms, merge: mergeUniforms};\nvar default_vertex = \"void main() {\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}\";\nvar default_fragment = \"void main() {\\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}\";\nclass ShaderMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"ShaderMaterial\";\n    this.defines = {};\n    this.uniforms = {};\n    this.vertexShader = default_vertex;\n    this.fragmentShader = default_fragment;\n    this.linewidth = 1;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false;\n    this.lights = false;\n    this.clipping = false;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.extensions = {\n      derivatives: false,\n      fragDepth: false,\n      drawBuffers: false,\n      shaderTextureLOD: false\n    };\n    this.defaultAttributeValues = {\n      \"color\": [1, 1, 1],\n      \"uv\": [0, 0],\n      \"uv2\": [0, 0]\n    };\n    this.index0AttributeName = void 0;\n    this.uniformsNeedUpdate = false;\n    this.glslVersion = null;\n    if (parameters !== void 0) {\n      if (parameters.attributes !== void 0) {\n        console.error(\"THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.\");\n      }\n      this.setValues(parameters);\n    }\n  }\n  copy(source) {\n    super.copy(source);\n    this.fragmentShader = source.fragmentShader;\n    this.vertexShader = source.vertexShader;\n    this.uniforms = cloneUniforms(source.uniforms);\n    this.defines = Object.assign({}, source.defines);\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.lights = source.lights;\n    this.clipping = source.clipping;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    this.extensions = Object.assign({}, source.extensions);\n    this.glslVersion = source.glslVersion;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.glslVersion = this.glslVersion;\n    data.uniforms = {};\n    for (const name in this.uniforms) {\n      const uniform = this.uniforms[name];\n      const value = uniform.value;\n      if (value && value.isTexture) {\n        data.uniforms[name] = {\n          type: \"t\",\n          value: value.toJSON(meta).uuid\n        };\n      } else if (value && value.isColor) {\n        data.uniforms[name] = {\n          type: \"c\",\n          value: value.getHex()\n        };\n      } else if (value && value.isVector2) {\n        data.uniforms[name] = {\n          type: \"v2\",\n          value: value.toArray()\n        };\n      } else if (value && value.isVector3) {\n        data.uniforms[name] = {\n          type: \"v3\",\n          value: value.toArray()\n        };\n      } else if (value && value.isVector4) {\n        data.uniforms[name] = {\n          type: \"v4\",\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix3) {\n        data.uniforms[name] = {\n          type: \"m3\",\n          value: value.toArray()\n        };\n      } else if (value && value.isMatrix4) {\n        data.uniforms[name] = {\n          type: \"m4\",\n          value: value.toArray()\n        };\n      } else {\n        data.uniforms[name] = {\n          value\n        };\n      }\n    }\n    if (Object.keys(this.defines).length > 0)\n      data.defines = this.defines;\n    data.vertexShader = this.vertexShader;\n    data.fragmentShader = this.fragmentShader;\n    const extensions = {};\n    for (const key in this.extensions) {\n      if (this.extensions[key] === true)\n        extensions[key] = true;\n    }\n    if (Object.keys(extensions).length > 0)\n      data.extensions = extensions;\n    return data;\n  }\n}\nShaderMaterial.prototype.isShaderMaterial = true;\nclass Camera extends Object3D {\n  constructor() {\n    super();\n    this.type = \"Camera\";\n    this.matrixWorldInverse = new Matrix4();\n    this.projectionMatrix = new Matrix4();\n    this.projectionMatrixInverse = new Matrix4();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.matrixWorldInverse.copy(source.matrixWorldInverse);\n    this.projectionMatrix.copy(source.projectionMatrix);\n    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n    return this;\n  }\n  getWorldDirection(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Camera: .getWorldDirection() target is now required\");\n      target = new Vector3();\n    }\n    this.updateWorldMatrix(true, false);\n    const e = this.matrixWorld.elements;\n    return target.set(-e[8], -e[9], -e[10]).normalize();\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  updateWorldMatrix(updateParents, updateChildren) {\n    super.updateWorldMatrix(updateParents, updateChildren);\n    this.matrixWorldInverse.copy(this.matrixWorld).invert();\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nCamera.prototype.isCamera = true;\nclass PerspectiveCamera extends Camera {\n  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {\n    super();\n    this.type = \"PerspectiveCamera\";\n    this.fov = fov2;\n    this.zoom = 1;\n    this.near = near;\n    this.far = far;\n    this.focus = 10;\n    this.aspect = aspect2;\n    this.view = null;\n    this.filmGauge = 35;\n    this.filmOffset = 0;\n    this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.fov = source.fov;\n    this.zoom = source.zoom;\n    this.near = source.near;\n    this.far = source.far;\n    this.focus = source.focus;\n    this.aspect = source.aspect;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    this.filmGauge = source.filmGauge;\n    this.filmOffset = source.filmOffset;\n    return this;\n  }\n  setFocalLength(focalLength) {\n    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);\n    this.updateProjectionMatrix();\n  }\n  getFocalLength() {\n    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);\n    return 0.5 * this.getFilmHeight() / vExtentSlope;\n  }\n  getEffectiveFOV() {\n    return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);\n  }\n  getFilmWidth() {\n    return this.filmGauge * Math.min(this.aspect, 1);\n  }\n  getFilmHeight() {\n    return this.filmGauge / Math.max(this.aspect, 1);\n  }\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    this.aspect = fullWidth / fullHeight;\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const near = this.near;\n    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;\n    let height = 2 * top;\n    let width = this.aspect * height;\n    let left = -0.5 * width;\n    const view = this.view;\n    if (this.view !== null && this.view.enabled) {\n      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;\n      left += view.offsetX * width / fullWidth;\n      top -= view.offsetY * height / fullHeight;\n      width *= view.width / fullWidth;\n      height *= view.height / fullHeight;\n    }\n    const skew = this.filmOffset;\n    if (skew !== 0)\n      left += near * skew / this.getFilmWidth();\n    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.fov = this.fov;\n    data.object.zoom = this.zoom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    data.object.focus = this.focus;\n    data.object.aspect = this.aspect;\n    if (this.view !== null)\n      data.object.view = Object.assign({}, this.view);\n    data.object.filmGauge = this.filmGauge;\n    data.object.filmOffset = this.filmOffset;\n    return data;\n  }\n}\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\nconst fov = 90, aspect = 1;\nclass CubeCamera extends Object3D {\n  constructor(near, far, renderTarget) {\n    super();\n    this.type = \"CubeCamera\";\n    if (renderTarget.isWebGLCubeRenderTarget !== true) {\n      console.error(\"THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.\");\n      return;\n    }\n    this.renderTarget = renderTarget;\n    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPX.layers = this.layers;\n    cameraPX.up.set(0, -1, 0);\n    cameraPX.lookAt(new Vector3(1, 0, 0));\n    this.add(cameraPX);\n    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNX.layers = this.layers;\n    cameraNX.up.set(0, -1, 0);\n    cameraNX.lookAt(new Vector3(-1, 0, 0));\n    this.add(cameraNX);\n    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPY.layers = this.layers;\n    cameraPY.up.set(0, 0, 1);\n    cameraPY.lookAt(new Vector3(0, 1, 0));\n    this.add(cameraPY);\n    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNY.layers = this.layers;\n    cameraNY.up.set(0, 0, -1);\n    cameraNY.lookAt(new Vector3(0, -1, 0));\n    this.add(cameraNY);\n    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraPZ.layers = this.layers;\n    cameraPZ.up.set(0, -1, 0);\n    cameraPZ.lookAt(new Vector3(0, 0, 1));\n    this.add(cameraPZ);\n    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);\n    cameraNZ.layers = this.layers;\n    cameraNZ.up.set(0, -1, 0);\n    cameraNZ.lookAt(new Vector3(0, 0, -1));\n    this.add(cameraNZ);\n  }\n  update(renderer, scene) {\n    if (this.parent === null)\n      this.updateMatrixWorld();\n    const renderTarget = this.renderTarget;\n    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;\n    const currentXrEnabled = renderer.xr.enabled;\n    const currentRenderTarget = renderer.getRenderTarget();\n    renderer.xr.enabled = false;\n    const generateMipmaps = renderTarget.texture.generateMipmaps;\n    renderTarget.texture.generateMipmaps = false;\n    renderer.setRenderTarget(renderTarget, 0);\n    renderer.render(scene, cameraPX);\n    renderer.setRenderTarget(renderTarget, 1);\n    renderer.render(scene, cameraNX);\n    renderer.setRenderTarget(renderTarget, 2);\n    renderer.render(scene, cameraPY);\n    renderer.setRenderTarget(renderTarget, 3);\n    renderer.render(scene, cameraNY);\n    renderer.setRenderTarget(renderTarget, 4);\n    renderer.render(scene, cameraPZ);\n    renderTarget.texture.generateMipmaps = generateMipmaps;\n    renderer.setRenderTarget(renderTarget, 5);\n    renderer.render(scene, cameraNZ);\n    renderer.setRenderTarget(currentRenderTarget);\n    renderer.xr.enabled = currentXrEnabled;\n  }\n}\nclass CubeTexture extends Texture {\n  constructor(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding) {\n    images = images !== void 0 ? images : [];\n    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping;\n    format = format !== void 0 ? format : RGBFormat;\n    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    this._needsFlipEnvMap = true;\n    this.flipY = false;\n  }\n  get images() {\n    return this.image;\n  }\n  set images(value) {\n    this.image = value;\n  }\n}\nCubeTexture.prototype.isCubeTexture = true;\nclass WebGLCubeRenderTarget extends WebGLRenderTarget {\n  constructor(size, options, dummy) {\n    if (Number.isInteger(options)) {\n      console.warn(\"THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )\");\n      options = dummy;\n    }\n    super(size, size, options);\n    options = options || {};\n    this.texture = new CubeTexture(void 0, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding);\n    this.texture.generateMipmaps = options.generateMipmaps !== void 0 ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== void 0 ? options.minFilter : LinearFilter;\n    this.texture._needsFlipEnvMap = false;\n  }\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.format = RGBAFormat;\n    this.texture.encoding = texture.encoding;\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n    const shader = {\n      uniforms: {\n        tEquirect: {value: null}\n      },\n      vertexShader: `\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader: `\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n    };\n    const geometry = new BoxGeometry(5, 5, 5);\n    const material = new ShaderMaterial({\n      name: \"CubemapFromEquirect\",\n      uniforms: cloneUniforms(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: BackSide,\n      blending: NoBlending\n    });\n    material.uniforms.tEquirect.value = texture;\n    const mesh = new Mesh(geometry, material);\n    const currentMinFilter = texture.minFilter;\n    if (texture.minFilter === LinearMipmapLinearFilter)\n      texture.minFilter = LinearFilter;\n    const camera = new CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n    texture.minFilter = currentMinFilter;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n      renderer.clear(color, depth, stencil);\n    }\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n}\nWebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;\nclass DataTexture extends Texture {\n  constructor(data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    this.image = {data: data || null, width: width || 1, height: height || 1};\n    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n  }\n}\nDataTexture.prototype.isDataTexture = true;\nconst _sphere$2 = /* @__PURE__ */ new Sphere();\nconst _vector$7 = /* @__PURE__ */ new Vector3();\nclass Frustum {\n  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {\n    this.planes = [p0, p1, p2, p3, p4, p5];\n  }\n  set(p0, p1, p2, p3, p4, p5) {\n    const planes = this.planes;\n    planes[0].copy(p0);\n    planes[1].copy(p1);\n    planes[2].copy(p2);\n    planes[3].copy(p3);\n    planes[4].copy(p4);\n    planes[5].copy(p5);\n    return this;\n  }\n  copy(frustum) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      planes[i].copy(frustum.planes[i]);\n    }\n    return this;\n  }\n  setFromProjectionMatrix(m) {\n    const planes = this.planes;\n    const me = m.elements;\n    const me0 = me[0], me1 = me[1], me2 = me[2], me3 = me[3];\n    const me4 = me[4], me5 = me[5], me6 = me[6], me7 = me[7];\n    const me8 = me[8], me9 = me[9], me10 = me[10], me11 = me[11];\n    const me12 = me[12], me13 = me[13], me14 = me[14], me15 = me[15];\n    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();\n    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();\n    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();\n    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();\n    planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();\n    planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();\n    return this;\n  }\n  intersectsObject(object) {\n    const geometry = object.geometry;\n    if (geometry.boundingSphere === null)\n      geometry.computeBoundingSphere();\n    _sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);\n    return this.intersectsSphere(_sphere$2);\n  }\n  intersectsSprite(sprite) {\n    _sphere$2.center.set(0, 0, 0);\n    _sphere$2.radius = 0.7071067811865476;\n    _sphere$2.applyMatrix4(sprite.matrixWorld);\n    return this.intersectsSphere(_sphere$2);\n  }\n  intersectsSphere(sphere) {\n    const planes = this.planes;\n    const center = sphere.center;\n    const negRadius = -sphere.radius;\n    for (let i = 0; i < 6; i++) {\n      const distance = planes[i].distanceToPoint(center);\n      if (distance < negRadius) {\n        return false;\n      }\n    }\n    return true;\n  }\n  intersectsBox(box) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      const plane = planes[i];\n      _vector$7.x = plane.normal.x > 0 ? box.max.x : box.min.x;\n      _vector$7.y = plane.normal.y > 0 ? box.max.y : box.min.y;\n      _vector$7.z = plane.normal.z > 0 ? box.max.z : box.min.z;\n      if (plane.distanceToPoint(_vector$7) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  containsPoint(point) {\n    const planes = this.planes;\n    for (let i = 0; i < 6; i++) {\n      if (planes[i].distanceToPoint(point) < 0) {\n        return false;\n      }\n    }\n    return true;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nfunction WebGLAnimation() {\n  let context = null;\n  let isAnimating = false;\n  let animationLoop = null;\n  let requestId = null;\n  function onAnimationFrame(time, frame) {\n    animationLoop(time, frame);\n    requestId = context.requestAnimationFrame(onAnimationFrame);\n  }\n  return {\n    start: function() {\n      if (isAnimating === true)\n        return;\n      if (animationLoop === null)\n        return;\n      requestId = context.requestAnimationFrame(onAnimationFrame);\n      isAnimating = true;\n    },\n    stop: function() {\n      context.cancelAnimationFrame(requestId);\n      isAnimating = false;\n    },\n    setAnimationLoop: function(callback) {\n      animationLoop = callback;\n    },\n    setContext: function(value) {\n      context = value;\n    }\n  };\n}\nfunction WebGLAttributes(gl, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  const buffers = new WeakMap();\n  function createBuffer(attribute, bufferType) {\n    const array = attribute.array;\n    const usage = attribute.usage;\n    const buffer = gl.createBuffer();\n    gl.bindBuffer(bufferType, buffer);\n    gl.bufferData(bufferType, array, usage);\n    attribute.onUploadCallback();\n    let type = 5126;\n    if (array instanceof Float32Array) {\n      type = 5126;\n    } else if (array instanceof Float64Array) {\n      console.warn(\"THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.\");\n    } else if (array instanceof Uint16Array) {\n      if (attribute.isFloat16BufferAttribute) {\n        if (isWebGL2) {\n          type = 5131;\n        } else {\n          console.warn(\"THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.\");\n        }\n      } else {\n        type = 5123;\n      }\n    } else if (array instanceof Int16Array) {\n      type = 5122;\n    } else if (array instanceof Uint32Array) {\n      type = 5125;\n    } else if (array instanceof Int32Array) {\n      type = 5124;\n    } else if (array instanceof Int8Array) {\n      type = 5120;\n    } else if (array instanceof Uint8Array) {\n      type = 5121;\n    }\n    return {\n      buffer,\n      type,\n      bytesPerElement: array.BYTES_PER_ELEMENT,\n      version: attribute.version\n    };\n  }\n  function updateBuffer(buffer, attribute, bufferType) {\n    const array = attribute.array;\n    const updateRange = attribute.updateRange;\n    gl.bindBuffer(bufferType, buffer);\n    if (updateRange.count === -1) {\n      gl.bufferSubData(bufferType, 0, array);\n    } else {\n      if (isWebGL2) {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array, updateRange.offset, updateRange.count);\n      } else {\n        gl.bufferSubData(bufferType, updateRange.offset * array.BYTES_PER_ELEMENT, array.subarray(updateRange.offset, updateRange.offset + updateRange.count));\n      }\n      updateRange.count = -1;\n    }\n  }\n  function get(attribute) {\n    if (attribute.isInterleavedBufferAttribute)\n      attribute = attribute.data;\n    return buffers.get(attribute);\n  }\n  function remove(attribute) {\n    if (attribute.isInterleavedBufferAttribute)\n      attribute = attribute.data;\n    const data = buffers.get(attribute);\n    if (data) {\n      gl.deleteBuffer(data.buffer);\n      buffers.delete(attribute);\n    }\n  }\n  function update(attribute, bufferType) {\n    if (attribute.isGLBufferAttribute) {\n      const cached = buffers.get(attribute);\n      if (!cached || cached.version < attribute.version) {\n        buffers.set(attribute, {\n          buffer: attribute.buffer,\n          type: attribute.type,\n          bytesPerElement: attribute.elementSize,\n          version: attribute.version\n        });\n      }\n      return;\n    }\n    if (attribute.isInterleavedBufferAttribute)\n      attribute = attribute.data;\n    const data = buffers.get(attribute);\n    if (data === void 0) {\n      buffers.set(attribute, createBuffer(attribute, bufferType));\n    } else if (data.version < attribute.version) {\n      updateBuffer(data.buffer, attribute, bufferType);\n      data.version = attribute.version;\n    }\n  }\n  return {\n    get,\n    remove,\n    update\n  };\n}\nclass PlaneGeometry extends BufferGeometry {\n  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n    super();\n    this.type = \"PlaneGeometry\";\n    this.parameters = {\n      width,\n      height,\n      widthSegments,\n      heightSegments\n    };\n    const width_half = width / 2;\n    const height_half = height / 2;\n    const gridX = Math.floor(widthSegments);\n    const gridY = Math.floor(heightSegments);\n    const gridX1 = gridX + 1;\n    const gridY1 = gridY + 1;\n    const segment_width = width / gridX;\n    const segment_height = height / gridY;\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    for (let iy = 0; iy < gridY1; iy++) {\n      const y = iy * segment_height - height_half;\n      for (let ix = 0; ix < gridX1; ix++) {\n        const x = ix * segment_width - width_half;\n        vertices.push(x, -y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(ix / gridX);\n        uvs.push(1 - iy / gridY);\n      }\n    }\n    for (let iy = 0; iy < gridY; iy++) {\n      for (let ix = 0; ix < gridX; ix++) {\n        const a = ix + gridX1 * iy;\n        const b = ix + gridX1 * (iy + 1);\n        const c = ix + 1 + gridX1 * (iy + 1);\n        const d = ix + 1 + gridX1 * iy;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n}\nvar alphamap_fragment = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\";\nvar alphamap_pars_fragment = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\";\nvar alphatest_fragment = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\";\nvar aomap_fragment = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\";\nvar aomap_pars_fragment = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\nvar begin_vertex = \"vec3 transformed = vec3( position );\";\nvar beginnormal_vertex = \"vec3 objectNormal = vec3( normal );\\n#ifdef USE_TANGENT\\n\tvec3 objectTangent = vec3( tangent.xyz );\\n#endif\";\nvar bsdfs = \"vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\tif( cutoffDistance > 0.0 ) {\\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t}\\n\treturn distanceFalloff;\\n#else\\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n\t}\\n\treturn 1.0;\\n#endif\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\\n\treturn Fr * fresnel + F0;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\\n\tconst float LUT_SIZE = 64.0;\\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\\n\tfloat dotNV = saturate( dot( N, V ) );\\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\\n\tuv = uv * LUT_SCALE + LUT_BIAS;\\n\treturn uv;\\n}\\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\\n\tfloat l = length( f );\\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\\n}\\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\\n\tfloat x = dot( v1, v2 );\\n\tfloat y = abs( x );\\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\\n\tfloat v = a / b;\\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\\n\treturn cross( v1, v2 ) * theta_sintheta;\\n}\\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\\n\tvec3 lightNormal = cross( v1, v2 );\\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\\n\tvec3 T1, T2;\\n\tT1 = normalize( V - N * dot( V, N ) );\\n\tT2 = - cross( N, T1 );\\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\\n\tvec3 coords[ 4 ];\\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\\n\tvec3 vectorFormFactor = vec3( 0.0 );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\\n\treturn vec3( result );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\treturn specularColor * brdf.x + brdf.y;\\n}\\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\\n\tvec3 FssEss = F * brdf.x + brdf.y;\\n\tfloat Ess = brdf.x + brdf.y;\\n\tfloat Ems = 1.0 - Ess;\\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\\n\tsingleScatter += FssEss;\\n\tmultiScatter += Fms * Ems;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n#if defined( USE_SHEEN )\\nfloat D_Charlie(float roughness, float NoH) {\\n\tfloat invAlpha = 1.0 / roughness;\\n\tfloat cos2h = NoH * NoH;\\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\\n}\\nfloat V_Neubelt(float NoV, float NoL) {\\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\\n}\\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\\n\tvec3 N = geometry.normal;\\n\tvec3 V = geometry.viewDir;\\n\tvec3 H = normalize( V + L );\\n\tfloat dotNH = saturate( dot( N, H ) );\\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\\n}\\n#endif\";\nvar bumpmap_pars_fragment = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\";\nvar clipping_planes_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\tvec4 plane;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\\n\t\tplane = clippingPlanes[ i ];\\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\\n\t\tbool clipped = true;\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\\n\t\t\tplane = clippingPlanes[ i ];\\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t\tif ( clipped ) discard;\\n\t#endif\\n#endif\";\nvar clipping_planes_pars_fragment = \"#if NUM_CLIPPING_PLANES > 0\\n\tvarying vec3 vClipPosition;\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\";\nvar clipping_planes_pars_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\tvarying vec3 vClipPosition;\\n#endif\";\nvar clipping_planes_vertex = \"#if NUM_CLIPPING_PLANES > 0\\n\tvClipPosition = - mvPosition.xyz;\\n#endif\";\nvar color_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\tdiffuseColor *= vColor;\\n#elif defined( USE_COLOR )\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\nvar color_pars_fragment = \"#if defined( USE_COLOR_ALPHA )\\n\tvarying vec4 vColor;\\n#elif defined( USE_COLOR )\\n\tvarying vec3 vColor;\\n#endif\";\nvar color_pars_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\tvarying vec4 vColor;\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\tvarying vec3 vColor;\\n#endif\";\nvar color_vertex = \"#if defined( USE_COLOR_ALPHA )\\n\tvColor = vec4( 1.0 );\\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\\n\tvColor = vec3( 1.0 );\\n#endif\\n#ifdef USE_COLOR\\n\tvColor *= color;\\n#endif\\n#ifdef USE_INSTANCING_COLOR\\n\tvColor.xyz *= instanceColor.xyz;\\n#endif\";\nvar common = \"#define PI 3.141592653589793\\n#define PI2 6.283185307179586\\n#define PI_HALF 1.5707963267948966\\n#define RECIPROCAL_PI 0.3183098861837907\\n#define RECIPROCAL_PI2 0.15915494309189535\\n#define EPSILON 1e-6\\n#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\n#ifdef HIGH_PRECISION\\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\\n#else\\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\\n\tfloat precisionSafeLength( vec3 v ) {\\n\t\tfloat maxComponent = max3( abs( v ) );\\n\t\treturn length( v / maxComponent ) * maxComponent;\\n\t}\\n#endif\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n#ifdef CLEARCOAT\\n\tvec3 clearcoatNormal;\\n#endif\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\nmat3 transposeMat3( const in mat3 m ) {\\n\tmat3 tmp;\\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\\n\treturn tmp;\\n}\\nfloat linearToRelativeLuminance( const in vec3 color ) {\\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\\n\treturn dot( weights, color.rgb );\\n}\\nbool isPerspectiveMatrix( mat4 m ) {\\n\treturn m[ 2 ][ 3 ] == - 1.0;\\n}\\nvec2 equirectUv( in vec3 dir ) {\\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\\n\treturn vec2( u, v );\\n}\";\nvar cube_uv_reflection_fragment = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n\t#define cubeUV_maxMipLevel 8.0\\n\t#define cubeUV_minMipLevel 4.0\\n\t#define cubeUV_maxTileSize 256.0\\n\t#define cubeUV_minTileSize 16.0\\n\tfloat getFace( vec3 direction ) {\\n\t\tvec3 absDirection = abs( direction );\\n\t\tfloat face = - 1.0;\\n\t\tif ( absDirection.x > absDirection.z ) {\\n\t\t\tif ( absDirection.x > absDirection.y )\\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\\n\t\t\telse\\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\t\t} else {\\n\t\t\tif ( absDirection.z > absDirection.y )\\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\\n\t\t\telse\\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\\n\t\t}\\n\t\treturn face;\\n\t}\\n\tvec2 getUV( vec3 direction, float face ) {\\n\t\tvec2 uv;\\n\t\tif ( face == 0.0 ) {\\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\\n\t\t} else if ( face == 1.0 ) {\\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\\n\t\t} else if ( face == 2.0 ) {\\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\\n\t\t} else if ( face == 3.0 ) {\\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\\n\t\t} else if ( face == 4.0 ) {\\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\\n\t\t} else {\\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\\n\t\t}\\n\t\treturn 0.5 * ( uv + 1.0 );\\n\t}\\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\\n\t\tfloat face = getFace( direction );\\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\\n\t\tfloat faceSize = exp2( mipInt );\\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\\n\t\tvec2 f = fract( uv );\\n\t\tuv += 0.5 - f;\\n\t\tif ( face > 2.0 ) {\\n\t\t\tuv.y += faceSize;\\n\t\t\tface -= 3.0;\\n\t\t}\\n\t\tuv.x += face * faceSize;\\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\\n\t\t}\\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\\n\t\tuv *= texelSize;\\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\t\tuv.x += texelSize;\\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\t\tuv.y += texelSize;\\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\t\tuv.x -= texelSize;\\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\\n\t\tvec3 tm = mix( tl, tr, f.x );\\n\t\tvec3 bm = mix( bl, br, f.x );\\n\t\treturn mix( tm, bm, f.y );\\n\t}\\n\t#define r0 1.0\\n\t#define v0 0.339\\n\t#define m0 - 2.0\\n\t#define r1 0.8\\n\t#define v1 0.276\\n\t#define m1 - 1.0\\n\t#define r4 0.4\\n\t#define v4 0.046\\n\t#define m4 2.0\\n\t#define r5 0.305\\n\t#define v5 0.016\\n\t#define m5 3.0\\n\t#define r6 0.21\\n\t#define v6 0.0038\\n\t#define m6 4.0\\n\tfloat roughnessToMip( float roughness ) {\\n\t\tfloat mip = 0.0;\\n\t\tif ( roughness >= r1 ) {\\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\\n\t\t} else if ( roughness >= r4 ) {\\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\\n\t\t} else if ( roughness >= r5 ) {\\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\\n\t\t} else if ( roughness >= r6 ) {\\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\\n\t\t} else {\\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\\n\t\treturn mip;\\n\t}\\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\\n\t\tfloat mipF = fract( mip );\\n\t\tfloat mipInt = floor( mip );\\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\\n\t\tif ( mipF == 0.0 ) {\\n\t\t\treturn vec4( color0, 1.0 );\\n\t\t} else {\\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\\n\t\t}\\n\t}\\n#endif\";\nvar defaultnormal_vertex = \"vec3 transformedNormal = objectNormal;\\n#ifdef USE_INSTANCING\\n\tmat3 m = mat3( instanceMatrix );\\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\\n\ttransformedNormal = m * transformedNormal;\\n#endif\\ntransformedNormal = normalMatrix * transformedNormal;\\n#ifdef FLIP_SIDED\\n\ttransformedNormal = - transformedNormal;\\n#endif\\n#ifdef USE_TANGENT\\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\t#ifdef FLIP_SIDED\\n\t\ttransformedTangent = - transformedTangent;\\n\t#endif\\n#endif\";\nvar displacementmap_pars_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\";\nvar displacementmap_vertex = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\\n#endif\";\nvar emissivemap_fragment = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\";\nvar emissivemap_pars_fragment = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\";\nvar encodings_fragment = \"gl_FragColor = linearToOutputTexel( gl_FragColor );\";\nvar encodings_pars_fragment = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n\treturn value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n\tM = ceil( M * 255.0 ) / 255.0;\\n\treturn vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\\n\tfloat D = max( maxRange / maxRGB, 1.0 );\\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value ) {\\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\\n\tvec4 vResult;\\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n\tvResult.w = fract( Le );\\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\\n\treturn vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n\tfloat Le = value.z * 255.0 + value.w;\\n\tvec3 Xp_Y_XYZp;\\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\\n}\";\nvar envmap_fragment = \"#ifdef USE_ENVMAP\\n\t#ifdef ENV_WORLDPOS\\n\t\tvec3 cameraToFrag;\\n\t\tif ( isOrthographic ) {\\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\t\t} else {\\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\\n\t\t}\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\\n\t#else\\n\t\tvec4 envColor = vec4( 0.0 );\\n\t#endif\\n\t#ifndef ENVMAP_TYPE_CUBE_UV\\n\t\tenvColor = envMapTexelToLinear( envColor );\\n\t#endif\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\";\nvar envmap_common_pars_fragment = \"#ifdef USE_ENVMAP\\n\tuniform float envMapIntensity;\\n\tuniform float flipEnvMap;\\n\tuniform int maxMipLevel;\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\t\\n#endif\";\nvar envmap_pars_fragment = \"#ifdef USE_ENVMAP\\n\tuniform float reflectivity;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\t#define ENV_WORLDPOS\\n\t#endif\\n\t#ifdef ENV_WORLDPOS\\n\t\tvarying vec3 vWorldPosition;\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\";\nvar envmap_pars_vertex = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\\n\t\t#define ENV_WORLDPOS\\n\t#endif\\n\t#ifdef ENV_WORLDPOS\\n\t\t\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\";\nvar envmap_vertex = \"#ifdef USE_ENVMAP\\n\t#ifdef ENV_WORLDPOS\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex;\\n\t\tif ( isOrthographic ) {\\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\\n\t\t} else {\\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\t}\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\";\nvar fog_vertex = \"#ifdef USE_FOG\\n\tfogDepth = - mvPosition.z;\\n#endif\";\nvar fog_pars_vertex = \"#ifdef USE_FOG\\n\tvarying float fogDepth;\\n#endif\";\nvar fog_fragment = \"#ifdef USE_FOG\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\";\nvar fog_pars_fragment = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\tvarying float fogDepth;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\nvar gradientmap_pars_fragment = \"#ifdef USE_GRADIENTMAP\\n\tuniform sampler2D gradientMap;\\n#endif\\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\\n\tfloat dotNL = dot( normal, lightDirection );\\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\\n\t#ifdef USE_GRADIENTMAP\\n\t\treturn texture2D( gradientMap, coord ).rgb;\\n\t#else\\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\\n\t#endif\\n}\";\nvar lightmap_fragment = \"#ifdef USE_LIGHTMAP\\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n#endif\";\nvar lightmap_pars_fragment = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\nvar lights_lambert_vertex = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\nvIndirectFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n\tvIndirectBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\\n#ifdef DOUBLE_SIDED\\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\";\nvar lights_pars_begin = \"uniform bool receiveShadow;\\nuniform vec3 ambientLightColor;\\nuniform vec3 lightProbe[ 9 ];\\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\\n\tfloat x = normal.x, y = normal.y, z = normal.z;\\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\\n\treturn result;\\n}\\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\\n\treturn irradiance;\\n}\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tdirectLight.color = pointLight.color;\\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( angleCos > spotLight.coneCos ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\tstruct RectAreaLight {\\n\t\tvec3 color;\\n\t\tvec3 position;\\n\t\tvec3 halfWidth;\\n\t\tvec3 halfHeight;\\n\t};\\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\";\nvar envmap_physical_pars_fragment = \"#if defined( USE_ENVMAP )\\n\t#ifdef ENVMAP_MODE_REFRACTION\\n\t\tuniform float refractionRatio;\\n\t#endif\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\\n\t\t#endif\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\";\nvar lights_toon_fragment = \"ToonMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\";\nvar lights_toon_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct ToonMaterial {\\n\tvec3 diffuseColor;\\n};\\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Toon\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\\n#define Material_LightProbeLOD( material )\t(0)\";\nvar lights_phong_fragment = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\";\nvar lights_phong_pars_fragment = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3 diffuseColor;\\n\tvec3 specularColor;\\n\tfloat specularShininess;\\n\tfloat specularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\";\nvar lights_physical_fragment = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\\n#ifdef REFLECTIVITY\\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\\n#endif\\n#ifdef CLEARCOAT\\n\tmaterial.clearcoat = clearcoat;\\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\\n\t#ifdef USE_CLEARCOATMAP\\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\\n\t#endif\\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\\n\t#endif\\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\\n\tmaterial.clearcoatRoughness += geometryRoughness;\\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\\n#endif\\n#ifdef USE_SHEEN\\n\tmaterial.sheenColor = sheen;\\n#endif\";\nvar lights_physical_pars_fragment = \"struct PhysicalMaterial {\\n\tvec3 diffuseColor;\\n\tfloat specularRoughness;\\n\tvec3 specularColor;\\n#ifdef CLEARCOAT\\n\tfloat clearcoat;\\n\tfloat clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\tvec3 sheenColor;\\n#endif\\n};\\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\\n}\\n#if NUM_RECT_AREA_LIGHTS > 0\\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\t\tvec3 normal = geometry.normal;\\n\t\tvec3 viewDir = geometry.viewDir;\\n\t\tvec3 position = geometry.position;\\n\t\tvec3 lightPos = rectAreaLight.position;\\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\\n\t\tvec3 lightColor = rectAreaLight.color;\\n\t\tfloat roughness = material.specularRoughness;\\n\t\tvec3 rectCoords[ 4 ];\\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\\n\t\tvec4 t1 = texture2D( ltc_1, uv );\\n\t\tvec4 t2 = texture2D( ltc_2, uv );\\n\t\tmat3 mInv = mat3(\\n\t\t\tvec3( t1.x, 0, t1.y ),\\n\t\t\tvec3(    0, 1,    0 ),\\n\t\t\tvec3( t1.z, 0, t1.w )\\n\t\t);\\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\\n\t}\\n#endif\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\t#ifdef CLEARCOAT\\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tccIrradiance *= PI;\\n\t\t#endif\\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\t#else\\n\t\tfloat clearcoatDHR = 0.0;\\n\t#endif\\n\t#ifdef USE_SHEEN\\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\\n\t\t\tmaterial.specularRoughness,\\n\t\t\tdirectLight.direction,\\n\t\t\tgeometry,\\n\t\t\tmaterial.sheenColor\\n\t\t);\\n\t#else\\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\\n\t#endif\\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\\n\t#ifdef CLEARCOAT\\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\\n\t\tfloat ccDotNL = ccDotNV;\\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\\n\t#else\\n\t\tfloat clearcoatDHR = 0.0;\\n\t#endif\\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\\n\tvec3 singleScattering = vec3( 0.0 );\\n\tvec3 multiScattering = vec3( 0.0 );\\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\";\nvar lights_fragment_begin = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\\n#ifdef CLEARCOAT\\n\tgeometry.clearcoatNormal = clearcoatNormal;\\n#endif\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\\n\tPointLightShadow pointLightShadow;\\n\t#endif\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\\n\t\tpointLightShadow = pointLightShadows[ i ];\\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\\n\tSpotLightShadow spotLightShadow;\\n\t#endif\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\\n\t\tspotLightShadow = spotLightShadows[ i ];\\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\\n\tDirectionalLightShadow directionalLightShadow;\\n\t#endif\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\\n\tRectAreaLight rectAreaLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\\n\t\trectAreaLight = rectAreaLights[ i ];\\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\\n\t}\\n\t#pragma unroll_loop_end\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 iblIrradiance = vec3( 0.0 );\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\t#pragma unroll_loop_start\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t\t#pragma unroll_loop_end\\n\t#endif\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\tvec3 radiance = vec3( 0.0 );\\n\tvec3 clearcoatRadiance = vec3( 0.0 );\\n#endif\";\nvar lights_fragment_maps = \"#if defined( RE_IndirectDiffuse )\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\\n\t#endif\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\\n\t#ifdef CLEARCOAT\\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\\n\t#endif\\n#endif\";\nvar lights_fragment_end = \"#if defined( RE_IndirectDiffuse )\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( RE_IndirectSpecular )\\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\\n#endif\";\nvar logdepthbuf_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\\n#endif\";\nvar logdepthbuf_pars_fragment = \"#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\\n\tuniform float logDepthBufFC;\\n\tvarying float vFragDepth;\\n\tvarying float vIsPerspective;\\n#endif\";\nvar logdepthbuf_pars_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t\tvarying float vIsPerspective;\\n\t#else\\n\t\tuniform float logDepthBufFC;\\n\t#endif\\n#endif\";\nvar logdepthbuf_vertex = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\\n\t#else\\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\\n\t\t\tgl_Position.z *= gl_Position.w;\\n\t\t}\\n\t#endif\\n#endif\";\nvar map_fragment = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\";\nvar map_pars_fragment = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\";\nvar map_particle_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\\n#endif\\n#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, uv );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\\n#endif\";\nvar map_particle_pars_fragment = \"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\\n\tuniform mat3 uvTransform;\\n#endif\\n#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\";\nvar metalnessmap_fragment = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.b;\\n#endif\";\nvar metalnessmap_pars_fragment = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\nvar morphnormal_vertex = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal *= morphTargetBaseInfluence;\\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\\n#endif\";\nvar morphtarget_pars_vertex = \"#ifdef USE_MORPHTARGETS\\n\tuniform float morphTargetBaseInfluence;\\n\t#ifndef USE_MORPHNORMALS\\n\t\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\t\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\nvar morphtarget_vertex = \"#ifdef USE_MORPHTARGETS\\n\ttransformed *= morphTargetBaseInfluence;\\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\";\nvar normal_fragment_begin = \"float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\\n#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * faceDirection;\\n\t#endif\\n\t#ifdef USE_TANGENT\\n\t\tvec3 tangent = normalize( vTangent );\\n\t\tvec3 bitangent = normalize( vBitangent );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\ttangent = tangent * faceDirection;\\n\t\t\tbitangent = bitangent * faceDirection;\\n\t\t#endif\\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\\n\t\t#endif\\n\t#endif\\n#endif\\nvec3 geometryNormal = normal;\";\nvar normal_fragment_maps = \"#ifdef OBJECTSPACE_NORMALMAP\\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t#ifdef FLIP_SIDED\\n\t\tnormal = - normal;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * faceDirection;\\n\t#endif\\n\tnormal = normalize( normalMatrix * normal );\\n#elif defined( TANGENTSPACE_NORMALMAP )\\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\tmapN.xy *= normalScale;\\n\t#ifdef USE_TANGENT\\n\t\tnormal = normalize( vTBN * mapN );\\n\t#else\\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\\n\t#endif\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\\n#endif\";\nvar normalmap_pars_fragment = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n#endif\\n#ifdef OBJECTSPACE_NORMALMAP\\n\tuniform mat3 normalMatrix;\\n#endif\\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 N = surf_norm;\\n\t\tvec3 q1perp = cross( q1, N );\\n\t\tvec3 q0perp = cross( N, q0 );\\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\\n\t}\\n#endif\";\nvar clearcoat_normal_fragment_begin = \"#ifdef CLEARCOAT\\n\tvec3 clearcoatNormal = geometryNormal;\\n#endif\";\nvar clearcoat_normal_fragment_maps = \"#ifdef USE_CLEARCOAT_NORMALMAP\\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\\n\tclearcoatMapN.xy *= clearcoatNormalScale;\\n\t#ifdef USE_TANGENT\\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\\n\t#else\\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\\n\t#endif\\n#endif\";\nvar clearcoat_pars_fragment = \"#ifdef USE_CLEARCOATMAP\\n\tuniform sampler2D clearcoatMap;\\n#endif\\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\\n\tuniform sampler2D clearcoatRoughnessMap;\\n#endif\\n#ifdef USE_CLEARCOAT_NORMALMAP\\n\tuniform sampler2D clearcoatNormalMap;\\n\tuniform vec2 clearcoatNormalScale;\\n#endif\";\nvar packing = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n\treturn normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n\treturn 2.0 * rgb.xyz - 1.0;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nvec4 pack2HalfToRGBA( vec2 v ) {\\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\\n}\\nvec2 unpackRGBATo2Half( vec4 v ) {\\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\\n}\\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\\n\treturn ( viewZ + near ) / ( near - far );\\n}\\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n\treturn linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\";\nvar premultiplied_alpha_fragment = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\";\nvar project_vertex = \"vec4 mvPosition = vec4( transformed, 1.0 );\\n#ifdef USE_INSTANCING\\n\tmvPosition = instanceMatrix * mvPosition;\\n#endif\\nmvPosition = modelViewMatrix * mvPosition;\\ngl_Position = projectionMatrix * mvPosition;\";\nvar dithering_fragment = \"#ifdef DITHERING\\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\\n#endif\";\nvar dithering_pars_fragment = \"#ifdef DITHERING\\n\tvec3 dithering( vec3 color ) {\\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\\n\t\treturn color + dither_shift_RGB;\\n\t}\\n#endif\";\nvar roughnessmap_fragment = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.g;\\n#endif\";\nvar roughnessmap_pars_fragment = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\nvar shadowmap_pars_fragment = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tstruct DirectionalLightShadow {\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t\tstruct SpotLightShadow {\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tstruct PointLightShadow {\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t\tfloat shadowCameraNear;\\n\t\t\tfloat shadowCameraFar;\\n\t\t};\\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\\n\t}\\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\\n\t\tfloat occlusion = 1.0;\\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\\n\t\tfloat hard_shadow = step( compare , distribution.x );\\n\t\tif (hard_shadow != 1.0 ) {\\n\t\t\tfloat distance = compare - distribution.x ;\\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\\n\t\t}\\n\t\treturn occlusion;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tfloat shadow = 1.0;\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\tfloat dx2 = dx0 / 2.0;\\n\t\t\tfloat dy2 = dy0 / 2.0;\\n\t\t\tfloat dx3 = dx1 / 2.0;\\n\t\t\tfloat dy3 = dy1 / 2.0;\\n\t\t\tshadow = (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 17.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx = texelSize.x;\\n\t\t\tfloat dy = texelSize.y;\\n\t\t\tvec2 uv = shadowCoord.xy;\\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\\n\t\t\tuv -= f * texelSize;\\n\t\t\tshadow = (\\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\\n\t\t\t\t\t f.x ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\\n\t\t\t\t\t f.x ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t f.y ) +\\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t f.y ) +\\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\\n\t\t\t\t\t\t  f.x ),\\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\\n\t\t\t\t\t\t  f.x ),\\n\t\t\t\t\t f.y )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#else\\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn shadow;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\";\nvar shadowmap_pars_vertex = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\\n\t\tstruct DirectionalLightShadow {\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t\tstruct SpotLightShadow {\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t};\\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\\n\t\tstruct PointLightShadow {\\n\t\t\tfloat shadowBias;\\n\t\t\tfloat shadowNormalBias;\\n\t\t\tfloat shadowRadius;\\n\t\t\tvec2 shadowMapSize;\\n\t\t\tfloat shadowCameraNear;\\n\t\t\tfloat shadowCameraFar;\\n\t\t};\\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\\n\t#endif\\n#endif\";\nvar shadowmap_vertex = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\tvec4 shadowWorldPosition;\\n\t#endif\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n#endif\";\nvar shadowmask_pars_fragment = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\\n\tDirectionalLightShadow directionalLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\\n\t\tdirectionalLight = directionalLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\\n\tSpotLightShadow spotLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\\n\t\tspotLight = spotLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\\n\tPointLightShadow pointLight;\\n\t#pragma unroll_loop_start\\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\\n\t\tpointLight = pointLightShadows[ i ];\\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\\n\t}\\n\t#pragma unroll_loop_end\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\";\nvar skinbase_vertex = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\nvar skinning_pars_vertex = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform highp sampler2D boneTexture;\\n\t\tuniform int boneTextureSize;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\";\nvar skinning_vertex = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\\n#endif\";\nvar skinnormal_vertex = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n\t#ifdef USE_TANGENT\\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\\n\t#endif\\n#endif\";\nvar specularmap_fragment = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\nvar specularmap_pars_fragment = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\nvar tonemapping_fragment = \"#if defined( TONE_MAPPING )\\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\";\nvar tonemapping_pars_fragment = \"#ifndef saturate\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#endif\\nuniform float toneMappingExposure;\\nvec3 LinearToneMapping( vec3 color ) {\\n\treturn toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n\tcolor *= toneMappingExposure;\\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n\tcolor *= toneMappingExposure;\\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\nvec3 RRTAndODTFit( vec3 v ) {\\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\\n\treturn a / b;\\n}\\nvec3 ACESFilmicToneMapping( vec3 color ) {\\n\tconst mat3 ACESInputMat = mat3(\\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\\n\t);\\n\tconst mat3 ACESOutputMat = mat3(\\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\\n\t);\\n\tcolor *= toneMappingExposure / 0.6;\\n\tcolor = ACESInputMat * color;\\n\tcolor = RRTAndODTFit( color );\\n\tcolor = ACESOutputMat * color;\\n\treturn saturate( color );\\n}\\nvec3 CustomToneMapping( vec3 color ) { return color; }\";\nvar transmissionmap_fragment = \"#ifdef USE_TRANSMISSIONMAP\\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\\n#endif\";\nvar transmissionmap_pars_fragment = \"#ifdef USE_TRANSMISSIONMAP\\n\tuniform sampler2D transmissionMap;\\n#endif\";\nvar uv_pars_fragment = \"#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\\n\tvarying vec2 vUv;\\n#endif\";\nvar uv_pars_vertex = \"#ifdef USE_UV\\n\t#ifdef UVS_VERTEX_ONLY\\n\t\tvec2 vUv;\\n\t#else\\n\t\tvarying vec2 vUv;\\n\t#endif\\n\tuniform mat3 uvTransform;\\n#endif\";\nvar uv_vertex = \"#ifdef USE_UV\\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n#endif\";\nvar uv2_pars_fragment = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\nvar uv2_pars_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n\tuniform mat3 uv2Transform;\\n#endif\";\nvar uv2_vertex = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\\n#endif\";\nvar worldpos_vertex = \"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\\n\tvec4 worldPosition = vec4( transformed, 1.0 );\\n\t#ifdef USE_INSTANCING\\n\t\tworldPosition = instanceMatrix * worldPosition;\\n\t#endif\\n\tworldPosition = modelMatrix * worldPosition;\\n#endif\";\nvar background_frag = \"uniform sampler2D t2D;\\nvarying vec2 vUv;\\nvoid main() {\\n\tvec4 texColor = texture2D( t2D, vUv );\\n\tgl_FragColor = mapTexelToLinear( texColor );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n}\";\nvar background_vert = \"varying vec2 vUv;\\nuniform mat3 uvTransform;\\nvoid main() {\\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\\n}\";\nvar cube_frag = \"#include <envmap_common_pars_fragment>\\nuniform float opacity;\\nvarying vec3 vWorldDirection;\\n#include <cube_uv_reflection_fragment>\\nvoid main() {\\n\tvec3 vReflect = vWorldDirection;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = envColor;\\n\tgl_FragColor.a *= opacity;\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n}\";\nvar cube_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvWorldDirection = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\tgl_Position.z = gl_Position.w;\\n}\";\nvar depth_frag = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\\n\t#endif\\n}\";\nvar depth_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvarying vec2 vHighPrecisionZW;\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_DISPLACEMENTMAP\\n\t\t#include <beginnormal_vertex>\\n\t\t#include <morphnormal_vertex>\\n\t\t#include <skinnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvHighPrecisionZW = gl_Position.zw;\\n}\";\nvar distanceRGBA_frag = \"#define DISTANCE\\nuniform vec3 referencePosition;\\nuniform float nearDistance;\\nuniform float farDistance;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\tfloat dist = length( vWorldPosition - referencePosition );\\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\\n\tdist = saturate( dist );\\n\tgl_FragColor = packDepthToRGBA( dist );\\n}\";\nvar distanceRGBA_vert = \"#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_DISPLACEMENTMAP\\n\t\t#include <beginnormal_vertex>\\n\t\t#include <morphnormal_vertex>\\n\t\t#include <skinnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition.xyz;\\n}\";\nvar equirect_frag = \"uniform sampler2D tEquirect;\\nvarying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvec3 direction = normalize( vWorldDirection );\\n\tvec2 sampleUV = equirectUv( direction );\\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\\n\tgl_FragColor = mapTexelToLinear( texColor );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n}\";\nvar equirect_vert = \"varying vec3 vWorldDirection;\\n#include <common>\\nvoid main() {\\n\tvWorldDirection = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n}\";\nvar linedashed_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n}\";\nvar linedashed_vert = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvLineDistance = scale * lineDistance;\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar meshbasic_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\t#ifdef USE_LIGHTMAP\\n\t\\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\\n\t#else\\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\\n\t#endif\\n\t#include <aomap_fragment>\\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nvar meshbasic_vert = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar meshlambert_frag = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\\n\t#else\\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\\n\t#endif\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nvar meshlambert_vert = \"#define LAMBERT\\nvarying vec3 vLightFront;\\nvarying vec3 vIndirectFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n\tvarying vec3 vIndirectBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar meshmatcap_frag = \"#define MATCAP\\nuniform vec3 diffuse;\\nuniform float opacity;\\nuniform sampler2D matcap;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\tvec3 viewDir = normalize( vViewPosition );\\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\\n\tvec3 y = cross( viewDir, x );\\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\\n\t#ifdef USE_MATCAP\\n\t\tvec4 matcapColor = texture2D( matcap, uv );\\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\\n\t#else\\n\t\tvec4 matcapColor = vec4( 1.0 );\\n\t#endif\\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nvar meshmatcap_vert = \"#define MATCAP\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <color_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#ifndef FLAT_SHADED\\n\t\tvNormal = normalize( transformedNormal );\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <fog_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n}\";\nvar meshtoon_frag = \"#define TOON\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <gradientmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_toon_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_toon_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nvar meshtoon_vert = \"#define TOON\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar meshphong_frag = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <cube_uv_reflection_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nvar meshphong_vert = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar meshphysical_frag = \"#define STANDARD\\n#ifdef PHYSICAL\\n\t#define REFLECTIVITY\\n\t#define CLEARCOAT\\n\t#define TRANSMISSION\\n#endif\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\n#ifdef TRANSMISSION\\n\tuniform float transmission;\\n#endif\\n#ifdef REFLECTIVITY\\n\tuniform float reflectivity;\\n#endif\\n#ifdef CLEARCOAT\\n\tuniform float clearcoat;\\n\tuniform float clearcoatRoughness;\\n#endif\\n#ifdef USE_SHEEN\\n\tuniform vec3 sheen;\\n#endif\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef USE_TANGENT\\n\t\tvarying vec3 vTangent;\\n\t\tvarying vec3 vBitangent;\\n\t#endif\\n#endif\\n#include <common>\\n#include <packing>\\n#include <dithering_pars_fragment>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <transmissionmap_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <envmap_common_pars_fragment>\\n#include <envmap_physical_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <lights_pars_begin>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <clearcoat_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#ifdef TRANSMISSION\\n\t\tfloat totalTransmission = transmission;\\n\t#endif\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\t#include <clearcoat_normal_fragment_begin>\\n\t#include <clearcoat_normal_fragment_maps>\\n\t#include <emissivemap_fragment>\\n\t#include <transmissionmap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_fragment_begin>\\n\t#include <lights_fragment_maps>\\n\t#include <lights_fragment_end>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#ifdef TRANSMISSION\\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\\n\t#endif\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <dithering_fragment>\\n}\";\nvar meshphysical_vert = \"#define STANDARD\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef USE_TANGENT\\n\t\tvarying vec3 vTangent;\\n\t\tvarying vec3 vBitangent;\\n\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n\t#ifdef USE_TANGENT\\n\t\tvTangent = normalize( transformedTangent );\\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\t#endif\\n#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar normal_frag = \"#define NORMAL\\nuniform float opacity;\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef USE_TANGENT\\n\t\tvarying vec3 vTangent;\\n\t\tvarying vec3 vBitangent;\\n\t#endif\\n#endif\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#include <normal_fragment_begin>\\n\t#include <normal_fragment_maps>\\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\\n}\";\nvar normal_vert = \"#define NORMAL\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\tvarying vec3 vViewPosition;\\n#endif\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n\t#ifdef USE_TANGENT\\n\t\tvarying vec3 vTangent;\\n\t\tvarying vec3 vBitangent;\\n\t#endif\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n\t#ifdef USE_TANGENT\\n\t\tvTangent = normalize( transformedTangent );\\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\\n\t#endif\\n#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n}\";\nvar points_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n\t#include <premultiplied_alpha_fragment>\\n}\";\nvar points_vert = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\tgl_PointSize = size;\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar shadow_frag = \"uniform vec3 color;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars_begin>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\";\nvar shadow_vert = \"#include <common>\\n#include <fog_pars_vertex>\\n#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <shadowmap_vertex>\\n\t#include <fog_vertex>\\n}\";\nvar sprite_frag = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\";\nvar sprite_vert = \"uniform float rotation;\\nuniform vec2 center;\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <fog_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\\n\tvec2 scale;\\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\\n\t#ifndef USE_SIZEATTENUATION\\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\\n\t#endif\\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\\n\tvec2 rotatedPosition;\\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\\n\tmvPosition.xy += rotatedPosition;\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <fog_vertex>\\n}\";\nconst ShaderChunk = {\n  alphamap_fragment,\n  alphamap_pars_fragment,\n  alphatest_fragment,\n  aomap_fragment,\n  aomap_pars_fragment,\n  begin_vertex,\n  beginnormal_vertex,\n  bsdfs,\n  bumpmap_pars_fragment,\n  clipping_planes_fragment,\n  clipping_planes_pars_fragment,\n  clipping_planes_pars_vertex,\n  clipping_planes_vertex,\n  color_fragment,\n  color_pars_fragment,\n  color_pars_vertex,\n  color_vertex,\n  common,\n  cube_uv_reflection_fragment,\n  defaultnormal_vertex,\n  displacementmap_pars_vertex,\n  displacementmap_vertex,\n  emissivemap_fragment,\n  emissivemap_pars_fragment,\n  encodings_fragment,\n  encodings_pars_fragment,\n  envmap_fragment,\n  envmap_common_pars_fragment,\n  envmap_pars_fragment,\n  envmap_pars_vertex,\n  envmap_physical_pars_fragment,\n  envmap_vertex,\n  fog_vertex,\n  fog_pars_vertex,\n  fog_fragment,\n  fog_pars_fragment,\n  gradientmap_pars_fragment,\n  lightmap_fragment,\n  lightmap_pars_fragment,\n  lights_lambert_vertex,\n  lights_pars_begin,\n  lights_toon_fragment,\n  lights_toon_pars_fragment,\n  lights_phong_fragment,\n  lights_phong_pars_fragment,\n  lights_physical_fragment,\n  lights_physical_pars_fragment,\n  lights_fragment_begin,\n  lights_fragment_maps,\n  lights_fragment_end,\n  logdepthbuf_fragment,\n  logdepthbuf_pars_fragment,\n  logdepthbuf_pars_vertex,\n  logdepthbuf_vertex,\n  map_fragment,\n  map_pars_fragment,\n  map_particle_fragment,\n  map_particle_pars_fragment,\n  metalnessmap_fragment,\n  metalnessmap_pars_fragment,\n  morphnormal_vertex,\n  morphtarget_pars_vertex,\n  morphtarget_vertex,\n  normal_fragment_begin,\n  normal_fragment_maps,\n  normalmap_pars_fragment,\n  clearcoat_normal_fragment_begin,\n  clearcoat_normal_fragment_maps,\n  clearcoat_pars_fragment,\n  packing,\n  premultiplied_alpha_fragment,\n  project_vertex,\n  dithering_fragment,\n  dithering_pars_fragment,\n  roughnessmap_fragment,\n  roughnessmap_pars_fragment,\n  shadowmap_pars_fragment,\n  shadowmap_pars_vertex,\n  shadowmap_vertex,\n  shadowmask_pars_fragment,\n  skinbase_vertex,\n  skinning_pars_vertex,\n  skinning_vertex,\n  skinnormal_vertex,\n  specularmap_fragment,\n  specularmap_pars_fragment,\n  tonemapping_fragment,\n  tonemapping_pars_fragment,\n  transmissionmap_fragment,\n  transmissionmap_pars_fragment,\n  uv_pars_fragment,\n  uv_pars_vertex,\n  uv_vertex,\n  uv2_pars_fragment,\n  uv2_pars_vertex,\n  uv2_vertex,\n  worldpos_vertex,\n  background_frag,\n  background_vert,\n  cube_frag,\n  cube_vert,\n  depth_frag,\n  depth_vert,\n  distanceRGBA_frag,\n  distanceRGBA_vert,\n  equirect_frag,\n  equirect_vert,\n  linedashed_frag,\n  linedashed_vert,\n  meshbasic_frag,\n  meshbasic_vert,\n  meshlambert_frag,\n  meshlambert_vert,\n  meshmatcap_frag,\n  meshmatcap_vert,\n  meshtoon_frag,\n  meshtoon_vert,\n  meshphong_frag,\n  meshphong_vert,\n  meshphysical_frag,\n  meshphysical_vert,\n  normal_frag,\n  normal_vert,\n  points_frag,\n  points_vert,\n  shadow_frag,\n  shadow_vert,\n  sprite_frag,\n  sprite_vert\n};\nconst UniformsLib = {\n  common: {\n    diffuse: {value: new Color(15658734)},\n    opacity: {value: 1},\n    map: {value: null},\n    uvTransform: {value: new Matrix3()},\n    uv2Transform: {value: new Matrix3()},\n    alphaMap: {value: null}\n  },\n  specularmap: {\n    specularMap: {value: null}\n  },\n  envmap: {\n    envMap: {value: null},\n    flipEnvMap: {value: -1},\n    reflectivity: {value: 1},\n    refractionRatio: {value: 0.98},\n    maxMipLevel: {value: 0}\n  },\n  aomap: {\n    aoMap: {value: null},\n    aoMapIntensity: {value: 1}\n  },\n  lightmap: {\n    lightMap: {value: null},\n    lightMapIntensity: {value: 1}\n  },\n  emissivemap: {\n    emissiveMap: {value: null}\n  },\n  bumpmap: {\n    bumpMap: {value: null},\n    bumpScale: {value: 1}\n  },\n  normalmap: {\n    normalMap: {value: null},\n    normalScale: {value: new Vector2(1, 1)}\n  },\n  displacementmap: {\n    displacementMap: {value: null},\n    displacementScale: {value: 1},\n    displacementBias: {value: 0}\n  },\n  roughnessmap: {\n    roughnessMap: {value: null}\n  },\n  metalnessmap: {\n    metalnessMap: {value: null}\n  },\n  gradientmap: {\n    gradientMap: {value: null}\n  },\n  fog: {\n    fogDensity: {value: 25e-5},\n    fogNear: {value: 1},\n    fogFar: {value: 2e3},\n    fogColor: {value: new Color(16777215)}\n  },\n  lights: {\n    ambientLightColor: {value: []},\n    lightProbe: {value: []},\n    directionalLights: {value: [], properties: {\n      direction: {},\n      color: {}\n    }},\n    directionalLightShadows: {value: [], properties: {\n      shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: {},\n      shadowMapSize: {}\n    }},\n    directionalShadowMap: {value: []},\n    directionalShadowMatrix: {value: []},\n    spotLights: {value: [], properties: {\n      color: {},\n      position: {},\n      direction: {},\n      distance: {},\n      coneCos: {},\n      penumbraCos: {},\n      decay: {}\n    }},\n    spotLightShadows: {value: [], properties: {\n      shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: {},\n      shadowMapSize: {}\n    }},\n    spotShadowMap: {value: []},\n    spotShadowMatrix: {value: []},\n    pointLights: {value: [], properties: {\n      color: {},\n      position: {},\n      decay: {},\n      distance: {}\n    }},\n    pointLightShadows: {value: [], properties: {\n      shadowBias: {},\n      shadowNormalBias: {},\n      shadowRadius: {},\n      shadowMapSize: {},\n      shadowCameraNear: {},\n      shadowCameraFar: {}\n    }},\n    pointShadowMap: {value: []},\n    pointShadowMatrix: {value: []},\n    hemisphereLights: {value: [], properties: {\n      direction: {},\n      skyColor: {},\n      groundColor: {}\n    }},\n    rectAreaLights: {value: [], properties: {\n      color: {},\n      position: {},\n      width: {},\n      height: {}\n    }},\n    ltc_1: {value: null},\n    ltc_2: {value: null}\n  },\n  points: {\n    diffuse: {value: new Color(15658734)},\n    opacity: {value: 1},\n    size: {value: 1},\n    scale: {value: 1},\n    map: {value: null},\n    alphaMap: {value: null},\n    uvTransform: {value: new Matrix3()}\n  },\n  sprite: {\n    diffuse: {value: new Color(15658734)},\n    opacity: {value: 1},\n    center: {value: new Vector2(0.5, 0.5)},\n    rotation: {value: 0},\n    map: {value: null},\n    alphaMap: {value: null},\n    uvTransform: {value: new Matrix3()}\n  }\n};\nconst ShaderLib = {\n  basic: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.fog\n    ]),\n    vertexShader: ShaderChunk.meshbasic_vert,\n    fragmentShader: ShaderChunk.meshbasic_frag\n  },\n  lambert: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: {value: new Color(0)}\n      }\n    ]),\n    vertexShader: ShaderChunk.meshlambert_vert,\n    fragmentShader: ShaderChunk.meshlambert_frag\n  },\n  phong: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.specularmap,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: {value: new Color(0)},\n        specular: {value: new Color(1118481)},\n        shininess: {value: 30}\n      }\n    ]),\n    vertexShader: ShaderChunk.meshphong_vert,\n    fragmentShader: ShaderChunk.meshphong_frag\n  },\n  standard: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.envmap,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.roughnessmap,\n      UniformsLib.metalnessmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: {value: new Color(0)},\n        roughness: {value: 1},\n        metalness: {value: 0},\n        envMapIntensity: {value: 1}\n      }\n    ]),\n    vertexShader: ShaderChunk.meshphysical_vert,\n    fragmentShader: ShaderChunk.meshphysical_frag\n  },\n  toon: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.aomap,\n      UniformsLib.lightmap,\n      UniformsLib.emissivemap,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.gradientmap,\n      UniformsLib.fog,\n      UniformsLib.lights,\n      {\n        emissive: {value: new Color(0)}\n      }\n    ]),\n    vertexShader: ShaderChunk.meshtoon_vert,\n    fragmentShader: ShaderChunk.meshtoon_frag\n  },\n  matcap: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      UniformsLib.fog,\n      {\n        matcap: {value: null}\n      }\n    ]),\n    vertexShader: ShaderChunk.meshmatcap_vert,\n    fragmentShader: ShaderChunk.meshmatcap_frag\n  },\n  points: {\n    uniforms: mergeUniforms([\n      UniformsLib.points,\n      UniformsLib.fog\n    ]),\n    vertexShader: ShaderChunk.points_vert,\n    fragmentShader: ShaderChunk.points_frag\n  },\n  dashed: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.fog,\n      {\n        scale: {value: 1},\n        dashSize: {value: 1},\n        totalSize: {value: 2}\n      }\n    ]),\n    vertexShader: ShaderChunk.linedashed_vert,\n    fragmentShader: ShaderChunk.linedashed_frag\n  },\n  depth: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.displacementmap\n    ]),\n    vertexShader: ShaderChunk.depth_vert,\n    fragmentShader: ShaderChunk.depth_frag\n  },\n  normal: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.bumpmap,\n      UniformsLib.normalmap,\n      UniformsLib.displacementmap,\n      {\n        opacity: {value: 1}\n      }\n    ]),\n    vertexShader: ShaderChunk.normal_vert,\n    fragmentShader: ShaderChunk.normal_frag\n  },\n  sprite: {\n    uniforms: mergeUniforms([\n      UniformsLib.sprite,\n      UniformsLib.fog\n    ]),\n    vertexShader: ShaderChunk.sprite_vert,\n    fragmentShader: ShaderChunk.sprite_frag\n  },\n  background: {\n    uniforms: {\n      uvTransform: {value: new Matrix3()},\n      t2D: {value: null}\n    },\n    vertexShader: ShaderChunk.background_vert,\n    fragmentShader: ShaderChunk.background_frag\n  },\n  cube: {\n    uniforms: mergeUniforms([\n      UniformsLib.envmap,\n      {\n        opacity: {value: 1}\n      }\n    ]),\n    vertexShader: ShaderChunk.cube_vert,\n    fragmentShader: ShaderChunk.cube_frag\n  },\n  equirect: {\n    uniforms: {\n      tEquirect: {value: null}\n    },\n    vertexShader: ShaderChunk.equirect_vert,\n    fragmentShader: ShaderChunk.equirect_frag\n  },\n  distanceRGBA: {\n    uniforms: mergeUniforms([\n      UniformsLib.common,\n      UniformsLib.displacementmap,\n      {\n        referencePosition: {value: new Vector3()},\n        nearDistance: {value: 1},\n        farDistance: {value: 1e3}\n      }\n    ]),\n    vertexShader: ShaderChunk.distanceRGBA_vert,\n    fragmentShader: ShaderChunk.distanceRGBA_frag\n  },\n  shadow: {\n    uniforms: mergeUniforms([\n      UniformsLib.lights,\n      UniformsLib.fog,\n      {\n        color: {value: new Color(0)},\n        opacity: {value: 1}\n      }\n    ]),\n    vertexShader: ShaderChunk.shadow_vert,\n    fragmentShader: ShaderChunk.shadow_frag\n  }\n};\nShaderLib.physical = {\n  uniforms: mergeUniforms([\n    ShaderLib.standard.uniforms,\n    {\n      clearcoat: {value: 0},\n      clearcoatMap: {value: null},\n      clearcoatRoughness: {value: 0},\n      clearcoatRoughnessMap: {value: null},\n      clearcoatNormalScale: {value: new Vector2(1, 1)},\n      clearcoatNormalMap: {value: null},\n      sheen: {value: new Color(0)},\n      transmission: {value: 0},\n      transmissionMap: {value: null}\n    }\n  ]),\n  vertexShader: ShaderChunk.meshphysical_vert,\n  fragmentShader: ShaderChunk.meshphysical_frag\n};\nfunction WebGLBackground(renderer, cubemaps, state, objects, premultipliedAlpha) {\n  const clearColor = new Color(0);\n  let clearAlpha = 0;\n  let planeMesh;\n  let boxMesh;\n  let currentBackground = null;\n  let currentBackgroundVersion = 0;\n  let currentTonemapping = null;\n  function render(renderList, scene, camera, forceClear) {\n    let background = scene.isScene === true ? scene.background : null;\n    if (background && background.isTexture) {\n      background = cubemaps.get(background);\n    }\n    const xr = renderer.xr;\n    const session = xr.getSession && xr.getSession();\n    if (session && session.environmentBlendMode === \"additive\") {\n      background = null;\n    }\n    if (background === null) {\n      setClear(clearColor, clearAlpha);\n    } else if (background && background.isColor) {\n      setClear(background, 1);\n      forceClear = true;\n    }\n    if (renderer.autoClear || forceClear) {\n      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);\n    }\n    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {\n      if (boxMesh === void 0) {\n        boxMesh = new Mesh(new BoxGeometry(1, 1, 1), new ShaderMaterial({\n          name: \"BackgroundCubeMaterial\",\n          uniforms: cloneUniforms(ShaderLib.cube.uniforms),\n          vertexShader: ShaderLib.cube.vertexShader,\n          fragmentShader: ShaderLib.cube.fragmentShader,\n          side: BackSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        boxMesh.geometry.deleteAttribute(\"normal\");\n        boxMesh.geometry.deleteAttribute(\"uv\");\n        boxMesh.onBeforeRender = function(renderer2, scene2, camera2) {\n          this.matrixWorld.copyPosition(camera2.matrixWorld);\n        };\n        Object.defineProperty(boxMesh.material, \"envMap\", {\n          get: function() {\n            return this.uniforms.envMap.value;\n          }\n        });\n        objects.update(boxMesh);\n      }\n      boxMesh.material.uniforms.envMap.value = background;\n      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background._needsFlipEnvMap ? -1 : 1;\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        boxMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);\n    } else if (background && background.isTexture) {\n      if (planeMesh === void 0) {\n        planeMesh = new Mesh(new PlaneGeometry(2, 2), new ShaderMaterial({\n          name: \"BackgroundMaterial\",\n          uniforms: cloneUniforms(ShaderLib.background.uniforms),\n          vertexShader: ShaderLib.background.vertexShader,\n          fragmentShader: ShaderLib.background.fragmentShader,\n          side: FrontSide,\n          depthTest: false,\n          depthWrite: false,\n          fog: false\n        }));\n        planeMesh.geometry.deleteAttribute(\"normal\");\n        Object.defineProperty(planeMesh.material, \"map\", {\n          get: function() {\n            return this.uniforms.t2D.value;\n          }\n        });\n        objects.update(planeMesh);\n      }\n      planeMesh.material.uniforms.t2D.value = background;\n      if (background.matrixAutoUpdate === true) {\n        background.updateMatrix();\n      }\n      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);\n      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {\n        planeMesh.material.needsUpdate = true;\n        currentBackground = background;\n        currentBackgroundVersion = background.version;\n        currentTonemapping = renderer.toneMapping;\n      }\n      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);\n    }\n  }\n  function setClear(color, alpha) {\n    state.buffers.color.setClear(color.r, color.g, color.b, alpha, premultipliedAlpha);\n  }\n  return {\n    getClearColor: function() {\n      return clearColor;\n    },\n    setClearColor: function(color, alpha = 1) {\n      clearColor.set(color);\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    getClearAlpha: function() {\n      return clearAlpha;\n    },\n    setClearAlpha: function(alpha) {\n      clearAlpha = alpha;\n      setClear(clearColor, clearAlpha);\n    },\n    render\n  };\n}\nfunction WebGLBindingStates(gl, extensions, attributes, capabilities) {\n  const maxVertexAttributes = gl.getParameter(34921);\n  const extension = capabilities.isWebGL2 ? null : extensions.get(\"OES_vertex_array_object\");\n  const vaoAvailable = capabilities.isWebGL2 || extension !== null;\n  const bindingStates = {};\n  const defaultState = createBindingState(null);\n  let currentState = defaultState;\n  function setup(object, material, program, geometry, index) {\n    let updateBuffers = false;\n    if (vaoAvailable) {\n      const state = getBindingState(geometry, program, material);\n      if (currentState !== state) {\n        currentState = state;\n        bindVertexArrayObject(currentState.object);\n      }\n      updateBuffers = needsUpdate(geometry, index);\n      if (updateBuffers)\n        saveCache(geometry, index);\n    } else {\n      const wireframe = material.wireframe === true;\n      if (currentState.geometry !== geometry.id || currentState.program !== program.id || currentState.wireframe !== wireframe) {\n        currentState.geometry = geometry.id;\n        currentState.program = program.id;\n        currentState.wireframe = wireframe;\n        updateBuffers = true;\n      }\n    }\n    if (object.isInstancedMesh === true) {\n      updateBuffers = true;\n    }\n    if (index !== null) {\n      attributes.update(index, 34963);\n    }\n    if (updateBuffers) {\n      setupVertexAttributes(object, material, program, geometry);\n      if (index !== null) {\n        gl.bindBuffer(34963, attributes.get(index).buffer);\n      }\n    }\n  }\n  function createVertexArrayObject() {\n    if (capabilities.isWebGL2)\n      return gl.createVertexArray();\n    return extension.createVertexArrayOES();\n  }\n  function bindVertexArrayObject(vao) {\n    if (capabilities.isWebGL2)\n      return gl.bindVertexArray(vao);\n    return extension.bindVertexArrayOES(vao);\n  }\n  function deleteVertexArrayObject(vao) {\n    if (capabilities.isWebGL2)\n      return gl.deleteVertexArray(vao);\n    return extension.deleteVertexArrayOES(vao);\n  }\n  function getBindingState(geometry, program, material) {\n    const wireframe = material.wireframe === true;\n    let programMap = bindingStates[geometry.id];\n    if (programMap === void 0) {\n      programMap = {};\n      bindingStates[geometry.id] = programMap;\n    }\n    let stateMap = programMap[program.id];\n    if (stateMap === void 0) {\n      stateMap = {};\n      programMap[program.id] = stateMap;\n    }\n    let state = stateMap[wireframe];\n    if (state === void 0) {\n      state = createBindingState(createVertexArrayObject());\n      stateMap[wireframe] = state;\n    }\n    return state;\n  }\n  function createBindingState(vao) {\n    const newAttributes = [];\n    const enabledAttributes = [];\n    const attributeDivisors = [];\n    for (let i = 0; i < maxVertexAttributes; i++) {\n      newAttributes[i] = 0;\n      enabledAttributes[i] = 0;\n      attributeDivisors[i] = 0;\n    }\n    return {\n      geometry: null,\n      program: null,\n      wireframe: false,\n      newAttributes,\n      enabledAttributes,\n      attributeDivisors,\n      object: vao,\n      attributes: {},\n      index: null\n    };\n  }\n  function needsUpdate(geometry, index) {\n    const cachedAttributes = currentState.attributes;\n    const geometryAttributes = geometry.attributes;\n    let attributesNum = 0;\n    for (const key in geometryAttributes) {\n      const cachedAttribute = cachedAttributes[key];\n      const geometryAttribute = geometryAttributes[key];\n      if (cachedAttribute === void 0)\n        return true;\n      if (cachedAttribute.attribute !== geometryAttribute)\n        return true;\n      if (cachedAttribute.data !== geometryAttribute.data)\n        return true;\n      attributesNum++;\n    }\n    if (currentState.attributesNum !== attributesNum)\n      return true;\n    if (currentState.index !== index)\n      return true;\n    return false;\n  }\n  function saveCache(geometry, index) {\n    const cache = {};\n    const attributes2 = geometry.attributes;\n    let attributesNum = 0;\n    for (const key in attributes2) {\n      const attribute = attributes2[key];\n      const data = {};\n      data.attribute = attribute;\n      if (attribute.data) {\n        data.data = attribute.data;\n      }\n      cache[key] = data;\n      attributesNum++;\n    }\n    currentState.attributes = cache;\n    currentState.attributesNum = attributesNum;\n    currentState.index = index;\n  }\n  function initAttributes() {\n    const newAttributes = currentState.newAttributes;\n    for (let i = 0, il = newAttributes.length; i < il; i++) {\n      newAttributes[i] = 0;\n    }\n  }\n  function enableAttribute(attribute) {\n    enableAttributeAndDivisor(attribute, 0);\n  }\n  function enableAttributeAndDivisor(attribute, meshPerAttribute) {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    const attributeDivisors = currentState.attributeDivisors;\n    newAttributes[attribute] = 1;\n    if (enabledAttributes[attribute] === 0) {\n      gl.enableVertexAttribArray(attribute);\n      enabledAttributes[attribute] = 1;\n    }\n    if (attributeDivisors[attribute] !== meshPerAttribute) {\n      const extension2 = capabilities.isWebGL2 ? gl : extensions.get(\"ANGLE_instanced_arrays\");\n      extension2[capabilities.isWebGL2 ? \"vertexAttribDivisor\" : \"vertexAttribDivisorANGLE\"](attribute, meshPerAttribute);\n      attributeDivisors[attribute] = meshPerAttribute;\n    }\n  }\n  function disableUnusedAttributes() {\n    const newAttributes = currentState.newAttributes;\n    const enabledAttributes = currentState.enabledAttributes;\n    for (let i = 0, il = enabledAttributes.length; i < il; i++) {\n      if (enabledAttributes[i] !== newAttributes[i]) {\n        gl.disableVertexAttribArray(i);\n        enabledAttributes[i] = 0;\n      }\n    }\n  }\n  function vertexAttribPointer(index, size, type, normalized, stride, offset) {\n    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {\n      gl.vertexAttribIPointer(index, size, type, stride, offset);\n    } else {\n      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);\n    }\n  }\n  function setupVertexAttributes(object, material, program, geometry) {\n    if (capabilities.isWebGL2 === false && (object.isInstancedMesh || geometry.isInstancedBufferGeometry)) {\n      if (extensions.get(\"ANGLE_instanced_arrays\") === null)\n        return;\n    }\n    initAttributes();\n    const geometryAttributes = geometry.attributes;\n    const programAttributes = program.getAttributes();\n    const materialDefaultAttributeValues = material.defaultAttributeValues;\n    for (const name in programAttributes) {\n      const programAttribute = programAttributes[name];\n      if (programAttribute >= 0) {\n        const geometryAttribute = geometryAttributes[name];\n        if (geometryAttribute !== void 0) {\n          const normalized = geometryAttribute.normalized;\n          const size = geometryAttribute.itemSize;\n          const attribute = attributes.get(geometryAttribute);\n          if (attribute === void 0)\n            continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          const bytesPerElement = attribute.bytesPerElement;\n          if (geometryAttribute.isInterleavedBufferAttribute) {\n            const data = geometryAttribute.data;\n            const stride = data.stride;\n            const offset = geometryAttribute.offset;\n            if (data && data.isInstancedInterleavedBuffer) {\n              enableAttributeAndDivisor(programAttribute, data.meshPerAttribute);\n              if (geometry._maxInstanceCount === void 0) {\n                geometry._maxInstanceCount = data.meshPerAttribute * data.count;\n              }\n            } else {\n              enableAttribute(programAttribute);\n            }\n            gl.bindBuffer(34962, buffer);\n            vertexAttribPointer(programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement);\n          } else {\n            if (geometryAttribute.isInstancedBufferAttribute) {\n              enableAttributeAndDivisor(programAttribute, geometryAttribute.meshPerAttribute);\n              if (geometry._maxInstanceCount === void 0) {\n                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\n              }\n            } else {\n              enableAttribute(programAttribute);\n            }\n            gl.bindBuffer(34962, buffer);\n            vertexAttribPointer(programAttribute, size, type, normalized, 0, 0);\n          }\n        } else if (name === \"instanceMatrix\") {\n          const attribute = attributes.get(object.instanceMatrix);\n          if (attribute === void 0)\n            continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          enableAttributeAndDivisor(programAttribute + 0, 1);\n          enableAttributeAndDivisor(programAttribute + 1, 1);\n          enableAttributeAndDivisor(programAttribute + 2, 1);\n          enableAttributeAndDivisor(programAttribute + 3, 1);\n          gl.bindBuffer(34962, buffer);\n          gl.vertexAttribPointer(programAttribute + 0, 4, type, false, 64, 0);\n          gl.vertexAttribPointer(programAttribute + 1, 4, type, false, 64, 16);\n          gl.vertexAttribPointer(programAttribute + 2, 4, type, false, 64, 32);\n          gl.vertexAttribPointer(programAttribute + 3, 4, type, false, 64, 48);\n        } else if (name === \"instanceColor\") {\n          const attribute = attributes.get(object.instanceColor);\n          if (attribute === void 0)\n            continue;\n          const buffer = attribute.buffer;\n          const type = attribute.type;\n          enableAttributeAndDivisor(programAttribute, 1);\n          gl.bindBuffer(34962, buffer);\n          gl.vertexAttribPointer(programAttribute, 3, type, false, 12, 0);\n        } else if (materialDefaultAttributeValues !== void 0) {\n          const value = materialDefaultAttributeValues[name];\n          if (value !== void 0) {\n            switch (value.length) {\n              case 2:\n                gl.vertexAttrib2fv(programAttribute, value);\n                break;\n              case 3:\n                gl.vertexAttrib3fv(programAttribute, value);\n                break;\n              case 4:\n                gl.vertexAttrib4fv(programAttribute, value);\n                break;\n              default:\n                gl.vertexAttrib1fv(programAttribute, value);\n            }\n          }\n        }\n      }\n    }\n    disableUnusedAttributes();\n  }\n  function dispose() {\n    reset();\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      for (const programId in programMap) {\n        const stateMap = programMap[programId];\n        for (const wireframe in stateMap) {\n          deleteVertexArrayObject(stateMap[wireframe].object);\n          delete stateMap[wireframe];\n        }\n        delete programMap[programId];\n      }\n      delete bindingStates[geometryId];\n    }\n  }\n  function releaseStatesOfGeometry(geometry) {\n    if (bindingStates[geometry.id] === void 0)\n      return;\n    const programMap = bindingStates[geometry.id];\n    for (const programId in programMap) {\n      const stateMap = programMap[programId];\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n      delete programMap[programId];\n    }\n    delete bindingStates[geometry.id];\n  }\n  function releaseStatesOfProgram(program) {\n    for (const geometryId in bindingStates) {\n      const programMap = bindingStates[geometryId];\n      if (programMap[program.id] === void 0)\n        continue;\n      const stateMap = programMap[program.id];\n      for (const wireframe in stateMap) {\n        deleteVertexArrayObject(stateMap[wireframe].object);\n        delete stateMap[wireframe];\n      }\n      delete programMap[program.id];\n    }\n  }\n  function reset() {\n    resetDefaultState();\n    if (currentState === defaultState)\n      return;\n    currentState = defaultState;\n    bindVertexArrayObject(currentState.object);\n  }\n  function resetDefaultState() {\n    defaultState.geometry = null;\n    defaultState.program = null;\n    defaultState.wireframe = false;\n  }\n  return {\n    setup,\n    reset,\n    resetDefaultState,\n    dispose,\n    releaseStatesOfGeometry,\n    releaseStatesOfProgram,\n    initAttributes,\n    enableAttribute,\n    disableUnusedAttributes\n  };\n}\nfunction WebGLBufferRenderer(gl, extensions, info, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  let mode;\n  function setMode(value) {\n    mode = value;\n  }\n  function render(start, count) {\n    gl.drawArrays(mode, start, count);\n    info.update(count, mode, 1);\n  }\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0)\n      return;\n    let extension, methodName;\n    if (isWebGL2) {\n      extension = gl;\n      methodName = \"drawArraysInstanced\";\n    } else {\n      extension = extensions.get(\"ANGLE_instanced_arrays\");\n      methodName = \"drawArraysInstancedANGLE\";\n      if (extension === null) {\n        console.error(\"THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");\n        return;\n      }\n    }\n    extension[methodName](mode, start, count, primcount);\n    info.update(count, mode, primcount);\n  }\n  this.setMode = setMode;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\nfunction WebGLCapabilities(gl, extensions, parameters) {\n  let maxAnisotropy;\n  function getMaxAnisotropy() {\n    if (maxAnisotropy !== void 0)\n      return maxAnisotropy;\n    if (extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      const extension = extensions.get(\"EXT_texture_filter_anisotropic\");\n      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);\n    } else {\n      maxAnisotropy = 0;\n    }\n    return maxAnisotropy;\n  }\n  function getMaxPrecision(precision2) {\n    if (precision2 === \"highp\") {\n      if (gl.getShaderPrecisionFormat(35633, 36338).precision > 0 && gl.getShaderPrecisionFormat(35632, 36338).precision > 0) {\n        return \"highp\";\n      }\n      precision2 = \"mediump\";\n    }\n    if (precision2 === \"mediump\") {\n      if (gl.getShaderPrecisionFormat(35633, 36337).precision > 0 && gl.getShaderPrecisionFormat(35632, 36337).precision > 0) {\n        return \"mediump\";\n      }\n    }\n    return \"lowp\";\n  }\n  const isWebGL2 = typeof WebGL2RenderingContext !== \"undefined\" && gl instanceof WebGL2RenderingContext || typeof WebGL2ComputeRenderingContext !== \"undefined\" && gl instanceof WebGL2ComputeRenderingContext;\n  let precision = parameters.precision !== void 0 ? parameters.precision : \"highp\";\n  const maxPrecision = getMaxPrecision(precision);\n  if (maxPrecision !== precision) {\n    console.warn(\"THREE.WebGLRenderer:\", precision, \"not supported, using\", maxPrecision, \"instead.\");\n    precision = maxPrecision;\n  }\n  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;\n  const maxTextures = gl.getParameter(34930);\n  const maxVertexTextures = gl.getParameter(35660);\n  const maxTextureSize = gl.getParameter(3379);\n  const maxCubemapSize = gl.getParameter(34076);\n  const maxAttributes = gl.getParameter(34921);\n  const maxVertexUniforms = gl.getParameter(36347);\n  const maxVaryings = gl.getParameter(36348);\n  const maxFragmentUniforms = gl.getParameter(36349);\n  const vertexTextures = maxVertexTextures > 0;\n  const floatFragmentTextures = isWebGL2 || extensions.has(\"OES_texture_float\");\n  const floatVertexTextures = vertexTextures && floatFragmentTextures;\n  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0;\n  return {\n    isWebGL2,\n    getMaxAnisotropy,\n    getMaxPrecision,\n    precision,\n    logarithmicDepthBuffer,\n    maxTextures,\n    maxVertexTextures,\n    maxTextureSize,\n    maxCubemapSize,\n    maxAttributes,\n    maxVertexUniforms,\n    maxVaryings,\n    maxFragmentUniforms,\n    vertexTextures,\n    floatFragmentTextures,\n    floatVertexTextures,\n    maxSamples\n  };\n}\nfunction WebGLClipping(properties) {\n  const scope = this;\n  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;\n  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = {value: null, needsUpdate: false};\n  this.uniform = uniform;\n  this.numPlanes = 0;\n  this.numIntersection = 0;\n  this.init = function(planes, enableLocalClipping, camera) {\n    const enabled = planes.length !== 0 || enableLocalClipping || numGlobalPlanes !== 0 || localClippingEnabled;\n    localClippingEnabled = enableLocalClipping;\n    globalState = projectPlanes(planes, camera, 0);\n    numGlobalPlanes = planes.length;\n    return enabled;\n  };\n  this.beginShadows = function() {\n    renderingShadows = true;\n    projectPlanes(null);\n  };\n  this.endShadows = function() {\n    renderingShadows = false;\n    resetGlobalState();\n  };\n  this.setState = function(material, camera, useCache) {\n    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;\n    const materialProperties = properties.get(material);\n    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {\n      if (renderingShadows) {\n        projectPlanes(null);\n      } else {\n        resetGlobalState();\n      }\n    } else {\n      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;\n      let dstArray = materialProperties.clippingState || null;\n      uniform.value = dstArray;\n      dstArray = projectPlanes(planes, camera, lGlobal, useCache);\n      for (let i = 0; i !== lGlobal; ++i) {\n        dstArray[i] = globalState[i];\n      }\n      materialProperties.clippingState = dstArray;\n      this.numIntersection = clipIntersection ? this.numPlanes : 0;\n      this.numPlanes += nGlobal;\n    }\n  };\n  function resetGlobalState() {\n    if (uniform.value !== globalState) {\n      uniform.value = globalState;\n      uniform.needsUpdate = numGlobalPlanes > 0;\n    }\n    scope.numPlanes = numGlobalPlanes;\n    scope.numIntersection = 0;\n  }\n  function projectPlanes(planes, camera, dstOffset, skipTransform) {\n    const nPlanes = planes !== null ? planes.length : 0;\n    let dstArray = null;\n    if (nPlanes !== 0) {\n      dstArray = uniform.value;\n      if (skipTransform !== true || dstArray === null) {\n        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;\n        viewNormalMatrix.getNormalMatrix(viewMatrix);\n        if (dstArray === null || dstArray.length < flatSize) {\n          dstArray = new Float32Array(flatSize);\n        }\n        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {\n          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix);\n          plane.normal.toArray(dstArray, i4);\n          dstArray[i4 + 3] = plane.constant;\n        }\n      }\n      uniform.value = dstArray;\n      uniform.needsUpdate = true;\n    }\n    scope.numPlanes = nPlanes;\n    scope.numIntersection = 0;\n    return dstArray;\n  }\n}\nfunction WebGLCubeMaps(renderer) {\n  let cubemaps = new WeakMap();\n  function mapTextureMapping(texture, mapping) {\n    if (mapping === EquirectangularReflectionMapping) {\n      texture.mapping = CubeReflectionMapping;\n    } else if (mapping === EquirectangularRefractionMapping) {\n      texture.mapping = CubeRefractionMapping;\n    }\n    return texture;\n  }\n  function get(texture) {\n    if (texture && texture.isTexture) {\n      const mapping = texture.mapping;\n      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {\n        if (cubemaps.has(texture)) {\n          const cubemap = cubemaps.get(texture).texture;\n          return mapTextureMapping(cubemap, texture.mapping);\n        } else {\n          const image = texture.image;\n          if (image && image.height > 0) {\n            const currentRenderTarget = renderer.getRenderTarget();\n            const renderTarget = new WebGLCubeRenderTarget(image.height / 2);\n            renderTarget.fromEquirectangularTexture(renderer, texture);\n            cubemaps.set(texture, renderTarget);\n            renderer.setRenderTarget(currentRenderTarget);\n            texture.addEventListener(\"dispose\", onTextureDispose);\n            return mapTextureMapping(renderTarget.texture, texture.mapping);\n          } else {\n            return null;\n          }\n        }\n      }\n    }\n    return texture;\n  }\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener(\"dispose\", onTextureDispose);\n    const cubemap = cubemaps.get(texture);\n    if (cubemap !== void 0) {\n      cubemaps.delete(texture);\n      cubemap.dispose();\n    }\n  }\n  function dispose() {\n    cubemaps = new WeakMap();\n  }\n  return {\n    get,\n    dispose\n  };\n}\nfunction WebGLExtensions(gl) {\n  const extensions = {};\n  function getExtension(name) {\n    if (extensions[name] !== void 0) {\n      return extensions[name];\n    }\n    let extension;\n    switch (name) {\n      case \"WEBGL_depth_texture\":\n        extension = gl.getExtension(\"WEBGL_depth_texture\") || gl.getExtension(\"MOZ_WEBGL_depth_texture\") || gl.getExtension(\"WEBKIT_WEBGL_depth_texture\");\n        break;\n      case \"EXT_texture_filter_anisotropic\":\n        extension = gl.getExtension(\"EXT_texture_filter_anisotropic\") || gl.getExtension(\"MOZ_EXT_texture_filter_anisotropic\") || gl.getExtension(\"WEBKIT_EXT_texture_filter_anisotropic\");\n        break;\n      case \"WEBGL_compressed_texture_s3tc\":\n        extension = gl.getExtension(\"WEBGL_compressed_texture_s3tc\") || gl.getExtension(\"MOZ_WEBGL_compressed_texture_s3tc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_s3tc\");\n        break;\n      case \"WEBGL_compressed_texture_pvrtc\":\n        extension = gl.getExtension(\"WEBGL_compressed_texture_pvrtc\") || gl.getExtension(\"WEBKIT_WEBGL_compressed_texture_pvrtc\");\n        break;\n      default:\n        extension = gl.getExtension(name);\n    }\n    extensions[name] = extension;\n    return extension;\n  }\n  return {\n    has: function(name) {\n      return getExtension(name) !== null;\n    },\n    init: function(capabilities) {\n      if (capabilities.isWebGL2) {\n        getExtension(\"EXT_color_buffer_float\");\n      } else {\n        getExtension(\"WEBGL_depth_texture\");\n        getExtension(\"OES_texture_float\");\n        getExtension(\"OES_texture_half_float\");\n        getExtension(\"OES_texture_half_float_linear\");\n        getExtension(\"OES_standard_derivatives\");\n        getExtension(\"OES_element_index_uint\");\n        getExtension(\"OES_vertex_array_object\");\n        getExtension(\"ANGLE_instanced_arrays\");\n      }\n      getExtension(\"OES_texture_float_linear\");\n      getExtension(\"EXT_color_buffer_half_float\");\n    },\n    get: function(name) {\n      const extension = getExtension(name);\n      if (extension === null) {\n        console.warn(\"THREE.WebGLRenderer: \" + name + \" extension not supported.\");\n      }\n      return extension;\n    }\n  };\n}\nfunction WebGLGeometries(gl, attributes, info, bindingStates) {\n  const geometries = {};\n  const wireframeAttributes = new WeakMap();\n  function onGeometryDispose(event) {\n    const geometry = event.target;\n    if (geometry.index !== null) {\n      attributes.remove(geometry.index);\n    }\n    for (const name in geometry.attributes) {\n      attributes.remove(geometry.attributes[name]);\n    }\n    geometry.removeEventListener(\"dispose\", onGeometryDispose);\n    delete geometries[geometry.id];\n    const attribute = wireframeAttributes.get(geometry);\n    if (attribute) {\n      attributes.remove(attribute);\n      wireframeAttributes.delete(geometry);\n    }\n    bindingStates.releaseStatesOfGeometry(geometry);\n    if (geometry.isInstancedBufferGeometry === true) {\n      delete geometry._maxInstanceCount;\n    }\n    info.memory.geometries--;\n  }\n  function get(object, geometry) {\n    if (geometries[geometry.id] === true)\n      return geometry;\n    geometry.addEventListener(\"dispose\", onGeometryDispose);\n    geometries[geometry.id] = true;\n    info.memory.geometries++;\n    return geometry;\n  }\n  function update(geometry) {\n    const geometryAttributes = geometry.attributes;\n    for (const name in geometryAttributes) {\n      attributes.update(geometryAttributes[name], 34962);\n    }\n    const morphAttributes = geometry.morphAttributes;\n    for (const name in morphAttributes) {\n      const array = morphAttributes[name];\n      for (let i = 0, l = array.length; i < l; i++) {\n        attributes.update(array[i], 34962);\n      }\n    }\n  }\n  function updateWireframeAttribute(geometry) {\n    const indices = [];\n    const geometryIndex = geometry.index;\n    const geometryPosition = geometry.attributes.position;\n    let version = 0;\n    if (geometryIndex !== null) {\n      const array = geometryIndex.array;\n      version = geometryIndex.version;\n      for (let i = 0, l = array.length; i < l; i += 3) {\n        const a = array[i + 0];\n        const b = array[i + 1];\n        const c = array[i + 2];\n        indices.push(a, b, b, c, c, a);\n      }\n    } else {\n      const array = geometryPosition.array;\n      version = geometryPosition.version;\n      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {\n        const a = i + 0;\n        const b = i + 1;\n        const c = i + 2;\n        indices.push(a, b, b, c, c, a);\n      }\n    }\n    const attribute = new (arrayMax(indices) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);\n    attribute.version = version;\n    const previousAttribute = wireframeAttributes.get(geometry);\n    if (previousAttribute)\n      attributes.remove(previousAttribute);\n    wireframeAttributes.set(geometry, attribute);\n  }\n  function getWireframeAttribute(geometry) {\n    const currentAttribute = wireframeAttributes.get(geometry);\n    if (currentAttribute) {\n      const geometryIndex = geometry.index;\n      if (geometryIndex !== null) {\n        if (currentAttribute.version < geometryIndex.version) {\n          updateWireframeAttribute(geometry);\n        }\n      }\n    } else {\n      updateWireframeAttribute(geometry);\n    }\n    return wireframeAttributes.get(geometry);\n  }\n  return {\n    get,\n    update,\n    getWireframeAttribute\n  };\n}\nfunction WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  let mode;\n  function setMode(value) {\n    mode = value;\n  }\n  let type, bytesPerElement;\n  function setIndex(value) {\n    type = value.type;\n    bytesPerElement = value.bytesPerElement;\n  }\n  function render(start, count) {\n    gl.drawElements(mode, count, type, start * bytesPerElement);\n    info.update(count, mode, 1);\n  }\n  function renderInstances(start, count, primcount) {\n    if (primcount === 0)\n      return;\n    let extension, methodName;\n    if (isWebGL2) {\n      extension = gl;\n      methodName = \"drawElementsInstanced\";\n    } else {\n      extension = extensions.get(\"ANGLE_instanced_arrays\");\n      methodName = \"drawElementsInstancedANGLE\";\n      if (extension === null) {\n        console.error(\"THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.\");\n        return;\n      }\n    }\n    extension[methodName](mode, count, type, start * bytesPerElement, primcount);\n    info.update(count, mode, primcount);\n  }\n  this.setMode = setMode;\n  this.setIndex = setIndex;\n  this.render = render;\n  this.renderInstances = renderInstances;\n}\nfunction WebGLInfo(gl) {\n  const memory = {\n    geometries: 0,\n    textures: 0\n  };\n  const render = {\n    frame: 0,\n    calls: 0,\n    triangles: 0,\n    points: 0,\n    lines: 0\n  };\n  function update(count, mode, instanceCount) {\n    render.calls++;\n    switch (mode) {\n      case 4:\n        render.triangles += instanceCount * (count / 3);\n        break;\n      case 1:\n        render.lines += instanceCount * (count / 2);\n        break;\n      case 3:\n        render.lines += instanceCount * (count - 1);\n        break;\n      case 2:\n        render.lines += instanceCount * count;\n        break;\n      case 0:\n        render.points += instanceCount * count;\n        break;\n      default:\n        console.error(\"THREE.WebGLInfo: Unknown draw mode:\", mode);\n        break;\n    }\n  }\n  function reset() {\n    render.frame++;\n    render.calls = 0;\n    render.triangles = 0;\n    render.points = 0;\n    render.lines = 0;\n  }\n  return {\n    memory,\n    render,\n    programs: null,\n    autoReset: true,\n    reset,\n    update\n  };\n}\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\nfunction WebGLMorphtargets(gl) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const workInfluences = [];\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences;\n    const length = objectInfluences === void 0 ? 0 : objectInfluences.length;\n    let influences = influencesList[geometry.id];\n    if (influences === void 0) {\n      influences = [];\n      for (let i = 0; i < length; i++) {\n        influences[i] = [i, 0];\n      }\n      influencesList[geometry.id] = influences;\n    }\n    for (let i = 0; i < length; i++) {\n      const influence = influences[i];\n      influence[0] = i;\n      influence[1] = objectInfluences[i];\n    }\n    influences.sort(absNumericalSort);\n    for (let i = 0; i < 8; i++) {\n      if (i < length && influences[i][1]) {\n        workInfluences[i][0] = influences[i][0];\n        workInfluences[i][1] = influences[i][1];\n      } else {\n        workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n        workInfluences[i][1] = 0;\n      }\n    }\n    workInfluences.sort(numericalSort);\n    const morphTargets = material.morphTargets && geometry.morphAttributes.position;\n    const morphNormals = material.morphNormals && geometry.morphAttributes.normal;\n    let morphInfluencesSum = 0;\n    for (let i = 0; i < 8; i++) {\n      const influence = workInfluences[i];\n      const index = influence[0];\n      const value = influence[1];\n      if (index !== Number.MAX_SAFE_INTEGER && value) {\n        if (morphTargets && geometry.getAttribute(\"morphTarget\" + i) !== morphTargets[index]) {\n          geometry.setAttribute(\"morphTarget\" + i, morphTargets[index]);\n        }\n        if (morphNormals && geometry.getAttribute(\"morphNormal\" + i) !== morphNormals[index]) {\n          geometry.setAttribute(\"morphNormal\" + i, morphNormals[index]);\n        }\n        morphInfluences[i] = value;\n        morphInfluencesSum += value;\n      } else {\n        if (morphTargets && geometry.hasAttribute(\"morphTarget\" + i) === true) {\n          geometry.deleteAttribute(\"morphTarget\" + i);\n        }\n        if (morphNormals && geometry.hasAttribute(\"morphNormal\" + i) === true) {\n          geometry.deleteAttribute(\"morphNormal\" + i);\n        }\n        morphInfluences[i] = 0;\n      }\n    }\n    const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n    program.getUniforms().setValue(gl, \"morphTargetBaseInfluence\", morphBaseInfluence);\n    program.getUniforms().setValue(gl, \"morphTargetInfluences\", morphInfluences);\n  }\n  return {\n    update\n  };\n}\nfunction WebGLObjects(gl, geometries, attributes, info) {\n  let updateMap = new WeakMap();\n  function update(object) {\n    const frame = info.render.frame;\n    const geometry = object.geometry;\n    const buffergeometry = geometries.get(object, geometry);\n    if (updateMap.get(buffergeometry) !== frame) {\n      geometries.update(buffergeometry);\n      updateMap.set(buffergeometry, frame);\n    }\n    if (object.isInstancedMesh) {\n      if (object.hasEventListener(\"dispose\", onInstancedMeshDispose) === false) {\n        object.addEventListener(\"dispose\", onInstancedMeshDispose);\n      }\n      attributes.update(object.instanceMatrix, 34962);\n      if (object.instanceColor !== null) {\n        attributes.update(object.instanceColor, 34962);\n      }\n    }\n    return buffergeometry;\n  }\n  function dispose() {\n    updateMap = new WeakMap();\n  }\n  function onInstancedMeshDispose(event) {\n    const instancedMesh = event.target;\n    instancedMesh.removeEventListener(\"dispose\", onInstancedMeshDispose);\n    attributes.remove(instancedMesh.instanceMatrix);\n    if (instancedMesh.instanceColor !== null)\n      attributes.remove(instancedMesh.instanceColor);\n  }\n  return {\n    update,\n    dispose\n  };\n}\nclass DataTexture2DArray extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n    this.image = {data, width, height, depth};\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n  }\n}\nDataTexture2DArray.prototype.isDataTexture2DArray = true;\nclass DataTexture3D extends Texture {\n  constructor(data = null, width = 1, height = 1, depth = 1) {\n    super(null);\n    this.image = {data, width, height, depth};\n    this.magFilter = NearestFilter;\n    this.minFilter = NearestFilter;\n    this.wrapR = ClampToEdgeWrapping;\n    this.generateMipmaps = false;\n    this.flipY = false;\n    this.unpackAlignment = 1;\n    this.needsUpdate = true;\n  }\n}\nDataTexture3D.prototype.isDataTexture3D = true;\nconst emptyTexture = new Texture();\nconst emptyTexture2dArray = new DataTexture2DArray();\nconst emptyTexture3d = new DataTexture3D();\nconst emptyCubeTexture = new CubeTexture();\nconst arrayCacheF32 = [];\nconst arrayCacheI32 = [];\nconst mat4array = new Float32Array(16);\nconst mat3array = new Float32Array(9);\nconst mat2array = new Float32Array(4);\nfunction flatten(array, nBlocks, blockSize) {\n  const firstElem = array[0];\n  if (firstElem <= 0 || firstElem > 0)\n    return array;\n  const n = nBlocks * blockSize;\n  let r = arrayCacheF32[n];\n  if (r === void 0) {\n    r = new Float32Array(n);\n    arrayCacheF32[n] = r;\n  }\n  if (nBlocks !== 0) {\n    firstElem.toArray(r, 0);\n    for (let i = 1, offset = 0; i !== nBlocks; ++i) {\n      offset += blockSize;\n      array[i].toArray(r, offset);\n    }\n  }\n  return r;\n}\nfunction arraysEqual(a, b) {\n  if (a.length !== b.length)\n    return false;\n  for (let i = 0, l = a.length; i < l; i++) {\n    if (a[i] !== b[i])\n      return false;\n  }\n  return true;\n}\nfunction copyArray(a, b) {\n  for (let i = 0, l = b.length; i < l; i++) {\n    a[i] = b[i];\n  }\n}\nfunction allocTexUnits(textures, n) {\n  let r = arrayCacheI32[n];\n  if (r === void 0) {\n    r = new Int32Array(n);\n    arrayCacheI32[n] = r;\n  }\n  for (let i = 0; i !== n; ++i) {\n    r[i] = textures.allocateTextureUnit();\n  }\n  return r;\n}\nfunction setValueV1f(gl, v) {\n  const cache = this.cache;\n  if (cache[0] === v)\n    return;\n  gl.uniform1f(this.addr, v);\n  cache[0] = v;\n}\nfunction setValueV2f(gl, v) {\n  const cache = this.cache;\n  if (v.x !== void 0) {\n    if (cache[0] !== v.x || cache[1] !== v.y) {\n      gl.uniform2f(this.addr, v.x, v.y);\n      cache[0] = v.x;\n      cache[1] = v.y;\n    }\n  } else {\n    if (arraysEqual(cache, v))\n      return;\n    gl.uniform2fv(this.addr, v);\n    copyArray(cache, v);\n  }\n}\nfunction setValueV3f(gl, v) {\n  const cache = this.cache;\n  if (v.x !== void 0) {\n    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {\n      gl.uniform3f(this.addr, v.x, v.y, v.z);\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n    }\n  } else if (v.r !== void 0) {\n    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {\n      gl.uniform3f(this.addr, v.r, v.g, v.b);\n      cache[0] = v.r;\n      cache[1] = v.g;\n      cache[2] = v.b;\n    }\n  } else {\n    if (arraysEqual(cache, v))\n      return;\n    gl.uniform3fv(this.addr, v);\n    copyArray(cache, v);\n  }\n}\nfunction setValueV4f(gl, v) {\n  const cache = this.cache;\n  if (v.x !== void 0) {\n    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z || cache[3] !== v.w) {\n      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w);\n      cache[0] = v.x;\n      cache[1] = v.y;\n      cache[2] = v.z;\n      cache[3] = v.w;\n    }\n  } else {\n    if (arraysEqual(cache, v))\n      return;\n    gl.uniform4fv(this.addr, v);\n    copyArray(cache, v);\n  }\n}\nfunction setValueM2(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache, v))\n      return;\n    gl.uniformMatrix2fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements))\n      return;\n    mat2array.set(elements);\n    gl.uniformMatrix2fv(this.addr, false, mat2array);\n    copyArray(cache, elements);\n  }\n}\nfunction setValueM3(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache, v))\n      return;\n    gl.uniformMatrix3fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements))\n      return;\n    mat3array.set(elements);\n    gl.uniformMatrix3fv(this.addr, false, mat3array);\n    copyArray(cache, elements);\n  }\n}\nfunction setValueM4(gl, v) {\n  const cache = this.cache;\n  const elements = v.elements;\n  if (elements === void 0) {\n    if (arraysEqual(cache, v))\n      return;\n    gl.uniformMatrix4fv(this.addr, false, v);\n    copyArray(cache, v);\n  } else {\n    if (arraysEqual(cache, elements))\n      return;\n    mat4array.set(elements);\n    gl.uniformMatrix4fv(this.addr, false, mat4array);\n    copyArray(cache, elements);\n  }\n}\nfunction setValueV1i(gl, v) {\n  const cache = this.cache;\n  if (cache[0] === v)\n    return;\n  gl.uniform1i(this.addr, v);\n  cache[0] = v;\n}\nfunction setValueV2i(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v))\n    return;\n  gl.uniform2iv(this.addr, v);\n  copyArray(cache, v);\n}\nfunction setValueV3i(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v))\n    return;\n  gl.uniform3iv(this.addr, v);\n  copyArray(cache, v);\n}\nfunction setValueV4i(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v))\n    return;\n  gl.uniform4iv(this.addr, v);\n  copyArray(cache, v);\n}\nfunction setValueV1ui(gl, v) {\n  const cache = this.cache;\n  if (cache[0] === v)\n    return;\n  gl.uniform1ui(this.addr, v);\n  cache[0] = v;\n}\nfunction setValueV2ui(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v))\n    return;\n  gl.uniform2uiv(this.addr, v);\n  copyArray(cache, v);\n}\nfunction setValueV3ui(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v))\n    return;\n  gl.uniform3uiv(this.addr, v);\n  copyArray(cache, v);\n}\nfunction setValueV4ui(gl, v) {\n  const cache = this.cache;\n  if (arraysEqual(cache, v))\n    return;\n  gl.uniform4uiv(this.addr, v);\n  copyArray(cache, v);\n}\nfunction setValueT1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n  textures.safeSetTexture2D(v || emptyTexture, unit);\n}\nfunction setValueT3D1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n  textures.setTexture3D(v || emptyTexture3d, unit);\n}\nfunction setValueT6(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n  textures.safeSetTextureCube(v || emptyCubeTexture, unit);\n}\nfunction setValueT2DArray1(gl, v, textures) {\n  const cache = this.cache;\n  const unit = textures.allocateTextureUnit();\n  if (cache[0] !== unit) {\n    gl.uniform1i(this.addr, unit);\n    cache[0] = unit;\n  }\n  textures.setTexture2DArray(v || emptyTexture2dArray, unit);\n}\nfunction getSingularSetter(type) {\n  switch (type) {\n    case 5126:\n      return setValueV1f;\n    case 35664:\n      return setValueV2f;\n    case 35665:\n      return setValueV3f;\n    case 35666:\n      return setValueV4f;\n    case 35674:\n      return setValueM2;\n    case 35675:\n      return setValueM3;\n    case 35676:\n      return setValueM4;\n    case 5124:\n    case 35670:\n      return setValueV1i;\n    case 35667:\n    case 35671:\n      return setValueV2i;\n    case 35668:\n    case 35672:\n      return setValueV3i;\n    case 35669:\n    case 35673:\n      return setValueV4i;\n    case 5125:\n      return setValueV1ui;\n    case 36294:\n      return setValueV2ui;\n    case 36295:\n      return setValueV3ui;\n    case 36296:\n      return setValueV4ui;\n    case 35678:\n    case 36198:\n    case 36298:\n    case 36306:\n    case 35682:\n      return setValueT1;\n    case 35679:\n    case 36299:\n    case 36307:\n      return setValueT3D1;\n    case 35680:\n    case 36300:\n    case 36308:\n    case 36293:\n      return setValueT6;\n    case 36289:\n    case 36303:\n    case 36311:\n    case 36292:\n      return setValueT2DArray1;\n  }\n}\nfunction setValueV1fArray(gl, v) {\n  gl.uniform1fv(this.addr, v);\n}\nfunction setValueV2fArray(gl, v) {\n  const data = flatten(v, this.size, 2);\n  gl.uniform2fv(this.addr, data);\n}\nfunction setValueV3fArray(gl, v) {\n  const data = flatten(v, this.size, 3);\n  gl.uniform3fv(this.addr, data);\n}\nfunction setValueV4fArray(gl, v) {\n  const data = flatten(v, this.size, 4);\n  gl.uniform4fv(this.addr, data);\n}\nfunction setValueM2Array(gl, v) {\n  const data = flatten(v, this.size, 4);\n  gl.uniformMatrix2fv(this.addr, false, data);\n}\nfunction setValueM3Array(gl, v) {\n  const data = flatten(v, this.size, 9);\n  gl.uniformMatrix3fv(this.addr, false, data);\n}\nfunction setValueM4Array(gl, v) {\n  const data = flatten(v, this.size, 16);\n  gl.uniformMatrix4fv(this.addr, false, data);\n}\nfunction setValueV1iArray(gl, v) {\n  gl.uniform1iv(this.addr, v);\n}\nfunction setValueV2iArray(gl, v) {\n  gl.uniform2iv(this.addr, v);\n}\nfunction setValueV3iArray(gl, v) {\n  gl.uniform3iv(this.addr, v);\n}\nfunction setValueV4iArray(gl, v) {\n  gl.uniform4iv(this.addr, v);\n}\nfunction setValueV1uiArray(gl, v) {\n  gl.uniform1uiv(this.addr, v);\n}\nfunction setValueV2uiArray(gl, v) {\n  gl.uniform2uiv(this.addr, v);\n}\nfunction setValueV3uiArray(gl, v) {\n  gl.uniform3uiv(this.addr, v);\n}\nfunction setValueV4uiArray(gl, v) {\n  gl.uniform4uiv(this.addr, v);\n}\nfunction setValueT1Array(gl, v, textures) {\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n  for (let i = 0; i !== n; ++i) {\n    textures.safeSetTexture2D(v[i] || emptyTexture, units[i]);\n  }\n}\nfunction setValueT6Array(gl, v, textures) {\n  const n = v.length;\n  const units = allocTexUnits(textures, n);\n  gl.uniform1iv(this.addr, units);\n  for (let i = 0; i !== n; ++i) {\n    textures.safeSetTextureCube(v[i] || emptyCubeTexture, units[i]);\n  }\n}\nfunction getPureArraySetter(type) {\n  switch (type) {\n    case 5126:\n      return setValueV1fArray;\n    case 35664:\n      return setValueV2fArray;\n    case 35665:\n      return setValueV3fArray;\n    case 35666:\n      return setValueV4fArray;\n    case 35674:\n      return setValueM2Array;\n    case 35675:\n      return setValueM3Array;\n    case 35676:\n      return setValueM4Array;\n    case 5124:\n    case 35670:\n      return setValueV1iArray;\n    case 35667:\n    case 35671:\n      return setValueV2iArray;\n    case 35668:\n    case 35672:\n      return setValueV3iArray;\n    case 35669:\n    case 35673:\n      return setValueV4iArray;\n    case 5125:\n      return setValueV1uiArray;\n    case 36294:\n      return setValueV2uiArray;\n    case 36295:\n      return setValueV3uiArray;\n    case 36296:\n      return setValueV4uiArray;\n    case 35678:\n    case 36198:\n    case 36298:\n    case 36306:\n    case 35682:\n      return setValueT1Array;\n    case 35680:\n    case 36300:\n    case 36308:\n    case 36293:\n      return setValueT6Array;\n  }\n}\nfunction SingleUniform(id, activeInfo, addr) {\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.setValue = getSingularSetter(activeInfo.type);\n}\nfunction PureArrayUniform(id, activeInfo, addr) {\n  this.id = id;\n  this.addr = addr;\n  this.cache = [];\n  this.size = activeInfo.size;\n  this.setValue = getPureArraySetter(activeInfo.type);\n}\nPureArrayUniform.prototype.updateCache = function(data) {\n  const cache = this.cache;\n  if (data instanceof Float32Array && cache.length !== data.length) {\n    this.cache = new Float32Array(data.length);\n  }\n  copyArray(cache, data);\n};\nfunction StructuredUniform(id) {\n  this.id = id;\n  this.seq = [];\n  this.map = {};\n}\nStructuredUniform.prototype.setValue = function(gl, value, textures) {\n  const seq = this.seq;\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i];\n    u.setValue(gl, value[u.id], textures);\n  }\n};\nconst RePathPart = /(\\w+)(\\])?(\\[|\\.)?/g;\nfunction addUniform(container, uniformObject) {\n  container.seq.push(uniformObject);\n  container.map[uniformObject.id] = uniformObject;\n}\nfunction parseUniform(activeInfo, addr, container) {\n  const path = activeInfo.name, pathLength = path.length;\n  RePathPart.lastIndex = 0;\n  while (true) {\n    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;\n    let id = match[1];\n    const idIsIndex = match[2] === \"]\", subscript = match[3];\n    if (idIsIndex)\n      id = id | 0;\n    if (subscript === void 0 || subscript === \"[\" && matchEnd + 2 === pathLength) {\n      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));\n      break;\n    } else {\n      const map = container.map;\n      let next = map[id];\n      if (next === void 0) {\n        next = new StructuredUniform(id);\n        addUniform(container, next);\n      }\n      container = next;\n    }\n  }\n}\nfunction WebGLUniforms(gl, program) {\n  this.seq = [];\n  this.map = {};\n  const n = gl.getProgramParameter(program, 35718);\n  for (let i = 0; i < n; ++i) {\n    const info = gl.getActiveUniform(program, i), addr = gl.getUniformLocation(program, info.name);\n    parseUniform(info, addr, this);\n  }\n}\nWebGLUniforms.prototype.setValue = function(gl, name, value, textures) {\n  const u = this.map[name];\n  if (u !== void 0)\n    u.setValue(gl, value, textures);\n};\nWebGLUniforms.prototype.setOptional = function(gl, object, name) {\n  const v = object[name];\n  if (v !== void 0)\n    this.setValue(gl, name, v);\n};\nWebGLUniforms.upload = function(gl, seq, values, textures) {\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i], v = values[u.id];\n    if (v.needsUpdate !== false) {\n      u.setValue(gl, v.value, textures);\n    }\n  }\n};\nWebGLUniforms.seqWithValue = function(seq, values) {\n  const r = [];\n  for (let i = 0, n = seq.length; i !== n; ++i) {\n    const u = seq[i];\n    if (u.id in values)\n      r.push(u);\n  }\n  return r;\n};\nfunction WebGLShader(gl, type, string) {\n  const shader = gl.createShader(type);\n  gl.shaderSource(shader, string);\n  gl.compileShader(shader);\n  return shader;\n}\nlet programIdCount = 0;\nfunction addLineNumbers(string) {\n  const lines = string.split(\"\\n\");\n  for (let i = 0; i < lines.length; i++) {\n    lines[i] = i + 1 + \": \" + lines[i];\n  }\n  return lines.join(\"\\n\");\n}\nfunction getEncodingComponents(encoding) {\n  switch (encoding) {\n    case LinearEncoding:\n      return [\"Linear\", \"( value )\"];\n    case sRGBEncoding:\n      return [\"sRGB\", \"( value )\"];\n    case RGBEEncoding:\n      return [\"RGBE\", \"( value )\"];\n    case RGBM7Encoding:\n      return [\"RGBM\", \"( value, 7.0 )\"];\n    case RGBM16Encoding:\n      return [\"RGBM\", \"( value, 16.0 )\"];\n    case RGBDEncoding:\n      return [\"RGBD\", \"( value, 256.0 )\"];\n    case GammaEncoding:\n      return [\"Gamma\", \"( value, float( GAMMA_FACTOR ) )\"];\n    case LogLuvEncoding:\n      return [\"LogLuv\", \"( value )\"];\n    default:\n      console.warn(\"THREE.WebGLProgram: Unsupported encoding:\", encoding);\n      return [\"Linear\", \"( value )\"];\n  }\n}\nfunction getShaderErrors(gl, shader, type) {\n  const status = gl.getShaderParameter(shader, 35713);\n  const log = gl.getShaderInfoLog(shader).trim();\n  if (status && log === \"\")\n    return \"\";\n  const source = gl.getShaderSource(shader);\n  return \"THREE.WebGLShader: gl.getShaderInfoLog() \" + type + \"\\n\" + log + addLineNumbers(source);\n}\nfunction getTexelDecodingFunction(functionName, encoding) {\n  const components = getEncodingComponents(encoding);\n  return \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[0] + \"ToLinear\" + components[1] + \"; }\";\n}\nfunction getTexelEncodingFunction(functionName, encoding) {\n  const components = getEncodingComponents(encoding);\n  return \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[0] + components[1] + \"; }\";\n}\nfunction getToneMappingFunction(functionName, toneMapping) {\n  let toneMappingName;\n  switch (toneMapping) {\n    case LinearToneMapping:\n      toneMappingName = \"Linear\";\n      break;\n    case ReinhardToneMapping:\n      toneMappingName = \"Reinhard\";\n      break;\n    case CineonToneMapping:\n      toneMappingName = \"OptimizedCineon\";\n      break;\n    case ACESFilmicToneMapping:\n      toneMappingName = \"ACESFilmic\";\n      break;\n    case CustomToneMapping:\n      toneMappingName = \"Custom\";\n      break;\n    default:\n      console.warn(\"THREE.WebGLProgram: Unsupported toneMapping:\", toneMapping);\n      toneMappingName = \"Linear\";\n  }\n  return \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\n}\nfunction generateExtensions(parameters) {\n  const chunks = [\n    parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === \"physical\" ? \"#extension GL_OES_standard_derivatives : enable\" : \"\",\n    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) && parameters.rendererExtensionFragDepth ? \"#extension GL_EXT_frag_depth : enable\" : \"\",\n    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ? \"#extension GL_EXT_draw_buffers : require\" : \"\",\n    (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? \"#extension GL_EXT_shader_texture_lod : enable\" : \"\"\n  ];\n  return chunks.filter(filterEmptyLine).join(\"\\n\");\n}\nfunction generateDefines(defines) {\n  const chunks = [];\n  for (const name in defines) {\n    const value = defines[name];\n    if (value === false)\n      continue;\n    chunks.push(\"#define \" + name + \" \" + value);\n  }\n  return chunks.join(\"\\n\");\n}\nfunction fetchAttributeLocations(gl, program) {\n  const attributes = {};\n  const n = gl.getProgramParameter(program, 35721);\n  for (let i = 0; i < n; i++) {\n    const info = gl.getActiveAttrib(program, i);\n    const name = info.name;\n    attributes[name] = gl.getAttribLocation(program, name);\n  }\n  return attributes;\n}\nfunction filterEmptyLine(string) {\n  return string !== \"\";\n}\nfunction replaceLightNums(string, parameters) {\n  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);\n}\nfunction replaceClippingPlaneNums(string, parameters) {\n  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);\n}\nconst includePattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\nfunction resolveIncludes(string) {\n  return string.replace(includePattern, includeReplacer);\n}\nfunction includeReplacer(match, include) {\n  const string = ShaderChunk[include];\n  if (string === void 0) {\n    throw new Error(\"Can not resolve #include <\" + include + \">\");\n  }\n  return resolveIncludes(string);\n}\nconst deprecatedUnrollLoopPattern = /#pragma unroll_loop[\\s]+?for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\nconst unrollLoopPattern = /#pragma unroll_loop_start\\s+for\\s*\\(\\s*int\\s+i\\s*=\\s*(\\d+)\\s*;\\s*i\\s*<\\s*(\\d+)\\s*;\\s*i\\s*\\+\\+\\s*\\)\\s*{([\\s\\S]+?)}\\s+#pragma unroll_loop_end/g;\nfunction unrollLoops(string) {\n  return string.replace(unrollLoopPattern, loopReplacer).replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer);\n}\nfunction deprecatedLoopReplacer(match, start, end, snippet) {\n  console.warn(\"WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.\");\n  return loopReplacer(match, start, end, snippet);\n}\nfunction loopReplacer(match, start, end, snippet) {\n  let string = \"\";\n  for (let i = parseInt(start); i < parseInt(end); i++) {\n    string += snippet.replace(/\\[\\s*i\\s*\\]/g, \"[ \" + i + \" ]\").replace(/UNROLLED_LOOP_INDEX/g, i);\n  }\n  return string;\n}\nfunction generatePrecision(parameters) {\n  let precisionstring = \"precision \" + parameters.precision + \" float;\\nprecision \" + parameters.precision + \" int;\";\n  if (parameters.precision === \"highp\") {\n    precisionstring += \"\\n#define HIGH_PRECISION\";\n  } else if (parameters.precision === \"mediump\") {\n    precisionstring += \"\\n#define MEDIUM_PRECISION\";\n  } else if (parameters.precision === \"lowp\") {\n    precisionstring += \"\\n#define LOW_PRECISION\";\n  }\n  return precisionstring;\n}\nfunction generateShadowMapTypeDefine(parameters) {\n  let shadowMapTypeDefine = \"SHADOWMAP_TYPE_BASIC\";\n  if (parameters.shadowMapType === PCFShadowMap) {\n    shadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF\";\n  } else if (parameters.shadowMapType === PCFSoftShadowMap) {\n    shadowMapTypeDefine = \"SHADOWMAP_TYPE_PCF_SOFT\";\n  } else if (parameters.shadowMapType === VSMShadowMap) {\n    shadowMapTypeDefine = \"SHADOWMAP_TYPE_VSM\";\n  }\n  return shadowMapTypeDefine;\n}\nfunction generateEnvMapTypeDefine(parameters) {\n  let envMapTypeDefine = \"ENVMAP_TYPE_CUBE\";\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeReflectionMapping:\n      case CubeRefractionMapping:\n        envMapTypeDefine = \"ENVMAP_TYPE_CUBE\";\n        break;\n      case CubeUVReflectionMapping:\n      case CubeUVRefractionMapping:\n        envMapTypeDefine = \"ENVMAP_TYPE_CUBE_UV\";\n        break;\n    }\n  }\n  return envMapTypeDefine;\n}\nfunction generateEnvMapModeDefine(parameters) {\n  let envMapModeDefine = \"ENVMAP_MODE_REFLECTION\";\n  if (parameters.envMap) {\n    switch (parameters.envMapMode) {\n      case CubeRefractionMapping:\n      case CubeUVRefractionMapping:\n        envMapModeDefine = \"ENVMAP_MODE_REFRACTION\";\n        break;\n    }\n  }\n  return envMapModeDefine;\n}\nfunction generateEnvMapBlendingDefine(parameters) {\n  let envMapBlendingDefine = \"ENVMAP_BLENDING_NONE\";\n  if (parameters.envMap) {\n    switch (parameters.combine) {\n      case MultiplyOperation:\n        envMapBlendingDefine = \"ENVMAP_BLENDING_MULTIPLY\";\n        break;\n      case MixOperation:\n        envMapBlendingDefine = \"ENVMAP_BLENDING_MIX\";\n        break;\n      case AddOperation:\n        envMapBlendingDefine = \"ENVMAP_BLENDING_ADD\";\n        break;\n    }\n  }\n  return envMapBlendingDefine;\n}\nfunction WebGLProgram(renderer, cacheKey, parameters, bindingStates) {\n  const gl = renderer.getContext();\n  const defines = parameters.defines;\n  let vertexShader = parameters.vertexShader;\n  let fragmentShader = parameters.fragmentShader;\n  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);\n  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);\n  const envMapModeDefine = generateEnvMapModeDefine(parameters);\n  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);\n  const gammaFactorDefine = renderer.gammaFactor > 0 ? renderer.gammaFactor : 1;\n  const customExtensions = parameters.isWebGL2 ? \"\" : generateExtensions(parameters);\n  const customDefines = generateDefines(defines);\n  const program = gl.createProgram();\n  let prefixVertex, prefixFragment;\n  let versionString = parameters.glslVersion ? \"#version \" + parameters.glslVersion + \"\\n\" : \"\";\n  if (parameters.isRawShaderMaterial) {\n    prefixVertex = [\n      customDefines\n    ].filter(filterEmptyLine).join(\"\\n\");\n    if (prefixVertex.length > 0) {\n      prefixVertex += \"\\n\";\n    }\n    prefixFragment = [\n      customExtensions,\n      customDefines\n    ].filter(filterEmptyLine).join(\"\\n\");\n    if (prefixFragment.length > 0) {\n      prefixFragment += \"\\n\";\n    }\n  } else {\n    prefixVertex = [\n      generatePrecision(parameters),\n      \"#define SHADER_NAME \" + parameters.shaderName,\n      customDefines,\n      parameters.instancing ? \"#define USE_INSTANCING\" : \"\",\n      parameters.instancingColor ? \"#define USE_INSTANCING_COLOR\" : \"\",\n      parameters.supportsVertexTextures ? \"#define VERTEX_TEXTURES\" : \"\",\n      \"#define GAMMA_FACTOR \" + gammaFactorDefine,\n      \"#define MAX_BONES \" + parameters.maxBones,\n      parameters.useFog && parameters.fog ? \"#define USE_FOG\" : \"\",\n      parameters.useFog && parameters.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n      parameters.map ? \"#define USE_MAP\" : \"\",\n      parameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n      parameters.envMap ? \"#define \" + envMapModeDefine : \"\",\n      parameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n      parameters.aoMap ? \"#define USE_AOMAP\" : \"\",\n      parameters.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\n      parameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n      parameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n      parameters.normalMap && parameters.objectSpaceNormalMap ? \"#define OBJECTSPACE_NORMALMAP\" : \"\",\n      parameters.normalMap && parameters.tangentSpaceNormalMap ? \"#define TANGENTSPACE_NORMALMAP\" : \"\",\n      parameters.clearcoatMap ? \"#define USE_CLEARCOATMAP\" : \"\",\n      parameters.clearcoatRoughnessMap ? \"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n      parameters.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n      parameters.displacementMap && parameters.supportsVertexTextures ? \"#define USE_DISPLACEMENTMAP\" : \"\",\n      parameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n      parameters.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\n      parameters.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\",\n      parameters.alphaMap ? \"#define USE_ALPHAMAP\" : \"\",\n      parameters.transmissionMap ? \"#define USE_TRANSMISSIONMAP\" : \"\",\n      parameters.vertexTangents ? \"#define USE_TANGENT\" : \"\",\n      parameters.vertexColors ? \"#define USE_COLOR\" : \"\",\n      parameters.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \"\",\n      parameters.vertexUvs ? \"#define USE_UV\" : \"\",\n      parameters.uvsVertexOnly ? \"#define UVS_VERTEX_ONLY\" : \"\",\n      parameters.flatShading ? \"#define FLAT_SHADED\" : \"\",\n      parameters.skinning ? \"#define USE_SKINNING\" : \"\",\n      parameters.useVertexTexture ? \"#define BONE_TEXTURE\" : \"\",\n      parameters.morphTargets ? \"#define USE_MORPHTARGETS\" : \"\",\n      parameters.morphNormals && parameters.flatShading === false ? \"#define USE_MORPHNORMALS\" : \"\",\n      parameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n      parameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n      parameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n      parameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n      parameters.sizeAttenuation ? \"#define USE_SIZEATTENUATION\" : \"\",\n      parameters.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\",\n      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? \"#define USE_LOGDEPTHBUF_EXT\" : \"\",\n      \"uniform mat4 modelMatrix;\",\n      \"uniform mat4 modelViewMatrix;\",\n      \"uniform mat4 projectionMatrix;\",\n      \"uniform mat4 viewMatrix;\",\n      \"uniform mat3 normalMatrix;\",\n      \"uniform vec3 cameraPosition;\",\n      \"uniform bool isOrthographic;\",\n      \"#ifdef USE_INSTANCING\",\n      \"\tattribute mat4 instanceMatrix;\",\n      \"#endif\",\n      \"#ifdef USE_INSTANCING_COLOR\",\n      \"\tattribute vec3 instanceColor;\",\n      \"#endif\",\n      \"attribute vec3 position;\",\n      \"attribute vec3 normal;\",\n      \"attribute vec2 uv;\",\n      \"#ifdef USE_TANGENT\",\n      \"\tattribute vec4 tangent;\",\n      \"#endif\",\n      \"#if defined( USE_COLOR_ALPHA )\",\n      \"\tattribute vec4 color;\",\n      \"#elif defined( USE_COLOR )\",\n      \"\tattribute vec3 color;\",\n      \"#endif\",\n      \"#ifdef USE_MORPHTARGETS\",\n      \"\tattribute vec3 morphTarget0;\",\n      \"\tattribute vec3 morphTarget1;\",\n      \"\tattribute vec3 morphTarget2;\",\n      \"\tattribute vec3 morphTarget3;\",\n      \"\t#ifdef USE_MORPHNORMALS\",\n      \"\t\tattribute vec3 morphNormal0;\",\n      \"\t\tattribute vec3 morphNormal1;\",\n      \"\t\tattribute vec3 morphNormal2;\",\n      \"\t\tattribute vec3 morphNormal3;\",\n      \"\t#else\",\n      \"\t\tattribute vec3 morphTarget4;\",\n      \"\t\tattribute vec3 morphTarget5;\",\n      \"\t\tattribute vec3 morphTarget6;\",\n      \"\t\tattribute vec3 morphTarget7;\",\n      \"\t#endif\",\n      \"#endif\",\n      \"#ifdef USE_SKINNING\",\n      \"\tattribute vec4 skinIndex;\",\n      \"\tattribute vec4 skinWeight;\",\n      \"#endif\",\n      \"\\n\"\n    ].filter(filterEmptyLine).join(\"\\n\");\n    prefixFragment = [\n      customExtensions,\n      generatePrecision(parameters),\n      \"#define SHADER_NAME \" + parameters.shaderName,\n      customDefines,\n      parameters.alphaTest ? \"#define ALPHATEST \" + parameters.alphaTest + (parameters.alphaTest % 1 ? \"\" : \".0\") : \"\",\n      \"#define GAMMA_FACTOR \" + gammaFactorDefine,\n      parameters.useFog && parameters.fog ? \"#define USE_FOG\" : \"\",\n      parameters.useFog && parameters.fogExp2 ? \"#define FOG_EXP2\" : \"\",\n      parameters.map ? \"#define USE_MAP\" : \"\",\n      parameters.matcap ? \"#define USE_MATCAP\" : \"\",\n      parameters.envMap ? \"#define USE_ENVMAP\" : \"\",\n      parameters.envMap ? \"#define \" + envMapTypeDefine : \"\",\n      parameters.envMap ? \"#define \" + envMapModeDefine : \"\",\n      parameters.envMap ? \"#define \" + envMapBlendingDefine : \"\",\n      parameters.lightMap ? \"#define USE_LIGHTMAP\" : \"\",\n      parameters.aoMap ? \"#define USE_AOMAP\" : \"\",\n      parameters.emissiveMap ? \"#define USE_EMISSIVEMAP\" : \"\",\n      parameters.bumpMap ? \"#define USE_BUMPMAP\" : \"\",\n      parameters.normalMap ? \"#define USE_NORMALMAP\" : \"\",\n      parameters.normalMap && parameters.objectSpaceNormalMap ? \"#define OBJECTSPACE_NORMALMAP\" : \"\",\n      parameters.normalMap && parameters.tangentSpaceNormalMap ? \"#define TANGENTSPACE_NORMALMAP\" : \"\",\n      parameters.clearcoatMap ? \"#define USE_CLEARCOATMAP\" : \"\",\n      parameters.clearcoatRoughnessMap ? \"#define USE_CLEARCOAT_ROUGHNESSMAP\" : \"\",\n      parameters.clearcoatNormalMap ? \"#define USE_CLEARCOAT_NORMALMAP\" : \"\",\n      parameters.specularMap ? \"#define USE_SPECULARMAP\" : \"\",\n      parameters.roughnessMap ? \"#define USE_ROUGHNESSMAP\" : \"\",\n      parameters.metalnessMap ? \"#define USE_METALNESSMAP\" : \"\",\n      parameters.alphaMap ? \"#define USE_ALPHAMAP\" : \"\",\n      parameters.sheen ? \"#define USE_SHEEN\" : \"\",\n      parameters.transmissionMap ? \"#define USE_TRANSMISSIONMAP\" : \"\",\n      parameters.vertexTangents ? \"#define USE_TANGENT\" : \"\",\n      parameters.vertexColors || parameters.instancingColor ? \"#define USE_COLOR\" : \"\",\n      parameters.vertexAlphas ? \"#define USE_COLOR_ALPHA\" : \"\",\n      parameters.vertexUvs ? \"#define USE_UV\" : \"\",\n      parameters.uvsVertexOnly ? \"#define UVS_VERTEX_ONLY\" : \"\",\n      parameters.gradientMap ? \"#define USE_GRADIENTMAP\" : \"\",\n      parameters.flatShading ? \"#define FLAT_SHADED\" : \"\",\n      parameters.doubleSided ? \"#define DOUBLE_SIDED\" : \"\",\n      parameters.flipSided ? \"#define FLIP_SIDED\" : \"\",\n      parameters.shadowMapEnabled ? \"#define USE_SHADOWMAP\" : \"\",\n      parameters.shadowMapEnabled ? \"#define \" + shadowMapTypeDefine : \"\",\n      parameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : \"\",\n      parameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : \"\",\n      parameters.logarithmicDepthBuffer ? \"#define USE_LOGDEPTHBUF\" : \"\",\n      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ? \"#define USE_LOGDEPTHBUF_EXT\" : \"\",\n      (parameters.extensionShaderTextureLOD || parameters.envMap) && parameters.rendererExtensionShaderTextureLod ? \"#define TEXTURE_LOD_EXT\" : \"\",\n      \"uniform mat4 viewMatrix;\",\n      \"uniform vec3 cameraPosition;\",\n      \"uniform bool isOrthographic;\",\n      parameters.toneMapping !== NoToneMapping ? \"#define TONE_MAPPING\" : \"\",\n      parameters.toneMapping !== NoToneMapping ? ShaderChunk[\"tonemapping_pars_fragment\"] : \"\",\n      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction(\"toneMapping\", parameters.toneMapping) : \"\",\n      parameters.dithering ? \"#define DITHERING\" : \"\",\n      ShaderChunk[\"encodings_pars_fragment\"],\n      parameters.map ? getTexelDecodingFunction(\"mapTexelToLinear\", parameters.mapEncoding) : \"\",\n      parameters.matcap ? getTexelDecodingFunction(\"matcapTexelToLinear\", parameters.matcapEncoding) : \"\",\n      parameters.envMap ? getTexelDecodingFunction(\"envMapTexelToLinear\", parameters.envMapEncoding) : \"\",\n      parameters.emissiveMap ? getTexelDecodingFunction(\"emissiveMapTexelToLinear\", parameters.emissiveMapEncoding) : \"\",\n      parameters.lightMap ? getTexelDecodingFunction(\"lightMapTexelToLinear\", parameters.lightMapEncoding) : \"\",\n      getTexelEncodingFunction(\"linearToOutputTexel\", parameters.outputEncoding),\n      parameters.depthPacking ? \"#define DEPTH_PACKING \" + parameters.depthPacking : \"\",\n      \"\\n\"\n    ].filter(filterEmptyLine).join(\"\\n\");\n  }\n  vertexShader = resolveIncludes(vertexShader);\n  vertexShader = replaceLightNums(vertexShader, parameters);\n  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);\n  fragmentShader = resolveIncludes(fragmentShader);\n  fragmentShader = replaceLightNums(fragmentShader, parameters);\n  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);\n  vertexShader = unrollLoops(vertexShader);\n  fragmentShader = unrollLoops(fragmentShader);\n  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {\n    versionString = \"#version 300 es\\n\";\n    prefixVertex = [\n      \"#define attribute in\",\n      \"#define varying out\",\n      \"#define texture2D texture\"\n    ].join(\"\\n\") + \"\\n\" + prefixVertex;\n    prefixFragment = [\n      \"#define varying in\",\n      parameters.glslVersion === GLSL3 ? \"\" : \"out highp vec4 pc_fragColor;\",\n      parameters.glslVersion === GLSL3 ? \"\" : \"#define gl_FragColor pc_fragColor\",\n      \"#define gl_FragDepthEXT gl_FragDepth\",\n      \"#define texture2D texture\",\n      \"#define textureCube texture\",\n      \"#define texture2DProj textureProj\",\n      \"#define texture2DLodEXT textureLod\",\n      \"#define texture2DProjLodEXT textureProjLod\",\n      \"#define textureCubeLodEXT textureLod\",\n      \"#define texture2DGradEXT textureGrad\",\n      \"#define texture2DProjGradEXT textureProjGrad\",\n      \"#define textureCubeGradEXT textureGrad\"\n    ].join(\"\\n\") + \"\\n\" + prefixFragment;\n  }\n  const vertexGlsl = versionString + prefixVertex + vertexShader;\n  const fragmentGlsl = versionString + prefixFragment + fragmentShader;\n  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl);\n  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl);\n  gl.attachShader(program, glVertexShader);\n  gl.attachShader(program, glFragmentShader);\n  if (parameters.index0AttributeName !== void 0) {\n    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);\n  } else if (parameters.morphTargets === true) {\n    gl.bindAttribLocation(program, 0, \"position\");\n  }\n  gl.linkProgram(program);\n  if (renderer.debug.checkShaderErrors) {\n    const programLog = gl.getProgramInfoLog(program).trim();\n    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim();\n    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim();\n    let runnable = true;\n    let haveDiagnostics = true;\n    if (gl.getProgramParameter(program, 35714) === false) {\n      runnable = false;\n      const vertexErrors = getShaderErrors(gl, glVertexShader, \"vertex\");\n      const fragmentErrors = getShaderErrors(gl, glFragmentShader, \"fragment\");\n      console.error(\"THREE.WebGLProgram: shader error: \", gl.getError(), \"35715\", gl.getProgramParameter(program, 35715), \"gl.getProgramInfoLog\", programLog, vertexErrors, fragmentErrors);\n    } else if (programLog !== \"\") {\n      console.warn(\"THREE.WebGLProgram: gl.getProgramInfoLog()\", programLog);\n    } else if (vertexLog === \"\" || fragmentLog === \"\") {\n      haveDiagnostics = false;\n    }\n    if (haveDiagnostics) {\n      this.diagnostics = {\n        runnable,\n        programLog,\n        vertexShader: {\n          log: vertexLog,\n          prefix: prefixVertex\n        },\n        fragmentShader: {\n          log: fragmentLog,\n          prefix: prefixFragment\n        }\n      };\n    }\n  }\n  gl.deleteShader(glVertexShader);\n  gl.deleteShader(glFragmentShader);\n  let cachedUniforms;\n  this.getUniforms = function() {\n    if (cachedUniforms === void 0) {\n      cachedUniforms = new WebGLUniforms(gl, program);\n    }\n    return cachedUniforms;\n  };\n  let cachedAttributes;\n  this.getAttributes = function() {\n    if (cachedAttributes === void 0) {\n      cachedAttributes = fetchAttributeLocations(gl, program);\n    }\n    return cachedAttributes;\n  };\n  this.destroy = function() {\n    bindingStates.releaseStatesOfProgram(this);\n    gl.deleteProgram(program);\n    this.program = void 0;\n  };\n  this.name = parameters.shaderName;\n  this.id = programIdCount++;\n  this.cacheKey = cacheKey;\n  this.usedTimes = 1;\n  this.program = program;\n  this.vertexShader = glVertexShader;\n  this.fragmentShader = glFragmentShader;\n  return this;\n}\nfunction WebGLPrograms(renderer, cubemaps, extensions, capabilities, bindingStates, clipping) {\n  const programs = [];\n  const isWebGL2 = capabilities.isWebGL2;\n  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;\n  const floatVertexTextures = capabilities.floatVertexTextures;\n  const maxVertexUniforms = capabilities.maxVertexUniforms;\n  const vertexTextures = capabilities.vertexTextures;\n  let precision = capabilities.precision;\n  const shaderIDs = {\n    MeshDepthMaterial: \"depth\",\n    MeshDistanceMaterial: \"distanceRGBA\",\n    MeshNormalMaterial: \"normal\",\n    MeshBasicMaterial: \"basic\",\n    MeshLambertMaterial: \"lambert\",\n    MeshPhongMaterial: \"phong\",\n    MeshToonMaterial: \"toon\",\n    MeshStandardMaterial: \"physical\",\n    MeshPhysicalMaterial: \"physical\",\n    MeshMatcapMaterial: \"matcap\",\n    LineBasicMaterial: \"basic\",\n    LineDashedMaterial: \"dashed\",\n    PointsMaterial: \"points\",\n    ShadowMaterial: \"shadow\",\n    SpriteMaterial: \"sprite\"\n  };\n  const parameterNames = [\n    \"precision\",\n    \"isWebGL2\",\n    \"supportsVertexTextures\",\n    \"outputEncoding\",\n    \"instancing\",\n    \"instancingColor\",\n    \"map\",\n    \"mapEncoding\",\n    \"matcap\",\n    \"matcapEncoding\",\n    \"envMap\",\n    \"envMapMode\",\n    \"envMapEncoding\",\n    \"envMapCubeUV\",\n    \"lightMap\",\n    \"lightMapEncoding\",\n    \"aoMap\",\n    \"emissiveMap\",\n    \"emissiveMapEncoding\",\n    \"bumpMap\",\n    \"normalMap\",\n    \"objectSpaceNormalMap\",\n    \"tangentSpaceNormalMap\",\n    \"clearcoatMap\",\n    \"clearcoatRoughnessMap\",\n    \"clearcoatNormalMap\",\n    \"displacementMap\",\n    \"specularMap\",\n    \"roughnessMap\",\n    \"metalnessMap\",\n    \"gradientMap\",\n    \"alphaMap\",\n    \"combine\",\n    \"vertexColors\",\n    \"vertexAlphas\",\n    \"vertexTangents\",\n    \"vertexUvs\",\n    \"uvsVertexOnly\",\n    \"fog\",\n    \"useFog\",\n    \"fogExp2\",\n    \"flatShading\",\n    \"sizeAttenuation\",\n    \"logarithmicDepthBuffer\",\n    \"skinning\",\n    \"maxBones\",\n    \"useVertexTexture\",\n    \"morphTargets\",\n    \"morphNormals\",\n    \"premultipliedAlpha\",\n    \"numDirLights\",\n    \"numPointLights\",\n    \"numSpotLights\",\n    \"numHemiLights\",\n    \"numRectAreaLights\",\n    \"numDirLightShadows\",\n    \"numPointLightShadows\",\n    \"numSpotLightShadows\",\n    \"shadowMapEnabled\",\n    \"shadowMapType\",\n    \"toneMapping\",\n    \"physicallyCorrectLights\",\n    \"alphaTest\",\n    \"doubleSided\",\n    \"flipSided\",\n    \"numClippingPlanes\",\n    \"numClipIntersection\",\n    \"depthPacking\",\n    \"dithering\",\n    \"sheen\",\n    \"transmissionMap\"\n  ];\n  function getMaxBones(object) {\n    const skeleton = object.skeleton;\n    const bones = skeleton.bones;\n    if (floatVertexTextures) {\n      return 1024;\n    } else {\n      const nVertexUniforms = maxVertexUniforms;\n      const nVertexMatrices = Math.floor((nVertexUniforms - 20) / 4);\n      const maxBones = Math.min(nVertexMatrices, bones.length);\n      if (maxBones < bones.length) {\n        console.warn(\"THREE.WebGLRenderer: Skeleton has \" + bones.length + \" bones. This GPU supports \" + maxBones + \".\");\n        return 0;\n      }\n      return maxBones;\n    }\n  }\n  function getTextureEncodingFromMap(map) {\n    let encoding;\n    if (map && map.isTexture) {\n      encoding = map.encoding;\n    } else if (map && map.isWebGLRenderTarget) {\n      console.warn(\"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\");\n      encoding = map.texture.encoding;\n    } else {\n      encoding = LinearEncoding;\n    }\n    return encoding;\n  }\n  function getParameters(material, lights, shadows, scene, object) {\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const envMap = cubemaps.get(material.envMap || environment);\n    const shaderID = shaderIDs[material.type];\n    const maxBones = object.isSkinnedMesh ? getMaxBones(object) : 0;\n    if (material.precision !== null) {\n      precision = capabilities.getMaxPrecision(material.precision);\n      if (precision !== material.precision) {\n        console.warn(\"THREE.WebGLProgram.getParameters:\", material.precision, \"not supported, using\", precision, \"instead.\");\n      }\n    }\n    let vertexShader, fragmentShader;\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n      vertexShader = shader.vertexShader;\n      fragmentShader = shader.fragmentShader;\n    } else {\n      vertexShader = material.vertexShader;\n      fragmentShader = material.fragmentShader;\n    }\n    const currentRenderTarget = renderer.getRenderTarget();\n    const parameters = {\n      isWebGL2,\n      shaderID,\n      shaderName: material.type,\n      vertexShader,\n      fragmentShader,\n      defines: material.defines,\n      isRawShaderMaterial: material.isRawShaderMaterial === true,\n      glslVersion: material.glslVersion,\n      precision,\n      instancing: object.isInstancedMesh === true,\n      instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,\n      supportsVertexTextures: vertexTextures,\n      outputEncoding: currentRenderTarget !== null ? getTextureEncodingFromMap(currentRenderTarget.texture) : renderer.outputEncoding,\n      map: !!material.map,\n      mapEncoding: getTextureEncodingFromMap(material.map),\n      matcap: !!material.matcap,\n      matcapEncoding: getTextureEncodingFromMap(material.matcap),\n      envMap: !!envMap,\n      envMapMode: envMap && envMap.mapping,\n      envMapEncoding: getTextureEncodingFromMap(envMap),\n      envMapCubeUV: !!envMap && (envMap.mapping === CubeUVReflectionMapping || envMap.mapping === CubeUVRefractionMapping),\n      lightMap: !!material.lightMap,\n      lightMapEncoding: getTextureEncodingFromMap(material.lightMap),\n      aoMap: !!material.aoMap,\n      emissiveMap: !!material.emissiveMap,\n      emissiveMapEncoding: getTextureEncodingFromMap(material.emissiveMap),\n      bumpMap: !!material.bumpMap,\n      normalMap: !!material.normalMap,\n      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,\n      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,\n      clearcoatMap: !!material.clearcoatMap,\n      clearcoatRoughnessMap: !!material.clearcoatRoughnessMap,\n      clearcoatNormalMap: !!material.clearcoatNormalMap,\n      displacementMap: !!material.displacementMap,\n      roughnessMap: !!material.roughnessMap,\n      metalnessMap: !!material.metalnessMap,\n      specularMap: !!material.specularMap,\n      alphaMap: !!material.alphaMap,\n      gradientMap: !!material.gradientMap,\n      sheen: !!material.sheen,\n      transmissionMap: !!material.transmissionMap,\n      combine: material.combine,\n      vertexTangents: material.normalMap && material.vertexTangents,\n      vertexColors: material.vertexColors,\n      vertexAlphas: material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4,\n      vertexUvs: !!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatMap || !!material.clearcoatRoughnessMap || !!material.clearcoatNormalMap || !!material.displacementMap || !!material.transmissionMap,\n      uvsVertexOnly: !(!!material.map || !!material.bumpMap || !!material.normalMap || !!material.specularMap || !!material.alphaMap || !!material.emissiveMap || !!material.roughnessMap || !!material.metalnessMap || !!material.clearcoatNormalMap || !!material.transmissionMap) && !!material.displacementMap,\n      fog: !!fog,\n      useFog: material.fog,\n      fogExp2: fog && fog.isFogExp2,\n      flatShading: !!material.flatShading,\n      sizeAttenuation: material.sizeAttenuation,\n      logarithmicDepthBuffer,\n      skinning: material.skinning && maxBones > 0,\n      maxBones,\n      useVertexTexture: floatVertexTextures,\n      morphTargets: material.morphTargets,\n      morphNormals: material.morphNormals,\n      numDirLights: lights.directional.length,\n      numPointLights: lights.point.length,\n      numSpotLights: lights.spot.length,\n      numRectAreaLights: lights.rectArea.length,\n      numHemiLights: lights.hemi.length,\n      numDirLightShadows: lights.directionalShadowMap.length,\n      numPointLightShadows: lights.pointShadowMap.length,\n      numSpotLightShadows: lights.spotShadowMap.length,\n      numClippingPlanes: clipping.numPlanes,\n      numClipIntersection: clipping.numIntersection,\n      dithering: material.dithering,\n      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,\n      shadowMapType: renderer.shadowMap.type,\n      toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,\n      physicallyCorrectLights: renderer.physicallyCorrectLights,\n      premultipliedAlpha: material.premultipliedAlpha,\n      alphaTest: material.alphaTest,\n      doubleSided: material.side === DoubleSide,\n      flipSided: material.side === BackSide,\n      depthPacking: material.depthPacking !== void 0 ? material.depthPacking : false,\n      index0AttributeName: material.index0AttributeName,\n      extensionDerivatives: material.extensions && material.extensions.derivatives,\n      extensionFragDepth: material.extensions && material.extensions.fragDepth,\n      extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,\n      extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,\n      rendererExtensionFragDepth: isWebGL2 || extensions.has(\"EXT_frag_depth\"),\n      rendererExtensionDrawBuffers: isWebGL2 || extensions.has(\"WEBGL_draw_buffers\"),\n      rendererExtensionShaderTextureLod: isWebGL2 || extensions.has(\"EXT_shader_texture_lod\"),\n      customProgramCacheKey: material.customProgramCacheKey()\n    };\n    return parameters;\n  }\n  function getProgramCacheKey(parameters) {\n    const array = [];\n    if (parameters.shaderID) {\n      array.push(parameters.shaderID);\n    } else {\n      array.push(parameters.fragmentShader);\n      array.push(parameters.vertexShader);\n    }\n    if (parameters.defines !== void 0) {\n      for (const name in parameters.defines) {\n        array.push(name);\n        array.push(parameters.defines[name]);\n      }\n    }\n    if (parameters.isRawShaderMaterial === false) {\n      for (let i = 0; i < parameterNames.length; i++) {\n        array.push(parameters[parameterNames[i]]);\n      }\n      array.push(renderer.outputEncoding);\n      array.push(renderer.gammaFactor);\n    }\n    array.push(parameters.customProgramCacheKey);\n    return array.join();\n  }\n  function getUniforms(material) {\n    const shaderID = shaderIDs[material.type];\n    let uniforms;\n    if (shaderID) {\n      const shader = ShaderLib[shaderID];\n      uniforms = UniformsUtils.clone(shader.uniforms);\n    } else {\n      uniforms = material.uniforms;\n    }\n    return uniforms;\n  }\n  function acquireProgram(parameters, cacheKey) {\n    let program;\n    for (let p = 0, pl = programs.length; p < pl; p++) {\n      const preexistingProgram = programs[p];\n      if (preexistingProgram.cacheKey === cacheKey) {\n        program = preexistingProgram;\n        ++program.usedTimes;\n        break;\n      }\n    }\n    if (program === void 0) {\n      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);\n      programs.push(program);\n    }\n    return program;\n  }\n  function releaseProgram(program) {\n    if (--program.usedTimes === 0) {\n      const i = programs.indexOf(program);\n      programs[i] = programs[programs.length - 1];\n      programs.pop();\n      program.destroy();\n    }\n  }\n  return {\n    getParameters,\n    getProgramCacheKey,\n    getUniforms,\n    acquireProgram,\n    releaseProgram,\n    programs\n  };\n}\nfunction WebGLProperties() {\n  let properties = new WeakMap();\n  function get(object) {\n    let map = properties.get(object);\n    if (map === void 0) {\n      map = {};\n      properties.set(object, map);\n    }\n    return map;\n  }\n  function remove(object) {\n    properties.delete(object);\n  }\n  function update(object, key, value) {\n    properties.get(object)[key] = value;\n  }\n  function dispose() {\n    properties = new WeakMap();\n  }\n  return {\n    get,\n    remove,\n    update,\n    dispose\n  };\n}\nfunction painterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.program !== b.program) {\n    return a.program.id - b.program.id;\n  } else if (a.material.id !== b.material.id) {\n    return a.material.id - b.material.id;\n  } else if (a.z !== b.z) {\n    return a.z - b.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction reversePainterSortStable(a, b) {\n  if (a.groupOrder !== b.groupOrder) {\n    return a.groupOrder - b.groupOrder;\n  } else if (a.renderOrder !== b.renderOrder) {\n    return a.renderOrder - b.renderOrder;\n  } else if (a.z !== b.z) {\n    return b.z - a.z;\n  } else {\n    return a.id - b.id;\n  }\n}\nfunction WebGLRenderList(properties) {\n  const renderItems = [];\n  let renderItemsIndex = 0;\n  const opaque = [];\n  const transparent = [];\n  const defaultProgram = {id: -1};\n  function init() {\n    renderItemsIndex = 0;\n    opaque.length = 0;\n    transparent.length = 0;\n  }\n  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {\n    let renderItem = renderItems[renderItemsIndex];\n    const materialProperties = properties.get(material);\n    if (renderItem === void 0) {\n      renderItem = {\n        id: object.id,\n        object,\n        geometry,\n        material,\n        program: materialProperties.program || defaultProgram,\n        groupOrder,\n        renderOrder: object.renderOrder,\n        z,\n        group\n      };\n      renderItems[renderItemsIndex] = renderItem;\n    } else {\n      renderItem.id = object.id;\n      renderItem.object = object;\n      renderItem.geometry = geometry;\n      renderItem.material = material;\n      renderItem.program = materialProperties.program || defaultProgram;\n      renderItem.groupOrder = groupOrder;\n      renderItem.renderOrder = object.renderOrder;\n      renderItem.z = z;\n      renderItem.group = group;\n    }\n    renderItemsIndex++;\n    return renderItem;\n  }\n  function push(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n    (material.transparent === true ? transparent : opaque).push(renderItem);\n  }\n  function unshift(object, geometry, material, groupOrder, z, group) {\n    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z, group);\n    (material.transparent === true ? transparent : opaque).unshift(renderItem);\n  }\n  function sort(customOpaqueSort, customTransparentSort) {\n    if (opaque.length > 1)\n      opaque.sort(customOpaqueSort || painterSortStable);\n    if (transparent.length > 1)\n      transparent.sort(customTransparentSort || reversePainterSortStable);\n  }\n  function finish() {\n    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {\n      const renderItem = renderItems[i];\n      if (renderItem.id === null)\n        break;\n      renderItem.id = null;\n      renderItem.object = null;\n      renderItem.geometry = null;\n      renderItem.material = null;\n      renderItem.program = null;\n      renderItem.group = null;\n    }\n  }\n  return {\n    opaque,\n    transparent,\n    init,\n    push,\n    unshift,\n    finish,\n    sort\n  };\n}\nfunction WebGLRenderLists(properties) {\n  let lists = new WeakMap();\n  function get(scene, renderCallDepth) {\n    let list;\n    if (lists.has(scene) === false) {\n      list = new WebGLRenderList(properties);\n      lists.set(scene, [list]);\n    } else {\n      if (renderCallDepth >= lists.get(scene).length) {\n        list = new WebGLRenderList(properties);\n        lists.get(scene).push(list);\n      } else {\n        list = lists.get(scene)[renderCallDepth];\n      }\n    }\n    return list;\n  }\n  function dispose() {\n    lists = new WeakMap();\n  }\n  return {\n    get,\n    dispose\n  };\n}\nfunction UniformsCache() {\n  const lights = {};\n  return {\n    get: function(light) {\n      if (lights[light.id] !== void 0) {\n        return lights[light.id];\n      }\n      let uniforms;\n      switch (light.type) {\n        case \"DirectionalLight\":\n          uniforms = {\n            direction: new Vector3(),\n            color: new Color()\n          };\n          break;\n        case \"SpotLight\":\n          uniforms = {\n            position: new Vector3(),\n            direction: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            coneCos: 0,\n            penumbraCos: 0,\n            decay: 0\n          };\n          break;\n        case \"PointLight\":\n          uniforms = {\n            position: new Vector3(),\n            color: new Color(),\n            distance: 0,\n            decay: 0\n          };\n          break;\n        case \"HemisphereLight\":\n          uniforms = {\n            direction: new Vector3(),\n            skyColor: new Color(),\n            groundColor: new Color()\n          };\n          break;\n        case \"RectAreaLight\":\n          uniforms = {\n            color: new Color(),\n            position: new Vector3(),\n            halfWidth: new Vector3(),\n            halfHeight: new Vector3()\n          };\n          break;\n      }\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\nfunction ShadowUniformsCache() {\n  const lights = {};\n  return {\n    get: function(light) {\n      if (lights[light.id] !== void 0) {\n        return lights[light.id];\n      }\n      let uniforms;\n      switch (light.type) {\n        case \"DirectionalLight\":\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n        case \"SpotLight\":\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2()\n          };\n          break;\n        case \"PointLight\":\n          uniforms = {\n            shadowBias: 0,\n            shadowNormalBias: 0,\n            shadowRadius: 1,\n            shadowMapSize: new Vector2(),\n            shadowCameraNear: 1,\n            shadowCameraFar: 1e3\n          };\n          break;\n      }\n      lights[light.id] = uniforms;\n      return uniforms;\n    }\n  };\n}\nlet nextVersion = 0;\nfunction shadowCastingLightsFirst(lightA, lightB) {\n  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0);\n}\nfunction WebGLLights(extensions, capabilities) {\n  const cache = new UniformsCache();\n  const shadowCache = ShadowUniformsCache();\n  const state = {\n    version: 0,\n    hash: {\n      directionalLength: -1,\n      pointLength: -1,\n      spotLength: -1,\n      rectAreaLength: -1,\n      hemiLength: -1,\n      numDirectionalShadows: -1,\n      numPointShadows: -1,\n      numSpotShadows: -1\n    },\n    ambient: [0, 0, 0],\n    probe: [],\n    directional: [],\n    directionalShadow: [],\n    directionalShadowMap: [],\n    directionalShadowMatrix: [],\n    spot: [],\n    spotShadow: [],\n    spotShadowMap: [],\n    spotShadowMatrix: [],\n    rectArea: [],\n    rectAreaLTC1: null,\n    rectAreaLTC2: null,\n    point: [],\n    pointShadow: [],\n    pointShadowMap: [],\n    pointShadowMatrix: [],\n    hemi: []\n  };\n  for (let i = 0; i < 9; i++)\n    state.probe.push(new Vector3());\n  const vector3 = new Vector3();\n  const matrix4 = new Matrix4();\n  const matrix42 = new Matrix4();\n  function setup(lights) {\n    let r = 0, g = 0, b = 0;\n    for (let i = 0; i < 9; i++)\n      state.probe[i].set(0, 0, 0);\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    let numDirectionalShadows = 0;\n    let numPointShadows = 0;\n    let numSpotShadows = 0;\n    lights.sort(shadowCastingLightsFirst);\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      const color = light.color;\n      const intensity = light.intensity;\n      const distance = light.distance;\n      const shadowMap = light.shadow && light.shadow.map ? light.shadow.map.texture : null;\n      if (light.isAmbientLight) {\n        r += color.r * intensity;\n        g += color.g * intensity;\n        b += color.b * intensity;\n      } else if (light.isLightProbe) {\n        for (let j = 0; j < 9; j++) {\n          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity);\n        }\n      } else if (light.isDirectionalLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.directionalShadow[directionalLength] = shadowUniforms;\n          state.directionalShadowMap[directionalLength] = shadowMap;\n          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;\n          numDirectionalShadows++;\n        }\n        state.directional[directionalLength] = uniforms;\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = cache.get(light);\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.distance = distance;\n        uniforms.coneCos = Math.cos(light.angle);\n        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));\n        uniforms.decay = light.decay;\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          state.spotShadow[spotLength] = shadowUniforms;\n          state.spotShadowMap[spotLength] = shadowMap;\n          state.spotShadowMatrix[spotLength] = light.shadow.matrix;\n          numSpotShadows++;\n        }\n        state.spot[spotLength] = uniforms;\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(color).multiplyScalar(intensity);\n        uniforms.halfWidth.set(light.width * 0.5, 0, 0);\n        uniforms.halfHeight.set(0, light.height * 0.5, 0);\n        state.rectArea[rectAreaLength] = uniforms;\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = cache.get(light);\n        uniforms.color.copy(light.color).multiplyScalar(light.intensity);\n        uniforms.distance = light.distance;\n        uniforms.decay = light.decay;\n        if (light.castShadow) {\n          const shadow = light.shadow;\n          const shadowUniforms = shadowCache.get(light);\n          shadowUniforms.shadowBias = shadow.bias;\n          shadowUniforms.shadowNormalBias = shadow.normalBias;\n          shadowUniforms.shadowRadius = shadow.radius;\n          shadowUniforms.shadowMapSize = shadow.mapSize;\n          shadowUniforms.shadowCameraNear = shadow.camera.near;\n          shadowUniforms.shadowCameraFar = shadow.camera.far;\n          state.pointShadow[pointLength] = shadowUniforms;\n          state.pointShadowMap[pointLength] = shadowMap;\n          state.pointShadowMatrix[pointLength] = light.shadow.matrix;\n          numPointShadows++;\n        }\n        state.point[pointLength] = uniforms;\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = cache.get(light);\n        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);\n        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);\n        state.hemi[hemiLength] = uniforms;\n        hemiLength++;\n      }\n    }\n    if (rectAreaLength > 0) {\n      if (capabilities.isWebGL2) {\n        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n      } else {\n        if (extensions.has(\"OES_texture_float_linear\") === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;\n        } else if (extensions.has(\"OES_texture_half_float_linear\") === true) {\n          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;\n          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;\n        } else {\n          console.error(\"THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.\");\n        }\n      }\n    }\n    state.ambient[0] = r;\n    state.ambient[1] = g;\n    state.ambient[2] = b;\n    const hash = state.hash;\n    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows) {\n      state.directional.length = directionalLength;\n      state.spot.length = spotLength;\n      state.rectArea.length = rectAreaLength;\n      state.point.length = pointLength;\n      state.hemi.length = hemiLength;\n      state.directionalShadow.length = numDirectionalShadows;\n      state.directionalShadowMap.length = numDirectionalShadows;\n      state.pointShadow.length = numPointShadows;\n      state.pointShadowMap.length = numPointShadows;\n      state.spotShadow.length = numSpotShadows;\n      state.spotShadowMap.length = numSpotShadows;\n      state.directionalShadowMatrix.length = numDirectionalShadows;\n      state.pointShadowMatrix.length = numPointShadows;\n      state.spotShadowMatrix.length = numSpotShadows;\n      hash.directionalLength = directionalLength;\n      hash.pointLength = pointLength;\n      hash.spotLength = spotLength;\n      hash.rectAreaLength = rectAreaLength;\n      hash.hemiLength = hemiLength;\n      hash.numDirectionalShadows = numDirectionalShadows;\n      hash.numPointShadows = numPointShadows;\n      hash.numSpotShadows = numSpotShadows;\n      state.version = nextVersion++;\n    }\n  }\n  function setupView(lights, camera) {\n    let directionalLength = 0;\n    let pointLength = 0;\n    let spotLength = 0;\n    let rectAreaLength = 0;\n    let hemiLength = 0;\n    const viewMatrix = camera.matrixWorldInverse;\n    for (let i = 0, l = lights.length; i < l; i++) {\n      const light = lights[i];\n      if (light.isDirectionalLight) {\n        const uniforms = state.directional[directionalLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        directionalLength++;\n      } else if (light.isSpotLight) {\n        const uniforms = state.spot[spotLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        vector3.setFromMatrixPosition(light.target.matrixWorld);\n        uniforms.direction.sub(vector3);\n        uniforms.direction.transformDirection(viewMatrix);\n        spotLength++;\n      } else if (light.isRectAreaLight) {\n        const uniforms = state.rectArea[rectAreaLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        matrix42.identity();\n        matrix4.copy(light.matrixWorld);\n        matrix4.premultiply(viewMatrix);\n        matrix42.extractRotation(matrix4);\n        uniforms.halfWidth.set(light.width * 0.5, 0, 0);\n        uniforms.halfHeight.set(0, light.height * 0.5, 0);\n        uniforms.halfWidth.applyMatrix4(matrix42);\n        uniforms.halfHeight.applyMatrix4(matrix42);\n        rectAreaLength++;\n      } else if (light.isPointLight) {\n        const uniforms = state.point[pointLength];\n        uniforms.position.setFromMatrixPosition(light.matrixWorld);\n        uniforms.position.applyMatrix4(viewMatrix);\n        pointLength++;\n      } else if (light.isHemisphereLight) {\n        const uniforms = state.hemi[hemiLength];\n        uniforms.direction.setFromMatrixPosition(light.matrixWorld);\n        uniforms.direction.transformDirection(viewMatrix);\n        uniforms.direction.normalize();\n        hemiLength++;\n      }\n    }\n  }\n  return {\n    setup,\n    setupView,\n    state\n  };\n}\nfunction WebGLRenderState(extensions, capabilities) {\n  const lights = new WebGLLights(extensions, capabilities);\n  const lightsArray = [];\n  const shadowsArray = [];\n  function init() {\n    lightsArray.length = 0;\n    shadowsArray.length = 0;\n  }\n  function pushLight(light) {\n    lightsArray.push(light);\n  }\n  function pushShadow(shadowLight) {\n    shadowsArray.push(shadowLight);\n  }\n  function setupLights() {\n    lights.setup(lightsArray);\n  }\n  function setupLightsView(camera) {\n    lights.setupView(lightsArray, camera);\n  }\n  const state = {\n    lightsArray,\n    shadowsArray,\n    lights\n  };\n  return {\n    init,\n    state,\n    setupLights,\n    setupLightsView,\n    pushLight,\n    pushShadow\n  };\n}\nfunction WebGLRenderStates(extensions, capabilities) {\n  let renderStates = new WeakMap();\n  function get(scene, renderCallDepth = 0) {\n    let renderState;\n    if (renderStates.has(scene) === false) {\n      renderState = new WebGLRenderState(extensions, capabilities);\n      renderStates.set(scene, [renderState]);\n    } else {\n      if (renderCallDepth >= renderStates.get(scene).length) {\n        renderState = new WebGLRenderState(extensions, capabilities);\n        renderStates.get(scene).push(renderState);\n      } else {\n        renderState = renderStates.get(scene)[renderCallDepth];\n      }\n    }\n    return renderState;\n  }\n  function dispose() {\n    renderStates = new WeakMap();\n  }\n  return {\n    get,\n    dispose\n  };\n}\nclass MeshDepthMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"MeshDepthMaterial\";\n    this.depthPacking = BasicDepthPacking;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.depthPacking = source.depthPacking;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    return this;\n  }\n}\nMeshDepthMaterial.prototype.isMeshDepthMaterial = true;\nclass MeshDistanceMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"MeshDistanceMaterial\";\n    this.referencePosition = new Vector3();\n    this.nearDistance = 1;\n    this.farDistance = 1e3;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.map = null;\n    this.alphaMap = null;\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.fog = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.referencePosition.copy(source.referencePosition);\n    this.nearDistance = source.nearDistance;\n    this.farDistance = source.farDistance;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    return this;\n  }\n}\nMeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;\nvar vsm_frag = \"uniform sampler2D shadow_pass;\\nuniform vec2 resolution;\\nuniform float radius;\\n#include <packing>\\nvoid main() {\\n\tfloat mean = 0.0;\\n\tfloat squared_mean = 0.0;\\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\\n\t\t#ifdef HORIZONTAL_PASS\\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\\n\t\t\tmean += distribution.x;\\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\\n\t\t#else\\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\\n\t\t\tmean += depth;\\n\t\t\tsquared_mean += depth * depth;\\n\t\t#endif\\n\t}\\n\tmean = mean * HALF_SAMPLE_RATE;\\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\\n}\";\nvar vsm_vert = \"void main() {\\n\tgl_Position = vec4( position, 1.0 );\\n}\";\nfunction WebGLShadowMap(_renderer, _objects, _capabilities) {\n  let _frustum = new Frustum();\n  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterials = [], _distanceMaterials = [], _materialCache = {}, _maxTextureSize = _capabilities.maxTextureSize;\n  const shadowSide = {0: BackSide, 1: FrontSide, 2: DoubleSide};\n  const shadowMaterialVertical = new ShaderMaterial({\n    defines: {\n      SAMPLE_RATE: 2 / 8,\n      HALF_SAMPLE_RATE: 1 / 8\n    },\n    uniforms: {\n      shadow_pass: {value: null},\n      resolution: {value: new Vector2()},\n      radius: {value: 4}\n    },\n    vertexShader: vsm_vert,\n    fragmentShader: vsm_frag\n  });\n  const shadowMaterialHorizontal = shadowMaterialVertical.clone();\n  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;\n  const fullScreenTri = new BufferGeometry();\n  fullScreenTri.setAttribute(\"position\", new BufferAttribute(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3));\n  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);\n  const scope = this;\n  this.enabled = false;\n  this.autoUpdate = true;\n  this.needsUpdate = false;\n  this.type = PCFShadowMap;\n  this.render = function(lights, scene, camera) {\n    if (scope.enabled === false)\n      return;\n    if (scope.autoUpdate === false && scope.needsUpdate === false)\n      return;\n    if (lights.length === 0)\n      return;\n    const currentRenderTarget = _renderer.getRenderTarget();\n    const activeCubeFace = _renderer.getActiveCubeFace();\n    const activeMipmapLevel = _renderer.getActiveMipmapLevel();\n    const _state = _renderer.state;\n    _state.setBlending(NoBlending);\n    _state.buffers.color.setClear(1, 1, 1, 1);\n    _state.buffers.depth.setTest(true);\n    _state.setScissorTest(false);\n    for (let i = 0, il = lights.length; i < il; i++) {\n      const light = lights[i];\n      const shadow = light.shadow;\n      if (shadow === void 0) {\n        console.warn(\"THREE.WebGLShadowMap:\", light, \"has no shadow.\");\n        continue;\n      }\n      if (shadow.autoUpdate === false && shadow.needsUpdate === false)\n        continue;\n      _shadowMapSize.copy(shadow.mapSize);\n      const shadowFrameExtents = shadow.getFrameExtents();\n      _shadowMapSize.multiply(shadowFrameExtents);\n      _viewportSize.copy(shadow.mapSize);\n      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {\n        if (_shadowMapSize.x > _maxTextureSize) {\n          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);\n          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;\n          shadow.mapSize.x = _viewportSize.x;\n        }\n        if (_shadowMapSize.y > _maxTextureSize) {\n          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);\n          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;\n          shadow.mapSize.y = _viewportSize.y;\n        }\n      }\n      if (shadow.map === null && !shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        const pars = {minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat};\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + \".shadowMap\";\n        shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.camera.updateProjectionMatrix();\n      }\n      if (shadow.map === null) {\n        const pars = {minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat};\n        shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, pars);\n        shadow.map.texture.name = light.name + \".shadowMap\";\n        shadow.camera.updateProjectionMatrix();\n      }\n      _renderer.setRenderTarget(shadow.map);\n      _renderer.clear();\n      const viewportCount = shadow.getViewportCount();\n      for (let vp = 0; vp < viewportCount; vp++) {\n        const viewport = shadow.getViewport(vp);\n        _viewport.set(_viewportSize.x * viewport.x, _viewportSize.y * viewport.y, _viewportSize.x * viewport.z, _viewportSize.y * viewport.w);\n        _state.viewport(_viewport);\n        shadow.updateMatrices(light, vp);\n        _frustum = shadow.getFrustum();\n        renderObject(scene, camera, shadow.camera, light, this.type);\n      }\n      if (!shadow.isPointLightShadow && this.type === VSMShadowMap) {\n        VSMPass(shadow, camera);\n      }\n      shadow.needsUpdate = false;\n    }\n    scope.needsUpdate = false;\n    _renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);\n  };\n  function VSMPass(shadow, camera) {\n    const geometry = _objects.update(fullScreenMesh);\n    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;\n    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialVertical.uniforms.radius.value = shadow.radius;\n    _renderer.setRenderTarget(shadow.mapPass);\n    _renderer.clear();\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);\n    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;\n    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;\n    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;\n    _renderer.setRenderTarget(shadow.map);\n    _renderer.clear();\n    _renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);\n  }\n  function getDepthMaterialVariant(useMorphing, useSkinning, useInstancing) {\n    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n    let material = _depthMaterials[index];\n    if (material === void 0) {\n      material = new MeshDepthMaterial({\n        depthPacking: RGBADepthPacking,\n        morphTargets: useMorphing,\n        skinning: useSkinning\n      });\n      _depthMaterials[index] = material;\n    }\n    return material;\n  }\n  function getDistanceMaterialVariant(useMorphing, useSkinning, useInstancing) {\n    const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;\n    let material = _distanceMaterials[index];\n    if (material === void 0) {\n      material = new MeshDistanceMaterial({\n        morphTargets: useMorphing,\n        skinning: useSkinning\n      });\n      _distanceMaterials[index] = material;\n    }\n    return material;\n  }\n  function getDepthMaterial(object, geometry, material, light, shadowCameraNear, shadowCameraFar, type) {\n    let result = null;\n    let getMaterialVariant = getDepthMaterialVariant;\n    let customMaterial = object.customDepthMaterial;\n    if (light.isPointLight === true) {\n      getMaterialVariant = getDistanceMaterialVariant;\n      customMaterial = object.customDistanceMaterial;\n    }\n    if (customMaterial === void 0) {\n      let useMorphing = false;\n      if (material.morphTargets === true) {\n        useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;\n      }\n      let useSkinning = false;\n      if (object.isSkinnedMesh === true) {\n        if (material.skinning === true) {\n          useSkinning = true;\n        } else {\n          console.warn(\"THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:\", object);\n        }\n      }\n      const useInstancing = object.isInstancedMesh === true;\n      result = getMaterialVariant(useMorphing, useSkinning, useInstancing);\n    } else {\n      result = customMaterial;\n    }\n    if (_renderer.localClippingEnabled && material.clipShadows === true && material.clippingPlanes.length !== 0) {\n      const keyA = result.uuid, keyB = material.uuid;\n      let materialsForVariant = _materialCache[keyA];\n      if (materialsForVariant === void 0) {\n        materialsForVariant = {};\n        _materialCache[keyA] = materialsForVariant;\n      }\n      let cachedMaterial = materialsForVariant[keyB];\n      if (cachedMaterial === void 0) {\n        cachedMaterial = result.clone();\n        materialsForVariant[keyB] = cachedMaterial;\n      }\n      result = cachedMaterial;\n    }\n    result.visible = material.visible;\n    result.wireframe = material.wireframe;\n    if (type === VSMShadowMap) {\n      result.side = material.shadowSide !== null ? material.shadowSide : material.side;\n    } else {\n      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];\n    }\n    result.clipShadows = material.clipShadows;\n    result.clippingPlanes = material.clippingPlanes;\n    result.clipIntersection = material.clipIntersection;\n    result.wireframeLinewidth = material.wireframeLinewidth;\n    result.linewidth = material.linewidth;\n    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {\n      result.referencePosition.setFromMatrixPosition(light.matrixWorld);\n      result.nearDistance = shadowCameraNear;\n      result.farDistance = shadowCameraFar;\n    }\n    return result;\n  }\n  function renderObject(object, camera, shadowCamera, light, type) {\n    if (object.visible === false)\n      return;\n    const visible = object.layers.test(camera.layers);\n    if (visible && (object.isMesh || object.isLine || object.isPoints)) {\n      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {\n        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);\n        const geometry = _objects.update(object);\n        const material = object.material;\n        if (Array.isArray(material)) {\n          const groups = geometry.groups;\n          for (let k = 0, kl = groups.length; k < kl; k++) {\n            const group = groups[k];\n            const groupMaterial = material[group.materialIndex];\n            if (groupMaterial && groupMaterial.visible) {\n              const depthMaterial = getDepthMaterial(object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type);\n              _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);\n            }\n          }\n        } else if (material.visible) {\n          const depthMaterial = getDepthMaterial(object, geometry, material, light, shadowCamera.near, shadowCamera.far, type);\n          _renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);\n        }\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      renderObject(children[i], camera, shadowCamera, light, type);\n    }\n  }\n}\nfunction WebGLState(gl, extensions, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  function ColorBuffer() {\n    let locked = false;\n    const color = new Vector4();\n    let currentColorMask = null;\n    const currentColorClear = new Vector4(0, 0, 0, 0);\n    return {\n      setMask: function(colorMask) {\n        if (currentColorMask !== colorMask && !locked) {\n          gl.colorMask(colorMask, colorMask, colorMask, colorMask);\n          currentColorMask = colorMask;\n        }\n      },\n      setLocked: function(lock) {\n        locked = lock;\n      },\n      setClear: function(r, g, b, a, premultipliedAlpha) {\n        if (premultipliedAlpha === true) {\n          r *= a;\n          g *= a;\n          b *= a;\n        }\n        color.set(r, g, b, a);\n        if (currentColorClear.equals(color) === false) {\n          gl.clearColor(r, g, b, a);\n          currentColorClear.copy(color);\n        }\n      },\n      reset: function() {\n        locked = false;\n        currentColorMask = null;\n        currentColorClear.set(-1, 0, 0, 0);\n      }\n    };\n  }\n  function DepthBuffer() {\n    let locked = false;\n    let currentDepthMask = null;\n    let currentDepthFunc = null;\n    let currentDepthClear = null;\n    return {\n      setTest: function(depthTest) {\n        if (depthTest) {\n          enable(2929);\n        } else {\n          disable(2929);\n        }\n      },\n      setMask: function(depthMask) {\n        if (currentDepthMask !== depthMask && !locked) {\n          gl.depthMask(depthMask);\n          currentDepthMask = depthMask;\n        }\n      },\n      setFunc: function(depthFunc) {\n        if (currentDepthFunc !== depthFunc) {\n          if (depthFunc) {\n            switch (depthFunc) {\n              case NeverDepth:\n                gl.depthFunc(512);\n                break;\n              case AlwaysDepth:\n                gl.depthFunc(519);\n                break;\n              case LessDepth:\n                gl.depthFunc(513);\n                break;\n              case LessEqualDepth:\n                gl.depthFunc(515);\n                break;\n              case EqualDepth:\n                gl.depthFunc(514);\n                break;\n              case GreaterEqualDepth:\n                gl.depthFunc(518);\n                break;\n              case GreaterDepth:\n                gl.depthFunc(516);\n                break;\n              case NotEqualDepth:\n                gl.depthFunc(517);\n                break;\n              default:\n                gl.depthFunc(515);\n            }\n          } else {\n            gl.depthFunc(515);\n          }\n          currentDepthFunc = depthFunc;\n        }\n      },\n      setLocked: function(lock) {\n        locked = lock;\n      },\n      setClear: function(depth) {\n        if (currentDepthClear !== depth) {\n          gl.clearDepth(depth);\n          currentDepthClear = depth;\n        }\n      },\n      reset: function() {\n        locked = false;\n        currentDepthMask = null;\n        currentDepthFunc = null;\n        currentDepthClear = null;\n      }\n    };\n  }\n  function StencilBuffer() {\n    let locked = false;\n    let currentStencilMask = null;\n    let currentStencilFunc = null;\n    let currentStencilRef = null;\n    let currentStencilFuncMask = null;\n    let currentStencilFail = null;\n    let currentStencilZFail = null;\n    let currentStencilZPass = null;\n    let currentStencilClear = null;\n    return {\n      setTest: function(stencilTest) {\n        if (!locked) {\n          if (stencilTest) {\n            enable(2960);\n          } else {\n            disable(2960);\n          }\n        }\n      },\n      setMask: function(stencilMask) {\n        if (currentStencilMask !== stencilMask && !locked) {\n          gl.stencilMask(stencilMask);\n          currentStencilMask = stencilMask;\n        }\n      },\n      setFunc: function(stencilFunc, stencilRef, stencilMask) {\n        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {\n          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);\n          currentStencilFunc = stencilFunc;\n          currentStencilRef = stencilRef;\n          currentStencilFuncMask = stencilMask;\n        }\n      },\n      setOp: function(stencilFail, stencilZFail, stencilZPass) {\n        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {\n          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);\n          currentStencilFail = stencilFail;\n          currentStencilZFail = stencilZFail;\n          currentStencilZPass = stencilZPass;\n        }\n      },\n      setLocked: function(lock) {\n        locked = lock;\n      },\n      setClear: function(stencil) {\n        if (currentStencilClear !== stencil) {\n          gl.clearStencil(stencil);\n          currentStencilClear = stencil;\n        }\n      },\n      reset: function() {\n        locked = false;\n        currentStencilMask = null;\n        currentStencilFunc = null;\n        currentStencilRef = null;\n        currentStencilFuncMask = null;\n        currentStencilFail = null;\n        currentStencilZFail = null;\n        currentStencilZPass = null;\n        currentStencilClear = null;\n      }\n    };\n  }\n  const colorBuffer = new ColorBuffer();\n  const depthBuffer = new DepthBuffer();\n  const stencilBuffer = new StencilBuffer();\n  let enabledCapabilities = {};\n  let xrFramebuffer = null;\n  let currentBoundFramebuffers = {};\n  let currentProgram = null;\n  let currentBlendingEnabled = false;\n  let currentBlending = null;\n  let currentBlendEquation = null;\n  let currentBlendSrc = null;\n  let currentBlendDst = null;\n  let currentBlendEquationAlpha = null;\n  let currentBlendSrcAlpha = null;\n  let currentBlendDstAlpha = null;\n  let currentPremultipledAlpha = false;\n  let currentFlipSided = null;\n  let currentCullFace = null;\n  let currentLineWidth = null;\n  let currentPolygonOffsetFactor = null;\n  let currentPolygonOffsetUnits = null;\n  const maxTextures = gl.getParameter(35661);\n  let lineWidthAvailable = false;\n  let version = 0;\n  const glVersion = gl.getParameter(7938);\n  if (glVersion.indexOf(\"WebGL\") !== -1) {\n    version = parseFloat(/^WebGL (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 1;\n  } else if (glVersion.indexOf(\"OpenGL ES\") !== -1) {\n    version = parseFloat(/^OpenGL ES (\\d)/.exec(glVersion)[1]);\n    lineWidthAvailable = version >= 2;\n  }\n  let currentTextureSlot = null;\n  let currentBoundTextures = {};\n  const currentScissor = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);\n  const currentViewport = new Vector4(0, 0, gl.canvas.width, gl.canvas.height);\n  function createTexture(type, target, count) {\n    const data = new Uint8Array(4);\n    const texture = gl.createTexture();\n    gl.bindTexture(type, texture);\n    gl.texParameteri(type, 10241, 9728);\n    gl.texParameteri(type, 10240, 9728);\n    for (let i = 0; i < count; i++) {\n      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data);\n    }\n    return texture;\n  }\n  const emptyTextures = {};\n  emptyTextures[3553] = createTexture(3553, 3553, 1);\n  emptyTextures[34067] = createTexture(34067, 34069, 6);\n  colorBuffer.setClear(0, 0, 0, 1);\n  depthBuffer.setClear(1);\n  stencilBuffer.setClear(0);\n  enable(2929);\n  depthBuffer.setFunc(LessEqualDepth);\n  setFlipSided(false);\n  setCullFace(CullFaceBack);\n  enable(2884);\n  setBlending(NoBlending);\n  function enable(id) {\n    if (enabledCapabilities[id] !== true) {\n      gl.enable(id);\n      enabledCapabilities[id] = true;\n    }\n  }\n  function disable(id) {\n    if (enabledCapabilities[id] !== false) {\n      gl.disable(id);\n      enabledCapabilities[id] = false;\n    }\n  }\n  function bindXRFramebuffer(framebuffer) {\n    if (framebuffer !== xrFramebuffer) {\n      gl.bindFramebuffer(36160, framebuffer);\n      xrFramebuffer = framebuffer;\n    }\n  }\n  function bindFramebuffer(target, framebuffer) {\n    if (framebuffer === null && xrFramebuffer !== null)\n      framebuffer = xrFramebuffer;\n    if (currentBoundFramebuffers[target] !== framebuffer) {\n      gl.bindFramebuffer(target, framebuffer);\n      currentBoundFramebuffers[target] = framebuffer;\n      if (isWebGL2) {\n        if (target === 36009) {\n          currentBoundFramebuffers[36160] = framebuffer;\n        }\n        if (target === 36160) {\n          currentBoundFramebuffers[36009] = framebuffer;\n        }\n      }\n    }\n  }\n  function useProgram(program) {\n    if (currentProgram !== program) {\n      gl.useProgram(program);\n      currentProgram = program;\n      return true;\n    }\n    return false;\n  }\n  const equationToGL = {\n    [AddEquation]: 32774,\n    [SubtractEquation]: 32778,\n    [ReverseSubtractEquation]: 32779\n  };\n  if (isWebGL2) {\n    equationToGL[MinEquation] = 32775;\n    equationToGL[MaxEquation] = 32776;\n  } else {\n    const extension = extensions.get(\"EXT_blend_minmax\");\n    if (extension !== null) {\n      equationToGL[MinEquation] = extension.MIN_EXT;\n      equationToGL[MaxEquation] = extension.MAX_EXT;\n    }\n  }\n  const factorToGL = {\n    [ZeroFactor]: 0,\n    [OneFactor]: 1,\n    [SrcColorFactor]: 768,\n    [SrcAlphaFactor]: 770,\n    [SrcAlphaSaturateFactor]: 776,\n    [DstColorFactor]: 774,\n    [DstAlphaFactor]: 772,\n    [OneMinusSrcColorFactor]: 769,\n    [OneMinusSrcAlphaFactor]: 771,\n    [OneMinusDstColorFactor]: 775,\n    [OneMinusDstAlphaFactor]: 773\n  };\n  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {\n    if (blending === NoBlending) {\n      if (currentBlendingEnabled === true) {\n        disable(3042);\n        currentBlendingEnabled = false;\n      }\n      return;\n    }\n    if (currentBlendingEnabled === false) {\n      enable(3042);\n      currentBlendingEnabled = true;\n    }\n    if (blending !== CustomBlending) {\n      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {\n        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {\n          gl.blendEquation(32774);\n          currentBlendEquation = AddEquation;\n          currentBlendEquationAlpha = AddEquation;\n        }\n        if (premultipliedAlpha) {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(1, 771, 1, 771);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(1, 1);\n              break;\n            case SubtractiveBlending:\n              gl.blendFuncSeparate(0, 0, 769, 771);\n              break;\n            case MultiplyBlending:\n              gl.blendFuncSeparate(0, 768, 0, 770);\n              break;\n            default:\n              console.error(\"THREE.WebGLState: Invalid blending: \", blending);\n              break;\n          }\n        } else {\n          switch (blending) {\n            case NormalBlending:\n              gl.blendFuncSeparate(770, 771, 1, 771);\n              break;\n            case AdditiveBlending:\n              gl.blendFunc(770, 1);\n              break;\n            case SubtractiveBlending:\n              gl.blendFunc(0, 769);\n              break;\n            case MultiplyBlending:\n              gl.blendFunc(0, 768);\n              break;\n            default:\n              console.error(\"THREE.WebGLState: Invalid blending: \", blending);\n              break;\n          }\n        }\n        currentBlendSrc = null;\n        currentBlendDst = null;\n        currentBlendSrcAlpha = null;\n        currentBlendDstAlpha = null;\n        currentBlending = blending;\n        currentPremultipledAlpha = premultipliedAlpha;\n      }\n      return;\n    }\n    blendEquationAlpha = blendEquationAlpha || blendEquation;\n    blendSrcAlpha = blendSrcAlpha || blendSrc;\n    blendDstAlpha = blendDstAlpha || blendDst;\n    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {\n      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);\n      currentBlendEquation = blendEquation;\n      currentBlendEquationAlpha = blendEquationAlpha;\n    }\n    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {\n      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);\n      currentBlendSrc = blendSrc;\n      currentBlendDst = blendDst;\n      currentBlendSrcAlpha = blendSrcAlpha;\n      currentBlendDstAlpha = blendDstAlpha;\n    }\n    currentBlending = blending;\n    currentPremultipledAlpha = null;\n  }\n  function setMaterial(material, frontFaceCW) {\n    material.side === DoubleSide ? disable(2884) : enable(2884);\n    let flipSided = material.side === BackSide;\n    if (frontFaceCW)\n      flipSided = !flipSided;\n    setFlipSided(flipSided);\n    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);\n    depthBuffer.setFunc(material.depthFunc);\n    depthBuffer.setTest(material.depthTest);\n    depthBuffer.setMask(material.depthWrite);\n    colorBuffer.setMask(material.colorWrite);\n    const stencilWrite = material.stencilWrite;\n    stencilBuffer.setTest(stencilWrite);\n    if (stencilWrite) {\n      stencilBuffer.setMask(material.stencilWriteMask);\n      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);\n      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);\n    }\n    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);\n    material.alphaToCoverage === true ? enable(32926) : disable(32926);\n  }\n  function setFlipSided(flipSided) {\n    if (currentFlipSided !== flipSided) {\n      if (flipSided) {\n        gl.frontFace(2304);\n      } else {\n        gl.frontFace(2305);\n      }\n      currentFlipSided = flipSided;\n    }\n  }\n  function setCullFace(cullFace) {\n    if (cullFace !== CullFaceNone) {\n      enable(2884);\n      if (cullFace !== currentCullFace) {\n        if (cullFace === CullFaceBack) {\n          gl.cullFace(1029);\n        } else if (cullFace === CullFaceFront) {\n          gl.cullFace(1028);\n        } else {\n          gl.cullFace(1032);\n        }\n      }\n    } else {\n      disable(2884);\n    }\n    currentCullFace = cullFace;\n  }\n  function setLineWidth(width) {\n    if (width !== currentLineWidth) {\n      if (lineWidthAvailable)\n        gl.lineWidth(width);\n      currentLineWidth = width;\n    }\n  }\n  function setPolygonOffset(polygonOffset, factor, units) {\n    if (polygonOffset) {\n      enable(32823);\n      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {\n        gl.polygonOffset(factor, units);\n        currentPolygonOffsetFactor = factor;\n        currentPolygonOffsetUnits = units;\n      }\n    } else {\n      disable(32823);\n    }\n  }\n  function setScissorTest(scissorTest) {\n    if (scissorTest) {\n      enable(3089);\n    } else {\n      disable(3089);\n    }\n  }\n  function activeTexture(webglSlot) {\n    if (webglSlot === void 0)\n      webglSlot = 33984 + maxTextures - 1;\n    if (currentTextureSlot !== webglSlot) {\n      gl.activeTexture(webglSlot);\n      currentTextureSlot = webglSlot;\n    }\n  }\n  function bindTexture(webglType, webglTexture) {\n    if (currentTextureSlot === null) {\n      activeTexture();\n    }\n    let boundTexture = currentBoundTextures[currentTextureSlot];\n    if (boundTexture === void 0) {\n      boundTexture = {type: void 0, texture: void 0};\n      currentBoundTextures[currentTextureSlot] = boundTexture;\n    }\n    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {\n      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);\n      boundTexture.type = webglType;\n      boundTexture.texture = webglTexture;\n    }\n  }\n  function unbindTexture() {\n    const boundTexture = currentBoundTextures[currentTextureSlot];\n    if (boundTexture !== void 0 && boundTexture.type !== void 0) {\n      gl.bindTexture(boundTexture.type, null);\n      boundTexture.type = void 0;\n      boundTexture.texture = void 0;\n    }\n  }\n  function compressedTexImage2D() {\n    try {\n      gl.compressedTexImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texImage2D() {\n    try {\n      gl.texImage2D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function texImage3D() {\n    try {\n      gl.texImage3D.apply(gl, arguments);\n    } catch (error) {\n      console.error(\"THREE.WebGLState:\", error);\n    }\n  }\n  function scissor(scissor2) {\n    if (currentScissor.equals(scissor2) === false) {\n      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);\n      currentScissor.copy(scissor2);\n    }\n  }\n  function viewport(viewport2) {\n    if (currentViewport.equals(viewport2) === false) {\n      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);\n      currentViewport.copy(viewport2);\n    }\n  }\n  function reset() {\n    gl.disable(3042);\n    gl.disable(2884);\n    gl.disable(2929);\n    gl.disable(32823);\n    gl.disable(3089);\n    gl.disable(2960);\n    gl.disable(32926);\n    gl.blendEquation(32774);\n    gl.blendFunc(1, 0);\n    gl.blendFuncSeparate(1, 0, 1, 0);\n    gl.colorMask(true, true, true, true);\n    gl.clearColor(0, 0, 0, 0);\n    gl.depthMask(true);\n    gl.depthFunc(513);\n    gl.clearDepth(1);\n    gl.stencilMask(4294967295);\n    gl.stencilFunc(519, 0, 4294967295);\n    gl.stencilOp(7680, 7680, 7680);\n    gl.clearStencil(0);\n    gl.cullFace(1029);\n    gl.frontFace(2305);\n    gl.polygonOffset(0, 0);\n    gl.activeTexture(33984);\n    gl.bindFramebuffer(36160, null);\n    if (isWebGL2 === true) {\n      gl.bindFramebuffer(36009, null);\n      gl.bindFramebuffer(36008, null);\n    }\n    gl.useProgram(null);\n    gl.lineWidth(1);\n    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n    enabledCapabilities = {};\n    currentTextureSlot = null;\n    currentBoundTextures = {};\n    xrFramebuffer = null;\n    currentBoundFramebuffers = {};\n    currentProgram = null;\n    currentBlendingEnabled = false;\n    currentBlending = null;\n    currentBlendEquation = null;\n    currentBlendSrc = null;\n    currentBlendDst = null;\n    currentBlendEquationAlpha = null;\n    currentBlendSrcAlpha = null;\n    currentBlendDstAlpha = null;\n    currentPremultipledAlpha = false;\n    currentFlipSided = null;\n    currentCullFace = null;\n    currentLineWidth = null;\n    currentPolygonOffsetFactor = null;\n    currentPolygonOffsetUnits = null;\n    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);\n    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);\n    colorBuffer.reset();\n    depthBuffer.reset();\n    stencilBuffer.reset();\n  }\n  return {\n    buffers: {\n      color: colorBuffer,\n      depth: depthBuffer,\n      stencil: stencilBuffer\n    },\n    enable,\n    disable,\n    bindFramebuffer,\n    bindXRFramebuffer,\n    useProgram,\n    setBlending,\n    setMaterial,\n    setFlipSided,\n    setCullFace,\n    setLineWidth,\n    setPolygonOffset,\n    setScissorTest,\n    activeTexture,\n    bindTexture,\n    unbindTexture,\n    compressedTexImage2D,\n    texImage2D,\n    texImage3D,\n    scissor,\n    viewport,\n    reset\n  };\n}\nfunction WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {\n  const isWebGL2 = capabilities.isWebGL2;\n  const maxTextures = capabilities.maxTextures;\n  const maxCubemapSize = capabilities.maxCubemapSize;\n  const maxTextureSize = capabilities.maxTextureSize;\n  const maxSamples = capabilities.maxSamples;\n  const _videoTextures = new WeakMap();\n  let _canvas2;\n  let useOffscreenCanvas = false;\n  try {\n    useOffscreenCanvas = typeof OffscreenCanvas !== \"undefined\" && new OffscreenCanvas(1, 1).getContext(\"2d\") !== null;\n  } catch (err) {\n  }\n  function createCanvas(width, height) {\n    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n  }\n  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {\n    let scale = 1;\n    if (image.width > maxSize || image.height > maxSize) {\n      scale = maxSize / Math.max(image.width, image.height);\n    }\n    if (scale < 1 || needsPowerOfTwo === true) {\n      if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor;\n        const width = floor(scale * image.width);\n        const height = floor(scale * image.height);\n        if (_canvas2 === void 0)\n          _canvas2 = createCanvas(width, height);\n        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;\n        canvas.width = width;\n        canvas.height = height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0, width, height);\n        console.warn(\"THREE.WebGLRenderer: Texture has been resized from (\" + image.width + \"x\" + image.height + \") to (\" + width + \"x\" + height + \").\");\n        return canvas;\n      } else {\n        if (\"data\" in image) {\n          console.warn(\"THREE.WebGLRenderer: Image in DataTexture is too big (\" + image.width + \"x\" + image.height + \").\");\n        }\n        return image;\n      }\n    }\n    return image;\n  }\n  function isPowerOfTwo$1(image) {\n    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height);\n  }\n  function textureNeedsPowerOfTwo(texture) {\n    if (isWebGL2)\n      return false;\n    return texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping || texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n  function textureNeedsGenerateMipmaps(texture, supportsMips) {\n    return texture.generateMipmaps && supportsMips && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;\n  }\n  function generateMipmap(target, texture, width, height) {\n    _gl.generateMipmap(target);\n    const textureProperties = properties.get(texture);\n    textureProperties.__maxMipLevel = Math.log2(Math.max(width, height));\n  }\n  function getInternalFormat(internalFormatName, glFormat, glType) {\n    if (isWebGL2 === false)\n      return glFormat;\n    if (internalFormatName !== null) {\n      if (_gl[internalFormatName] !== void 0)\n        return _gl[internalFormatName];\n      console.warn(\"THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '\" + internalFormatName + \"'\");\n    }\n    let internalFormat = glFormat;\n    if (glFormat === 6403) {\n      if (glType === 5126)\n        internalFormat = 33326;\n      if (glType === 5131)\n        internalFormat = 33325;\n      if (glType === 5121)\n        internalFormat = 33321;\n    }\n    if (glFormat === 6407) {\n      if (glType === 5126)\n        internalFormat = 34837;\n      if (glType === 5131)\n        internalFormat = 34843;\n      if (glType === 5121)\n        internalFormat = 32849;\n    }\n    if (glFormat === 6408) {\n      if (glType === 5126)\n        internalFormat = 34836;\n      if (glType === 5131)\n        internalFormat = 34842;\n      if (glType === 5121)\n        internalFormat = 32856;\n    }\n    if (internalFormat === 33325 || internalFormat === 33326 || internalFormat === 34842 || internalFormat === 34836) {\n      extensions.get(\"EXT_color_buffer_float\");\n    }\n    return internalFormat;\n  }\n  function filterFallback(f) {\n    if (f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter) {\n      return 9728;\n    }\n    return 9729;\n  }\n  function onTextureDispose(event) {\n    const texture = event.target;\n    texture.removeEventListener(\"dispose\", onTextureDispose);\n    deallocateTexture(texture);\n    if (texture.isVideoTexture) {\n      _videoTextures.delete(texture);\n    }\n    info.memory.textures--;\n  }\n  function onRenderTargetDispose(event) {\n    const renderTarget = event.target;\n    renderTarget.removeEventListener(\"dispose\", onRenderTargetDispose);\n    deallocateRenderTarget(renderTarget);\n    info.memory.textures--;\n  }\n  function deallocateTexture(texture) {\n    const textureProperties = properties.get(texture);\n    if (textureProperties.__webglInit === void 0)\n      return;\n    _gl.deleteTexture(textureProperties.__webglTexture);\n    properties.remove(texture);\n  }\n  function deallocateRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    if (!renderTarget)\n      return;\n    if (textureProperties.__webglTexture !== void 0) {\n      _gl.deleteTexture(textureProperties.__webglTexture);\n    }\n    if (renderTarget.depthTexture) {\n      renderTarget.depthTexture.dispose();\n    }\n    if (renderTarget.isWebGLCubeRenderTarget) {\n      for (let i = 0; i < 6; i++) {\n        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i]);\n        if (renderTargetProperties.__webglDepthbuffer)\n          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i]);\n      }\n    } else {\n      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);\n      if (renderTargetProperties.__webglDepthbuffer)\n        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);\n      if (renderTargetProperties.__webglMultisampledFramebuffer)\n        _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);\n      if (renderTargetProperties.__webglColorRenderbuffer)\n        _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer);\n      if (renderTargetProperties.__webglDepthRenderbuffer)\n        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);\n    }\n    properties.remove(texture);\n    properties.remove(renderTarget);\n  }\n  let textureUnits = 0;\n  function resetTextureUnits() {\n    textureUnits = 0;\n  }\n  function allocateTextureUnit() {\n    const textureUnit = textureUnits;\n    if (textureUnit >= maxTextures) {\n      console.warn(\"THREE.WebGLTextures: Trying to use \" + textureUnit + \" texture units while this GPU supports only \" + maxTextures);\n    }\n    textureUnits += 1;\n    return textureUnit;\n  }\n  function setTexture2D(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.isVideoTexture)\n      updateVideoTexture(texture);\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      const image = texture.image;\n      if (image === void 0) {\n        console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is undefined\");\n      } else if (image.complete === false) {\n        console.warn(\"THREE.WebGLRenderer: Texture marked for update but image is incomplete\");\n      } else {\n        uploadTexture(textureProperties, texture, slot);\n        return;\n      }\n    }\n    state.activeTexture(33984 + slot);\n    state.bindTexture(3553, textureProperties.__webglTexture);\n  }\n  function setTexture2DArray(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n    state.activeTexture(33984 + slot);\n    state.bindTexture(35866, textureProperties.__webglTexture);\n  }\n  function setTexture3D(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadTexture(textureProperties, texture, slot);\n      return;\n    }\n    state.activeTexture(33984 + slot);\n    state.bindTexture(32879, textureProperties.__webglTexture);\n  }\n  function setTextureCube(texture, slot) {\n    const textureProperties = properties.get(texture);\n    if (texture.version > 0 && textureProperties.__version !== texture.version) {\n      uploadCubeTexture(textureProperties, texture, slot);\n      return;\n    }\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n  }\n  const wrappingToGL = {\n    [RepeatWrapping]: 10497,\n    [ClampToEdgeWrapping]: 33071,\n    [MirroredRepeatWrapping]: 33648\n  };\n  const filterToGL = {\n    [NearestFilter]: 9728,\n    [NearestMipmapNearestFilter]: 9984,\n    [NearestMipmapLinearFilter]: 9986,\n    [LinearFilter]: 9729,\n    [LinearMipmapNearestFilter]: 9985,\n    [LinearMipmapLinearFilter]: 9987\n  };\n  function setTextureParameters(textureType, texture, supportsMips) {\n    if (supportsMips) {\n      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS]);\n      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT]);\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR]);\n      }\n      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter]);\n      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter]);\n    } else {\n      _gl.texParameteri(textureType, 10242, 33071);\n      _gl.texParameteri(textureType, 10243, 33071);\n      if (textureType === 32879 || textureType === 35866) {\n        _gl.texParameteri(textureType, 32882, 33071);\n      }\n      if (texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping) {\n        console.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.\");\n      }\n      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter));\n      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter));\n      if (texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {\n        console.warn(\"THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.\");\n      }\n    }\n    if (extensions.has(\"EXT_texture_filter_anisotropic\") === true) {\n      const extension = extensions.get(\"EXT_texture_filter_anisotropic\");\n      if (texture.type === FloatType && extensions.has(\"OES_texture_float_linear\") === false)\n        return;\n      if (isWebGL2 === false && (texture.type === HalfFloatType && extensions.has(\"OES_texture_half_float_linear\") === false))\n        return;\n      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {\n        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));\n        properties.get(texture).__currentAnisotropy = texture.anisotropy;\n      }\n    }\n  }\n  function initTexture(textureProperties, texture) {\n    if (textureProperties.__webglInit === void 0) {\n      textureProperties.__webglInit = true;\n      texture.addEventListener(\"dispose\", onTextureDispose);\n      textureProperties.__webglTexture = _gl.createTexture();\n      info.memory.textures++;\n    }\n  }\n  function uploadTexture(textureProperties, texture, slot) {\n    let textureType = 3553;\n    if (texture.isDataTexture2DArray)\n      textureType = 35866;\n    if (texture.isDataTexture3D)\n      textureType = 32879;\n    initTexture(textureProperties, texture);\n    state.activeTexture(33984 + slot);\n    state.bindTexture(textureType, textureProperties.__webglTexture);\n    _gl.pixelStorei(37440, texture.flipY);\n    _gl.pixelStorei(37441, texture.premultiplyAlpha);\n    _gl.pixelStorei(3317, texture.unpackAlignment);\n    _gl.pixelStorei(37443, 0);\n    const needsPowerOfTwo = textureNeedsPowerOfTwo(texture) && isPowerOfTwo$1(texture.image) === false;\n    const image = resizeImage(texture.image, needsPowerOfTwo, false, maxTextureSize);\n    const supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format);\n    let glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n    setTextureParameters(textureType, texture, supportsMips);\n    let mipmap;\n    const mipmaps = texture.mipmaps;\n    if (texture.isDepthTexture) {\n      glInternalFormat = 6402;\n      if (isWebGL2) {\n        if (texture.type === FloatType) {\n          glInternalFormat = 36012;\n        } else if (texture.type === UnsignedIntType) {\n          glInternalFormat = 33190;\n        } else if (texture.type === UnsignedInt248Type) {\n          glInternalFormat = 35056;\n        } else {\n          glInternalFormat = 33189;\n        }\n      } else {\n        if (texture.type === FloatType) {\n          console.error(\"WebGLRenderer: Floating point depth texture requires WebGL2.\");\n        }\n      }\n      if (texture.format === DepthFormat && glInternalFormat === 6402) {\n        if (texture.type !== UnsignedShortType && texture.type !== UnsignedIntType) {\n          console.warn(\"THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.\");\n          texture.type = UnsignedShortType;\n          glType = utils.convert(texture.type);\n        }\n      }\n      if (texture.format === DepthStencilFormat && glInternalFormat === 6402) {\n        glInternalFormat = 34041;\n        if (texture.type !== UnsignedInt248Type) {\n          console.warn(\"THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.\");\n          texture.type = UnsignedInt248Type;\n          glType = utils.convert(texture.type);\n        }\n      }\n      state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);\n    } else if (texture.isDataTexture) {\n      if (mipmaps.length > 0 && supportsMips) {\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n        }\n        texture.generateMipmaps = false;\n        textureProperties.__maxMipLevel = mipmaps.length - 1;\n      } else {\n        state.texImage2D(3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);\n        textureProperties.__maxMipLevel = 0;\n      }\n    } else if (texture.isCompressedTexture) {\n      for (let i = 0, il = mipmaps.length; i < il; i++) {\n        mipmap = mipmaps[i];\n        if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n          if (glFormat !== null) {\n            state.compressedTexImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n          } else {\n            console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\");\n          }\n        } else {\n          state.texImage2D(3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n        }\n      }\n      textureProperties.__maxMipLevel = mipmaps.length - 1;\n    } else if (texture.isDataTexture2DArray) {\n      state.texImage3D(35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n      textureProperties.__maxMipLevel = 0;\n    } else if (texture.isDataTexture3D) {\n      state.texImage3D(32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);\n      textureProperties.__maxMipLevel = 0;\n    } else {\n      if (mipmaps.length > 0 && supportsMips) {\n        for (let i = 0, il = mipmaps.length; i < il; i++) {\n          mipmap = mipmaps[i];\n          state.texImage2D(3553, i, glInternalFormat, glFormat, glType, mipmap);\n        }\n        texture.generateMipmaps = false;\n        textureProperties.__maxMipLevel = mipmaps.length - 1;\n      } else {\n        state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image);\n        textureProperties.__maxMipLevel = 0;\n      }\n    }\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      generateMipmap(textureType, texture, image.width, image.height);\n    }\n    textureProperties.__version = texture.version;\n    if (texture.onUpdate)\n      texture.onUpdate(texture);\n  }\n  function uploadCubeTexture(textureProperties, texture, slot) {\n    if (texture.image.length !== 6)\n      return;\n    initTexture(textureProperties, texture);\n    state.activeTexture(33984 + slot);\n    state.bindTexture(34067, textureProperties.__webglTexture);\n    _gl.pixelStorei(37440, texture.flipY);\n    _gl.pixelStorei(37441, texture.premultiplyAlpha);\n    _gl.pixelStorei(3317, texture.unpackAlignment);\n    _gl.pixelStorei(37443, 0);\n    const isCompressed = texture && (texture.isCompressedTexture || texture.image[0].isCompressedTexture);\n    const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;\n    const cubeImage = [];\n    for (let i = 0; i < 6; i++) {\n      if (!isCompressed && !isDataTexture) {\n        cubeImage[i] = resizeImage(texture.image[i], false, true, maxCubemapSize);\n      } else {\n        cubeImage[i] = isDataTexture ? texture.image[i].image : texture.image[i];\n      }\n    }\n    const image = cubeImage[0], supportsMips = isPowerOfTwo$1(image) || isWebGL2, glFormat = utils.convert(texture.format), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n    setTextureParameters(34067, texture, supportsMips);\n    let mipmaps;\n    if (isCompressed) {\n      for (let i = 0; i < 6; i++) {\n        mipmaps = cubeImage[i].mipmaps;\n        for (let j = 0; j < mipmaps.length; j++) {\n          const mipmap = mipmaps[j];\n          if (texture.format !== RGBAFormat && texture.format !== RGBFormat) {\n            if (glFormat !== null) {\n              state.compressedTexImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);\n            } else {\n              console.warn(\"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\");\n            }\n          } else {\n            state.texImage2D(34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);\n          }\n        }\n      }\n      textureProperties.__maxMipLevel = mipmaps.length - 1;\n    } else {\n      mipmaps = texture.mipmaps;\n      for (let i = 0; i < 6; i++) {\n        if (isDataTexture) {\n          state.texImage2D(34069 + i, 0, glInternalFormat, cubeImage[i].width, cubeImage[i].height, 0, glFormat, glType, cubeImage[i].data);\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            const mipmapImage = mipmap.image[i].image;\n            state.texImage2D(34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);\n          }\n        } else {\n          state.texImage2D(34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[i]);\n          for (let j = 0; j < mipmaps.length; j++) {\n            const mipmap = mipmaps[j];\n            state.texImage2D(34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[i]);\n          }\n        }\n      }\n      textureProperties.__maxMipLevel = mipmaps.length;\n    }\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      generateMipmap(34067, texture, image.width, image.height);\n    }\n    textureProperties.__version = texture.version;\n    if (texture.onUpdate)\n      texture.onUpdate(texture);\n  }\n  function setupFrameBufferTexture(framebuffer, renderTarget, attachment, textureTarget) {\n    const texture = renderTarget.texture;\n    const glFormat = utils.convert(texture.format);\n    const glType = utils.convert(texture.type);\n    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n    if (textureTarget === 32879 || textureTarget === 35866) {\n      state.texImage3D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null);\n    } else {\n      state.texImage2D(textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);\n    }\n    state.bindFramebuffer(36160, framebuffer);\n    _gl.framebufferTexture2D(36160, attachment, textureTarget, properties.get(texture).__webglTexture, 0);\n    state.bindFramebuffer(36160, null);\n  }\n  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {\n    _gl.bindRenderbuffer(36161, renderbuffer);\n    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {\n      let glInternalFormat = 33189;\n      if (isMultisample) {\n        const depthTexture = renderTarget.depthTexture;\n        if (depthTexture && depthTexture.isDepthTexture) {\n          if (depthTexture.type === FloatType) {\n            glInternalFormat = 36012;\n          } else if (depthTexture.type === UnsignedIntType) {\n            glInternalFormat = 33190;\n          }\n        }\n        const samples = getRenderTargetSamples(renderTarget);\n        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer);\n    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {\n      if (isMultisample) {\n        const samples = getRenderTargetSamples(renderTarget);\n        _gl.renderbufferStorageMultisample(36161, samples, 35056, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(36161, 34041, renderTarget.width, renderTarget.height);\n      }\n      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer);\n    } else {\n      const texture = renderTarget.texture;\n      const glFormat = utils.convert(texture.format);\n      const glType = utils.convert(texture.type);\n      const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n      if (isMultisample) {\n        const samples = getRenderTargetSamples(renderTarget);\n        _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n      } else {\n        _gl.renderbufferStorage(36161, glInternalFormat, renderTarget.width, renderTarget.height);\n      }\n    }\n    _gl.bindRenderbuffer(36161, null);\n  }\n  function setupDepthTexture(framebuffer, renderTarget) {\n    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget;\n    if (isCube)\n      throw new Error(\"Depth Texture with cube render targets is not supported\");\n    state.bindFramebuffer(36160, framebuffer);\n    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {\n      throw new Error(\"renderTarget.depthTexture must be an instance of THREE.DepthTexture\");\n    }\n    if (!properties.get(renderTarget.depthTexture).__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {\n      renderTarget.depthTexture.image.width = renderTarget.width;\n      renderTarget.depthTexture.image.height = renderTarget.height;\n      renderTarget.depthTexture.needsUpdate = true;\n    }\n    setTexture2D(renderTarget.depthTexture, 0);\n    const webglDepthTexture = properties.get(renderTarget.depthTexture).__webglTexture;\n    if (renderTarget.depthTexture.format === DepthFormat) {\n      _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0);\n    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {\n      _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0);\n    } else {\n      throw new Error(\"Unknown depthTexture format\");\n    }\n  }\n  function setupDepthRenderbuffer(renderTarget) {\n    const renderTargetProperties = properties.get(renderTarget);\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    if (renderTarget.depthTexture) {\n      if (isCube)\n        throw new Error(\"target.depthTexture not supported in Cube render targets\");\n      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget);\n    } else {\n      if (isCube) {\n        renderTargetProperties.__webglDepthbuffer = [];\n        for (let i = 0; i < 6; i++) {\n          state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer[i]);\n          renderTargetProperties.__webglDepthbuffer[i] = _gl.createRenderbuffer();\n          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i], renderTarget, false);\n        }\n      } else {\n        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer);\n        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\n        setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);\n      }\n    }\n    state.bindFramebuffer(36160, null);\n  }\n  function setupRenderTarget(renderTarget) {\n    const texture = renderTarget.texture;\n    const renderTargetProperties = properties.get(renderTarget);\n    const textureProperties = properties.get(texture);\n    renderTarget.addEventListener(\"dispose\", onRenderTargetDispose);\n    textureProperties.__webglTexture = _gl.createTexture();\n    textureProperties.__version = texture.version;\n    info.memory.textures++;\n    const isCube = renderTarget.isWebGLCubeRenderTarget === true;\n    const isMultisample = renderTarget.isWebGLMultisampleRenderTarget === true;\n    const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;\n    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n    if (isWebGL2 && texture.format === RGBFormat && (texture.type === FloatType || texture.type === HalfFloatType)) {\n      texture.format = RGBAFormat;\n      console.warn(\"THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.\");\n    }\n    if (isCube) {\n      renderTargetProperties.__webglFramebuffer = [];\n      for (let i = 0; i < 6; i++) {\n        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer();\n      }\n    } else {\n      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\n      if (isMultisample) {\n        if (isWebGL2) {\n          renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();\n          renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();\n          _gl.bindRenderbuffer(36161, renderTargetProperties.__webglColorRenderbuffer);\n          const glFormat = utils.convert(texture.format);\n          const glType = utils.convert(texture.type);\n          const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType);\n          const samples = getRenderTargetSamples(renderTarget);\n          _gl.renderbufferStorageMultisample(36161, samples, glInternalFormat, renderTarget.width, renderTarget.height);\n          state.bindFramebuffer(36160, renderTargetProperties.__webglMultisampledFramebuffer);\n          _gl.framebufferRenderbuffer(36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer);\n          _gl.bindRenderbuffer(36161, null);\n          if (renderTarget.depthBuffer) {\n            renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();\n            setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);\n          }\n          state.bindFramebuffer(36160, null);\n        } else {\n          console.warn(\"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.\");\n        }\n      }\n    }\n    if (isCube) {\n      state.bindTexture(34067, textureProperties.__webglTexture);\n      setTextureParameters(34067, texture, supportsMips);\n      for (let i = 0; i < 6; i++) {\n        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i], renderTarget, 36064, 34069 + i);\n      }\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(34067, texture, renderTarget.width, renderTarget.height);\n      }\n      state.bindTexture(34067, null);\n    } else {\n      let glTextureType = 3553;\n      if (isRenderTarget3D) {\n        if (isWebGL2) {\n          const isTexture3D = texture.isDataTexture3D;\n          glTextureType = isTexture3D ? 32879 : 35866;\n        } else {\n          console.warn(\"THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.\");\n        }\n      }\n      state.bindTexture(glTextureType, textureProperties.__webglTexture);\n      setTextureParameters(glTextureType, texture, supportsMips);\n      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType);\n      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n        generateMipmap(3553, texture, renderTarget.width, renderTarget.height);\n      }\n      state.bindTexture(3553, null);\n    }\n    if (renderTarget.depthBuffer) {\n      setupDepthRenderbuffer(renderTarget);\n    }\n  }\n  function updateRenderTargetMipmap(renderTarget) {\n    const texture = renderTarget.texture;\n    const supportsMips = isPowerOfTwo$1(renderTarget) || isWebGL2;\n    if (textureNeedsGenerateMipmaps(texture, supportsMips)) {\n      const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;\n      const webglTexture = properties.get(texture).__webglTexture;\n      state.bindTexture(target, webglTexture);\n      generateMipmap(target, texture, renderTarget.width, renderTarget.height);\n      state.bindTexture(target, null);\n    }\n  }\n  function updateMultisampleRenderTarget(renderTarget) {\n    if (renderTarget.isWebGLMultisampleRenderTarget) {\n      if (isWebGL2) {\n        const width = renderTarget.width;\n        const height = renderTarget.height;\n        let mask = 16384;\n        if (renderTarget.depthBuffer)\n          mask |= 256;\n        if (renderTarget.stencilBuffer)\n          mask |= 1024;\n        const renderTargetProperties = properties.get(renderTarget);\n        state.bindFramebuffer(36008, renderTargetProperties.__webglMultisampledFramebuffer);\n        state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer);\n        _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, 9728);\n        state.bindFramebuffer(36008, null);\n        state.bindFramebuffer(36009, renderTargetProperties.__webglMultisampledFramebuffer);\n      } else {\n        console.warn(\"THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.\");\n      }\n    }\n  }\n  function getRenderTargetSamples(renderTarget) {\n    return isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ? Math.min(maxSamples, renderTarget.samples) : 0;\n  }\n  function updateVideoTexture(texture) {\n    const frame = info.render.frame;\n    if (_videoTextures.get(texture) !== frame) {\n      _videoTextures.set(texture, frame);\n      texture.update();\n    }\n  }\n  let warnedTexture2D = false;\n  let warnedTextureCube = false;\n  function safeSetTexture2D(texture, slot) {\n    if (texture && texture.isWebGLRenderTarget) {\n      if (warnedTexture2D === false) {\n        console.warn(\"THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead.\");\n        warnedTexture2D = true;\n      }\n      texture = texture.texture;\n    }\n    setTexture2D(texture, slot);\n  }\n  function safeSetTextureCube(texture, slot) {\n    if (texture && texture.isWebGLCubeRenderTarget) {\n      if (warnedTextureCube === false) {\n        console.warn(\"THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead.\");\n        warnedTextureCube = true;\n      }\n      texture = texture.texture;\n    }\n    setTextureCube(texture, slot);\n  }\n  this.allocateTextureUnit = allocateTextureUnit;\n  this.resetTextureUnits = resetTextureUnits;\n  this.setTexture2D = setTexture2D;\n  this.setTexture2DArray = setTexture2DArray;\n  this.setTexture3D = setTexture3D;\n  this.setTextureCube = setTextureCube;\n  this.setupRenderTarget = setupRenderTarget;\n  this.updateRenderTargetMipmap = updateRenderTargetMipmap;\n  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;\n  this.safeSetTexture2D = safeSetTexture2D;\n  this.safeSetTextureCube = safeSetTextureCube;\n}\nfunction WebGLUtils(gl, extensions, capabilities) {\n  const isWebGL2 = capabilities.isWebGL2;\n  function convert(p) {\n    let extension;\n    if (p === UnsignedByteType)\n      return 5121;\n    if (p === UnsignedShort4444Type)\n      return 32819;\n    if (p === UnsignedShort5551Type)\n      return 32820;\n    if (p === UnsignedShort565Type)\n      return 33635;\n    if (p === ByteType)\n      return 5120;\n    if (p === ShortType)\n      return 5122;\n    if (p === UnsignedShortType)\n      return 5123;\n    if (p === IntType)\n      return 5124;\n    if (p === UnsignedIntType)\n      return 5125;\n    if (p === FloatType)\n      return 5126;\n    if (p === HalfFloatType) {\n      if (isWebGL2)\n        return 5131;\n      extension = extensions.get(\"OES_texture_half_float\");\n      if (extension !== null) {\n        return extension.HALF_FLOAT_OES;\n      } else {\n        return null;\n      }\n    }\n    if (p === AlphaFormat)\n      return 6406;\n    if (p === RGBFormat)\n      return 6407;\n    if (p === RGBAFormat)\n      return 6408;\n    if (p === LuminanceFormat)\n      return 6409;\n    if (p === LuminanceAlphaFormat)\n      return 6410;\n    if (p === DepthFormat)\n      return 6402;\n    if (p === DepthStencilFormat)\n      return 34041;\n    if (p === RedFormat)\n      return 6403;\n    if (p === RedIntegerFormat)\n      return 36244;\n    if (p === RGFormat)\n      return 33319;\n    if (p === RGIntegerFormat)\n      return 33320;\n    if (p === RGBIntegerFormat)\n      return 36248;\n    if (p === RGBAIntegerFormat)\n      return 36249;\n    if (p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format || p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_s3tc\");\n      if (extension !== null) {\n        if (p === RGB_S3TC_DXT1_Format)\n          return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\n        if (p === RGBA_S3TC_DXT1_Format)\n          return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\n        if (p === RGBA_S3TC_DXT3_Format)\n          return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\n        if (p === RGBA_S3TC_DXT5_Format)\n          return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\n      } else {\n        return null;\n      }\n    }\n    if (p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format || p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_pvrtc\");\n      if (extension !== null) {\n        if (p === RGB_PVRTC_4BPPV1_Format)\n          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\n        if (p === RGB_PVRTC_2BPPV1_Format)\n          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\n        if (p === RGBA_PVRTC_4BPPV1_Format)\n          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\n        if (p === RGBA_PVRTC_2BPPV1_Format)\n          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\n      } else {\n        return null;\n      }\n    }\n    if (p === RGB_ETC1_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_etc1\");\n      if (extension !== null) {\n        return extension.COMPRESSED_RGB_ETC1_WEBGL;\n      } else {\n        return null;\n      }\n    }\n    if (p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_etc\");\n      if (extension !== null) {\n        if (p === RGB_ETC2_Format)\n          return extension.COMPRESSED_RGB8_ETC2;\n        if (p === RGBA_ETC2_EAC_Format)\n          return extension.COMPRESSED_RGBA8_ETC2_EAC;\n      }\n    }\n    if (p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format || p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format || p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format || p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format || p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format || p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format || p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format || p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format || p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format || p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format) {\n      extension = extensions.get(\"WEBGL_compressed_texture_astc\");\n      if (extension !== null) {\n        return p;\n      } else {\n        return null;\n      }\n    }\n    if (p === RGBA_BPTC_Format) {\n      extension = extensions.get(\"EXT_texture_compression_bptc\");\n      if (extension !== null) {\n        return p;\n      } else {\n        return null;\n      }\n    }\n    if (p === UnsignedInt248Type) {\n      if (isWebGL2)\n        return 34042;\n      extension = extensions.get(\"WEBGL_depth_texture\");\n      if (extension !== null) {\n        return extension.UNSIGNED_INT_24_8_WEBGL;\n      } else {\n        return null;\n      }\n    }\n  }\n  return {convert};\n}\nclass ArrayCamera extends PerspectiveCamera {\n  constructor(array = []) {\n    super();\n    this.cameras = array;\n  }\n}\nArrayCamera.prototype.isArrayCamera = true;\nclass Group extends Object3D {\n  constructor() {\n    super();\n    this.type = \"Group\";\n  }\n}\nGroup.prototype.isGroup = true;\nconst _moveEvent = {type: \"move\"};\nclass WebXRController {\n  constructor() {\n    this._targetRay = null;\n    this._grip = null;\n    this._hand = null;\n  }\n  getHandSpace() {\n    if (this._hand === null) {\n      this._hand = new Group();\n      this._hand.matrixAutoUpdate = false;\n      this._hand.visible = false;\n      this._hand.joints = {};\n      this._hand.inputState = {pinching: false};\n    }\n    return this._hand;\n  }\n  getTargetRaySpace() {\n    if (this._targetRay === null) {\n      this._targetRay = new Group();\n      this._targetRay.matrixAutoUpdate = false;\n      this._targetRay.visible = false;\n      this._targetRay.hasLinearVelocity = false;\n      this._targetRay.linearVelocity = new Vector3();\n      this._targetRay.hasAngularVelocity = false;\n      this._targetRay.angularVelocity = new Vector3();\n    }\n    return this._targetRay;\n  }\n  getGripSpace() {\n    if (this._grip === null) {\n      this._grip = new Group();\n      this._grip.matrixAutoUpdate = false;\n      this._grip.visible = false;\n      this._grip.hasLinearVelocity = false;\n      this._grip.linearVelocity = new Vector3();\n      this._grip.hasAngularVelocity = false;\n      this._grip.angularVelocity = new Vector3();\n    }\n    return this._grip;\n  }\n  dispatchEvent(event) {\n    if (this._targetRay !== null) {\n      this._targetRay.dispatchEvent(event);\n    }\n    if (this._grip !== null) {\n      this._grip.dispatchEvent(event);\n    }\n    if (this._hand !== null) {\n      this._hand.dispatchEvent(event);\n    }\n    return this;\n  }\n  disconnect(inputSource) {\n    this.dispatchEvent({type: \"disconnected\", data: inputSource});\n    if (this._targetRay !== null) {\n      this._targetRay.visible = false;\n    }\n    if (this._grip !== null) {\n      this._grip.visible = false;\n    }\n    if (this._hand !== null) {\n      this._hand.visible = false;\n    }\n    return this;\n  }\n  update(inputSource, frame, referenceSpace) {\n    let inputPose = null;\n    let gripPose = null;\n    let handPose = null;\n    const targetRay = this._targetRay;\n    const grip = this._grip;\n    const hand = this._hand;\n    if (inputSource && frame.session.visibilityState !== \"visible-blurred\") {\n      if (targetRay !== null) {\n        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);\n        if (inputPose !== null) {\n          targetRay.matrix.fromArray(inputPose.transform.matrix);\n          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);\n          if (inputPose.linearVelocity) {\n            targetRay.hasLinearVelocity = true;\n            targetRay.linearVelocity.copy(inputPose.linearVelocity);\n          } else {\n            targetRay.hasLinearVelocity = false;\n          }\n          if (inputPose.angularVelocity) {\n            targetRay.hasAngularVelocity = true;\n            targetRay.angularVelocity.copy(inputPose.angularVelocity);\n          } else {\n            targetRay.hasAngularVelocity = false;\n          }\n          this.dispatchEvent(_moveEvent);\n        }\n      }\n      if (hand && inputSource.hand) {\n        handPose = true;\n        for (const inputjoint of inputSource.hand.values()) {\n          const jointPose = frame.getJointPose(inputjoint, referenceSpace);\n          if (hand.joints[inputjoint.jointName] === void 0) {\n            const joint2 = new Group();\n            joint2.matrixAutoUpdate = false;\n            joint2.visible = false;\n            hand.joints[inputjoint.jointName] = joint2;\n            hand.add(joint2);\n          }\n          const joint = hand.joints[inputjoint.jointName];\n          if (jointPose !== null) {\n            joint.matrix.fromArray(jointPose.transform.matrix);\n            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);\n            joint.jointRadius = jointPose.radius;\n          }\n          joint.visible = jointPose !== null;\n        }\n        const indexTip = hand.joints[\"index-finger-tip\"];\n        const thumbTip = hand.joints[\"thumb-tip\"];\n        const distance = indexTip.position.distanceTo(thumbTip.position);\n        const distanceToPinch = 0.02;\n        const threshold = 5e-3;\n        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {\n          hand.inputState.pinching = false;\n          this.dispatchEvent({\n            type: \"pinchend\",\n            handedness: inputSource.handedness,\n            target: this\n          });\n        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {\n          hand.inputState.pinching = true;\n          this.dispatchEvent({\n            type: \"pinchstart\",\n            handedness: inputSource.handedness,\n            target: this\n          });\n        }\n      } else {\n        if (grip !== null && inputSource.gripSpace) {\n          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);\n          if (gripPose !== null) {\n            grip.matrix.fromArray(gripPose.transform.matrix);\n            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);\n            if (gripPose.linearVelocity) {\n              grip.hasLinearVelocity = true;\n              grip.linearVelocity.copy(gripPose.linearVelocity);\n            } else {\n              grip.hasLinearVelocity = false;\n            }\n            if (gripPose.angularVelocity) {\n              grip.hasAngularVelocity = true;\n              grip.angularVelocity.copy(gripPose.angularVelocity);\n            } else {\n              grip.hasAngularVelocity = false;\n            }\n          }\n        }\n      }\n    }\n    if (targetRay !== null) {\n      targetRay.visible = inputPose !== null;\n    }\n    if (grip !== null) {\n      grip.visible = gripPose !== null;\n    }\n    if (hand !== null) {\n      hand.visible = handPose !== null;\n    }\n    return this;\n  }\n}\nclass WebXRManager extends EventDispatcher {\n  constructor(renderer, gl) {\n    super();\n    const scope = this;\n    const state = renderer.state;\n    let session = null;\n    let framebufferScaleFactor = 1;\n    let referenceSpace = null;\n    let referenceSpaceType = \"local-floor\";\n    let pose = null;\n    const controllers = [];\n    const inputSourcesMap = new Map();\n    const cameraL = new PerspectiveCamera();\n    cameraL.layers.enable(1);\n    cameraL.viewport = new Vector4();\n    const cameraR = new PerspectiveCamera();\n    cameraR.layers.enable(2);\n    cameraR.viewport = new Vector4();\n    const cameras = [cameraL, cameraR];\n    const cameraVR = new ArrayCamera();\n    cameraVR.layers.enable(1);\n    cameraVR.layers.enable(2);\n    let _currentDepthNear = null;\n    let _currentDepthFar = null;\n    this.enabled = false;\n    this.isPresenting = false;\n    this.getController = function(index) {\n      let controller = controllers[index];\n      if (controller === void 0) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getTargetRaySpace();\n    };\n    this.getControllerGrip = function(index) {\n      let controller = controllers[index];\n      if (controller === void 0) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getGripSpace();\n    };\n    this.getHand = function(index) {\n      let controller = controllers[index];\n      if (controller === void 0) {\n        controller = new WebXRController();\n        controllers[index] = controller;\n      }\n      return controller.getHandSpace();\n    };\n    function onSessionEvent(event) {\n      const controller = inputSourcesMap.get(event.inputSource);\n      if (controller) {\n        controller.dispatchEvent({type: event.type, data: event.inputSource});\n      }\n    }\n    function onSessionEnd() {\n      inputSourcesMap.forEach(function(controller, inputSource) {\n        controller.disconnect(inputSource);\n      });\n      inputSourcesMap.clear();\n      _currentDepthNear = null;\n      _currentDepthFar = null;\n      state.bindXRFramebuffer(null);\n      renderer.setRenderTarget(renderer.getRenderTarget());\n      animation.stop();\n      scope.isPresenting = false;\n      scope.dispatchEvent({type: \"sessionend\"});\n    }\n    this.setFramebufferScaleFactor = function(value) {\n      framebufferScaleFactor = value;\n      if (scope.isPresenting === true) {\n        console.warn(\"THREE.WebXRManager: Cannot change framebuffer scale while presenting.\");\n      }\n    };\n    this.setReferenceSpaceType = function(value) {\n      referenceSpaceType = value;\n      if (scope.isPresenting === true) {\n        console.warn(\"THREE.WebXRManager: Cannot change reference space type while presenting.\");\n      }\n    };\n    this.getReferenceSpace = function() {\n      return referenceSpace;\n    };\n    this.getSession = function() {\n      return session;\n    };\n    this.setSession = function(value) {\n      return __async(this, null, function* () {\n        session = value;\n        if (session !== null) {\n          session.addEventListener(\"select\", onSessionEvent);\n          session.addEventListener(\"selectstart\", onSessionEvent);\n          session.addEventListener(\"selectend\", onSessionEvent);\n          session.addEventListener(\"squeeze\", onSessionEvent);\n          session.addEventListener(\"squeezestart\", onSessionEvent);\n          session.addEventListener(\"squeezeend\", onSessionEvent);\n          session.addEventListener(\"end\", onSessionEnd);\n          session.addEventListener(\"inputsourceschange\", onInputSourcesChange);\n          const attributes = gl.getContextAttributes();\n          if (attributes.xrCompatible !== true) {\n            yield gl.makeXRCompatible();\n          }\n          const layerInit = {\n            antialias: attributes.antialias,\n            alpha: attributes.alpha,\n            depth: attributes.depth,\n            stencil: attributes.stencil,\n            framebufferScaleFactor\n          };\n          const baseLayer = new XRWebGLLayer(session, gl, layerInit);\n          session.updateRenderState({baseLayer});\n          referenceSpace = yield session.requestReferenceSpace(referenceSpaceType);\n          animation.setContext(session);\n          animation.start();\n          scope.isPresenting = true;\n          scope.dispatchEvent({type: \"sessionstart\"});\n        }\n      });\n    };\n    function onInputSourcesChange(event) {\n      const inputSources = session.inputSources;\n      for (let i = 0; i < controllers.length; i++) {\n        inputSourcesMap.set(inputSources[i], controllers[i]);\n      }\n      for (let i = 0; i < event.removed.length; i++) {\n        const inputSource = event.removed[i];\n        const controller = inputSourcesMap.get(inputSource);\n        if (controller) {\n          controller.dispatchEvent({type: \"disconnected\", data: inputSource});\n          inputSourcesMap.delete(inputSource);\n        }\n      }\n      for (let i = 0; i < event.added.length; i++) {\n        const inputSource = event.added[i];\n        const controller = inputSourcesMap.get(inputSource);\n        if (controller) {\n          controller.dispatchEvent({type: \"connected\", data: inputSource});\n        }\n      }\n    }\n    const cameraLPos = new Vector3();\n    const cameraRPos = new Vector3();\n    function setProjectionFromUnion(camera, cameraL2, cameraR2) {\n      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);\n      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);\n      const ipd = cameraLPos.distanceTo(cameraRPos);\n      const projL = cameraL2.projectionMatrix.elements;\n      const projR = cameraR2.projectionMatrix.elements;\n      const near = projL[14] / (projL[10] - 1);\n      const far = projL[14] / (projL[10] + 1);\n      const topFov = (projL[9] + 1) / projL[5];\n      const bottomFov = (projL[9] - 1) / projL[5];\n      const leftFov = (projL[8] - 1) / projL[0];\n      const rightFov = (projR[8] + 1) / projR[0];\n      const left = near * leftFov;\n      const right = near * rightFov;\n      const zOffset = ipd / (-leftFov + rightFov);\n      const xOffset = zOffset * -leftFov;\n      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);\n      camera.translateX(xOffset);\n      camera.translateZ(zOffset);\n      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n      const near2 = near + zOffset;\n      const far2 = far + zOffset;\n      const left2 = left - xOffset;\n      const right2 = right + (ipd - xOffset);\n      const top2 = topFov * far / far2 * near2;\n      const bottom2 = bottomFov * far / far2 * near2;\n      camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);\n    }\n    function updateCamera(camera, parent) {\n      if (parent === null) {\n        camera.matrixWorld.copy(camera.matrix);\n      } else {\n        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);\n      }\n      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();\n    }\n    this.getCamera = function(camera) {\n      cameraVR.near = cameraR.near = cameraL.near = camera.near;\n      cameraVR.far = cameraR.far = cameraL.far = camera.far;\n      if (_currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far) {\n        session.updateRenderState({\n          depthNear: cameraVR.near,\n          depthFar: cameraVR.far\n        });\n        _currentDepthNear = cameraVR.near;\n        _currentDepthFar = cameraVR.far;\n      }\n      const parent = camera.parent;\n      const cameras2 = cameraVR.cameras;\n      updateCamera(cameraVR, parent);\n      for (let i = 0; i < cameras2.length; i++) {\n        updateCamera(cameras2[i], parent);\n      }\n      camera.matrixWorld.copy(cameraVR.matrixWorld);\n      camera.matrix.copy(cameraVR.matrix);\n      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);\n      const children = camera.children;\n      for (let i = 0, l = children.length; i < l; i++) {\n        children[i].updateMatrixWorld(true);\n      }\n      if (cameras2.length === 2) {\n        setProjectionFromUnion(cameraVR, cameraL, cameraR);\n      } else {\n        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix);\n      }\n      return cameraVR;\n    };\n    let onAnimationFrameCallback = null;\n    function onAnimationFrame(time, frame) {\n      pose = frame.getViewerPose(referenceSpace);\n      if (pose !== null) {\n        const views = pose.views;\n        const baseLayer = session.renderState.baseLayer;\n        state.bindXRFramebuffer(baseLayer.framebuffer);\n        let cameraVRNeedsUpdate = false;\n        if (views.length !== cameraVR.cameras.length) {\n          cameraVR.cameras.length = 0;\n          cameraVRNeedsUpdate = true;\n        }\n        for (let i = 0; i < views.length; i++) {\n          const view = views[i];\n          const viewport = baseLayer.getViewport(view);\n          const camera = cameras[i];\n          camera.matrix.fromArray(view.transform.matrix);\n          camera.projectionMatrix.fromArray(view.projectionMatrix);\n          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);\n          if (i === 0) {\n            cameraVR.matrix.copy(camera.matrix);\n          }\n          if (cameraVRNeedsUpdate === true) {\n            cameraVR.cameras.push(camera);\n          }\n        }\n      }\n      const inputSources = session.inputSources;\n      for (let i = 0; i < controllers.length; i++) {\n        const controller = controllers[i];\n        const inputSource = inputSources[i];\n        controller.update(inputSource, frame, referenceSpace);\n      }\n      if (onAnimationFrameCallback)\n        onAnimationFrameCallback(time, frame);\n    }\n    const animation = new WebGLAnimation();\n    animation.setAnimationLoop(onAnimationFrame);\n    this.setAnimationLoop = function(callback) {\n      onAnimationFrameCallback = callback;\n    };\n    this.dispose = function() {\n    };\n  }\n}\nfunction WebGLMaterials(properties) {\n  function refreshFogUniforms(uniforms, fog) {\n    uniforms.fogColor.value.copy(fog.color);\n    if (fog.isFog) {\n      uniforms.fogNear.value = fog.near;\n      uniforms.fogFar.value = fog.far;\n    } else if (fog.isFogExp2) {\n      uniforms.fogDensity.value = fog.density;\n    }\n  }\n  function refreshMaterialUniforms(uniforms, material, pixelRatio, height) {\n    if (material.isMeshBasicMaterial) {\n      refreshUniformsCommon(uniforms, material);\n    } else if (material.isMeshLambertMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsLambert(uniforms, material);\n    } else if (material.isMeshToonMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsToon(uniforms, material);\n    } else if (material.isMeshPhongMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsPhong(uniforms, material);\n    } else if (material.isMeshStandardMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      if (material.isMeshPhysicalMaterial) {\n        refreshUniformsPhysical(uniforms, material);\n      } else {\n        refreshUniformsStandard(uniforms, material);\n      }\n    } else if (material.isMeshMatcapMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsMatcap(uniforms, material);\n    } else if (material.isMeshDepthMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsDepth(uniforms, material);\n    } else if (material.isMeshDistanceMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsDistance(uniforms, material);\n    } else if (material.isMeshNormalMaterial) {\n      refreshUniformsCommon(uniforms, material);\n      refreshUniformsNormal(uniforms, material);\n    } else if (material.isLineBasicMaterial) {\n      refreshUniformsLine(uniforms, material);\n      if (material.isLineDashedMaterial) {\n        refreshUniformsDash(uniforms, material);\n      }\n    } else if (material.isPointsMaterial) {\n      refreshUniformsPoints(uniforms, material, pixelRatio, height);\n    } else if (material.isSpriteMaterial) {\n      refreshUniformsSprites(uniforms, material);\n    } else if (material.isShadowMaterial) {\n      uniforms.color.value.copy(material.color);\n      uniforms.opacity.value = material.opacity;\n    } else if (material.isShaderMaterial) {\n      material.uniformsNeedUpdate = false;\n    }\n  }\n  function refreshUniformsCommon(uniforms, material) {\n    uniforms.opacity.value = material.opacity;\n    if (material.color) {\n      uniforms.diffuse.value.copy(material.color);\n    }\n    if (material.emissive) {\n      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);\n    }\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n    if (material.specularMap) {\n      uniforms.specularMap.value = material.specularMap;\n    }\n    const envMap = properties.get(material).envMap;\n    if (envMap) {\n      uniforms.envMap.value = envMap;\n      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap._needsFlipEnvMap ? -1 : 1;\n      uniforms.reflectivity.value = material.reflectivity;\n      uniforms.refractionRatio.value = material.refractionRatio;\n      const maxMipLevel = properties.get(envMap).__maxMipLevel;\n      if (maxMipLevel !== void 0) {\n        uniforms.maxMipLevel.value = maxMipLevel;\n      }\n    }\n    if (material.lightMap) {\n      uniforms.lightMap.value = material.lightMap;\n      uniforms.lightMapIntensity.value = material.lightMapIntensity;\n    }\n    if (material.aoMap) {\n      uniforms.aoMap.value = material.aoMap;\n      uniforms.aoMapIntensity.value = material.aoMapIntensity;\n    }\n    let uvScaleMap;\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.specularMap) {\n      uvScaleMap = material.specularMap;\n    } else if (material.displacementMap) {\n      uvScaleMap = material.displacementMap;\n    } else if (material.normalMap) {\n      uvScaleMap = material.normalMap;\n    } else if (material.bumpMap) {\n      uvScaleMap = material.bumpMap;\n    } else if (material.roughnessMap) {\n      uvScaleMap = material.roughnessMap;\n    } else if (material.metalnessMap) {\n      uvScaleMap = material.metalnessMap;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    } else if (material.emissiveMap) {\n      uvScaleMap = material.emissiveMap;\n    } else if (material.clearcoatMap) {\n      uvScaleMap = material.clearcoatMap;\n    } else if (material.clearcoatNormalMap) {\n      uvScaleMap = material.clearcoatNormalMap;\n    } else if (material.clearcoatRoughnessMap) {\n      uvScaleMap = material.clearcoatRoughnessMap;\n    }\n    if (uvScaleMap !== void 0) {\n      if (uvScaleMap.isWebGLRenderTarget) {\n        uvScaleMap = uvScaleMap.texture;\n      }\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n    let uv2ScaleMap;\n    if (material.aoMap) {\n      uv2ScaleMap = material.aoMap;\n    } else if (material.lightMap) {\n      uv2ScaleMap = material.lightMap;\n    }\n    if (uv2ScaleMap !== void 0) {\n      if (uv2ScaleMap.isWebGLRenderTarget) {\n        uv2ScaleMap = uv2ScaleMap.texture;\n      }\n      if (uv2ScaleMap.matrixAutoUpdate === true) {\n        uv2ScaleMap.updateMatrix();\n      }\n      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix);\n    }\n  }\n  function refreshUniformsLine(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n  }\n  function refreshUniformsDash(uniforms, material) {\n    uniforms.dashSize.value = material.dashSize;\n    uniforms.totalSize.value = material.dashSize + material.gapSize;\n    uniforms.scale.value = material.scale;\n  }\n  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.size.value = material.size * pixelRatio;\n    uniforms.scale.value = height * 0.5;\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n    let uvScaleMap;\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n    if (uvScaleMap !== void 0) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n  function refreshUniformsSprites(uniforms, material) {\n    uniforms.diffuse.value.copy(material.color);\n    uniforms.opacity.value = material.opacity;\n    uniforms.rotation.value = material.rotation;\n    if (material.map) {\n      uniforms.map.value = material.map;\n    }\n    if (material.alphaMap) {\n      uniforms.alphaMap.value = material.alphaMap;\n    }\n    let uvScaleMap;\n    if (material.map) {\n      uvScaleMap = material.map;\n    } else if (material.alphaMap) {\n      uvScaleMap = material.alphaMap;\n    }\n    if (uvScaleMap !== void 0) {\n      if (uvScaleMap.matrixAutoUpdate === true) {\n        uvScaleMap.updateMatrix();\n      }\n      uniforms.uvTransform.value.copy(uvScaleMap.matrix);\n    }\n  }\n  function refreshUniformsLambert(uniforms, material) {\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n  }\n  function refreshUniformsPhong(uniforms, material) {\n    uniforms.specular.value.copy(material.specular);\n    uniforms.shininess.value = Math.max(material.shininess, 1e-4);\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide)\n        uniforms.bumpScale.value *= -1;\n    }\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide)\n        uniforms.normalScale.value.negate();\n    }\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n  function refreshUniformsToon(uniforms, material) {\n    if (material.gradientMap) {\n      uniforms.gradientMap.value = material.gradientMap;\n    }\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide)\n        uniforms.bumpScale.value *= -1;\n    }\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide)\n        uniforms.normalScale.value.negate();\n    }\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n  function refreshUniformsStandard(uniforms, material) {\n    uniforms.roughness.value = material.roughness;\n    uniforms.metalness.value = material.metalness;\n    if (material.roughnessMap) {\n      uniforms.roughnessMap.value = material.roughnessMap;\n    }\n    if (material.metalnessMap) {\n      uniforms.metalnessMap.value = material.metalnessMap;\n    }\n    if (material.emissiveMap) {\n      uniforms.emissiveMap.value = material.emissiveMap;\n    }\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide)\n        uniforms.bumpScale.value *= -1;\n    }\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide)\n        uniforms.normalScale.value.negate();\n    }\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n    const envMap = properties.get(material).envMap;\n    if (envMap) {\n      uniforms.envMapIntensity.value = material.envMapIntensity;\n    }\n  }\n  function refreshUniformsPhysical(uniforms, material) {\n    refreshUniformsStandard(uniforms, material);\n    uniforms.reflectivity.value = material.reflectivity;\n    uniforms.clearcoat.value = material.clearcoat;\n    uniforms.clearcoatRoughness.value = material.clearcoatRoughness;\n    if (material.sheen)\n      uniforms.sheen.value.copy(material.sheen);\n    if (material.clearcoatMap) {\n      uniforms.clearcoatMap.value = material.clearcoatMap;\n    }\n    if (material.clearcoatRoughnessMap) {\n      uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;\n    }\n    if (material.clearcoatNormalMap) {\n      uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);\n      uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;\n      if (material.side === BackSide) {\n        uniforms.clearcoatNormalScale.value.negate();\n      }\n    }\n    uniforms.transmission.value = material.transmission;\n    if (material.transmissionMap) {\n      uniforms.transmissionMap.value = material.transmissionMap;\n    }\n  }\n  function refreshUniformsMatcap(uniforms, material) {\n    if (material.matcap) {\n      uniforms.matcap.value = material.matcap;\n    }\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide)\n        uniforms.bumpScale.value *= -1;\n    }\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide)\n        uniforms.normalScale.value.negate();\n    }\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n  function refreshUniformsDepth(uniforms, material) {\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n  function refreshUniformsDistance(uniforms, material) {\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n    uniforms.referencePosition.value.copy(material.referencePosition);\n    uniforms.nearDistance.value = material.nearDistance;\n    uniforms.farDistance.value = material.farDistance;\n  }\n  function refreshUniformsNormal(uniforms, material) {\n    if (material.bumpMap) {\n      uniforms.bumpMap.value = material.bumpMap;\n      uniforms.bumpScale.value = material.bumpScale;\n      if (material.side === BackSide)\n        uniforms.bumpScale.value *= -1;\n    }\n    if (material.normalMap) {\n      uniforms.normalMap.value = material.normalMap;\n      uniforms.normalScale.value.copy(material.normalScale);\n      if (material.side === BackSide)\n        uniforms.normalScale.value.negate();\n    }\n    if (material.displacementMap) {\n      uniforms.displacementMap.value = material.displacementMap;\n      uniforms.displacementScale.value = material.displacementScale;\n      uniforms.displacementBias.value = material.displacementBias;\n    }\n  }\n  return {\n    refreshFogUniforms,\n    refreshMaterialUniforms\n  };\n}\nfunction createCanvasElement() {\n  const canvas = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"canvas\");\n  canvas.style.display = \"block\";\n  return canvas;\n}\nfunction WebGLRenderer(parameters) {\n  parameters = parameters || {};\n  const _canvas2 = parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(), _context2 = parameters.context !== void 0 ? parameters.context : null, _alpha = parameters.alpha !== void 0 ? parameters.alpha : false, _depth = parameters.depth !== void 0 ? parameters.depth : true, _stencil = parameters.stencil !== void 0 ? parameters.stencil : true, _antialias = parameters.antialias !== void 0 ? parameters.antialias : false, _premultipliedAlpha = parameters.premultipliedAlpha !== void 0 ? parameters.premultipliedAlpha : true, _preserveDrawingBuffer = parameters.preserveDrawingBuffer !== void 0 ? parameters.preserveDrawingBuffer : false, _powerPreference = parameters.powerPreference !== void 0 ? parameters.powerPreference : \"default\", _failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== void 0 ? parameters.failIfMajorPerformanceCaveat : false;\n  let currentRenderList = null;\n  let currentRenderState = null;\n  const renderListStack = [];\n  const renderStateStack = [];\n  this.domElement = _canvas2;\n  this.debug = {\n    checkShaderErrors: true\n  };\n  this.autoClear = true;\n  this.autoClearColor = true;\n  this.autoClearDepth = true;\n  this.autoClearStencil = true;\n  this.sortObjects = true;\n  this.clippingPlanes = [];\n  this.localClippingEnabled = false;\n  this.gammaFactor = 2;\n  this.outputEncoding = LinearEncoding;\n  this.physicallyCorrectLights = false;\n  this.toneMapping = NoToneMapping;\n  this.toneMappingExposure = 1;\n  const _this = this;\n  let _isContextLost = false;\n  let _currentActiveCubeFace = 0;\n  let _currentActiveMipmapLevel = 0;\n  let _currentRenderTarget = null;\n  let _currentMaterialId = -1;\n  let _currentCamera = null;\n  const _currentViewport = new Vector4();\n  const _currentScissor = new Vector4();\n  let _currentScissorTest = null;\n  let _width = _canvas2.width;\n  let _height = _canvas2.height;\n  let _pixelRatio = 1;\n  let _opaqueSort = null;\n  let _transparentSort = null;\n  const _viewport = new Vector4(0, 0, _width, _height);\n  const _scissor = new Vector4(0, 0, _width, _height);\n  let _scissorTest = false;\n  const _frustum = new Frustum();\n  let _clippingEnabled = false;\n  let _localClippingEnabled = false;\n  const _projScreenMatrix2 = new Matrix4();\n  const _vector3 = new Vector3();\n  const _emptyScene = {background: null, fog: null, environment: null, overrideMaterial: null, isScene: true};\n  function getTargetPixelRatio() {\n    return _currentRenderTarget === null ? _pixelRatio : 1;\n  }\n  let _gl = _context2;\n  function getContext(contextNames, contextAttributes) {\n    for (let i = 0; i < contextNames.length; i++) {\n      const contextName = contextNames[i];\n      const context = _canvas2.getContext(contextName, contextAttributes);\n      if (context !== null)\n        return context;\n    }\n    return null;\n  }\n  try {\n    const contextAttributes = {\n      alpha: _alpha,\n      depth: _depth,\n      stencil: _stencil,\n      antialias: _antialias,\n      premultipliedAlpha: _premultipliedAlpha,\n      preserveDrawingBuffer: _preserveDrawingBuffer,\n      powerPreference: _powerPreference,\n      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat\n    };\n    _canvas2.addEventListener(\"webglcontextlost\", onContextLost, false);\n    _canvas2.addEventListener(\"webglcontextrestored\", onContextRestore, false);\n    if (_gl === null) {\n      const contextNames = [\"webgl2\", \"webgl\", \"experimental-webgl\"];\n      if (_this.isWebGL1Renderer === true) {\n        contextNames.shift();\n      }\n      _gl = getContext(contextNames, contextAttributes);\n      if (_gl === null) {\n        if (getContext(contextNames)) {\n          throw new Error(\"Error creating WebGL context with your selected attributes.\");\n        } else {\n          throw new Error(\"Error creating WebGL context.\");\n        }\n      }\n    }\n    if (_gl.getShaderPrecisionFormat === void 0) {\n      _gl.getShaderPrecisionFormat = function() {\n        return {\"rangeMin\": 1, \"rangeMax\": 1, \"precision\": 1};\n      };\n    }\n  } catch (error) {\n    console.error(\"THREE.WebGLRenderer: \" + error.message);\n    throw error;\n  }\n  let extensions, capabilities, state, info;\n  let properties, textures, cubemaps, attributes, geometries, objects;\n  let programCache, materials, renderLists, renderStates, clipping, shadowMap;\n  let background, morphtargets, bufferRenderer, indexedBufferRenderer;\n  let utils, bindingStates;\n  function initGLContext() {\n    extensions = new WebGLExtensions(_gl);\n    capabilities = new WebGLCapabilities(_gl, extensions, parameters);\n    extensions.init(capabilities);\n    utils = new WebGLUtils(_gl, extensions, capabilities);\n    state = new WebGLState(_gl, extensions, capabilities);\n    info = new WebGLInfo(_gl);\n    properties = new WebGLProperties();\n    textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);\n    cubemaps = new WebGLCubeMaps(_this);\n    attributes = new WebGLAttributes(_gl, capabilities);\n    bindingStates = new WebGLBindingStates(_gl, extensions, attributes, capabilities);\n    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);\n    objects = new WebGLObjects(_gl, geometries, attributes, info);\n    morphtargets = new WebGLMorphtargets(_gl);\n    clipping = new WebGLClipping(properties);\n    programCache = new WebGLPrograms(_this, cubemaps, extensions, capabilities, bindingStates, clipping);\n    materials = new WebGLMaterials(properties);\n    renderLists = new WebGLRenderLists(properties);\n    renderStates = new WebGLRenderStates(extensions, capabilities);\n    background = new WebGLBackground(_this, cubemaps, state, objects, _premultipliedAlpha);\n    shadowMap = new WebGLShadowMap(_this, objects, capabilities);\n    bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info, capabilities);\n    indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info, capabilities);\n    info.programs = programCache.programs;\n    _this.capabilities = capabilities;\n    _this.extensions = extensions;\n    _this.properties = properties;\n    _this.renderLists = renderLists;\n    _this.shadowMap = shadowMap;\n    _this.state = state;\n    _this.info = info;\n  }\n  initGLContext();\n  const xr = new WebXRManager(_this, _gl);\n  this.xr = xr;\n  this.getContext = function() {\n    return _gl;\n  };\n  this.getContextAttributes = function() {\n    return _gl.getContextAttributes();\n  };\n  this.forceContextLoss = function() {\n    const extension = extensions.get(\"WEBGL_lose_context\");\n    if (extension)\n      extension.loseContext();\n  };\n  this.forceContextRestore = function() {\n    const extension = extensions.get(\"WEBGL_lose_context\");\n    if (extension)\n      extension.restoreContext();\n  };\n  this.getPixelRatio = function() {\n    return _pixelRatio;\n  };\n  this.setPixelRatio = function(value) {\n    if (value === void 0)\n      return;\n    _pixelRatio = value;\n    this.setSize(_width, _height, false);\n  };\n  this.getSize = function(target) {\n    if (target === void 0) {\n      console.warn(\"WebGLRenderer: .getsize() now requires a Vector2 as an argument\");\n      target = new Vector2();\n    }\n    return target.set(_width, _height);\n  };\n  this.setSize = function(width, height, updateStyle) {\n    if (xr.isPresenting) {\n      console.warn(\"THREE.WebGLRenderer: Can't change size while VR device is presenting.\");\n      return;\n    }\n    _width = width;\n    _height = height;\n    _canvas2.width = Math.floor(width * _pixelRatio);\n    _canvas2.height = Math.floor(height * _pixelRatio);\n    if (updateStyle !== false) {\n      _canvas2.style.width = width + \"px\";\n      _canvas2.style.height = height + \"px\";\n    }\n    this.setViewport(0, 0, width, height);\n  };\n  this.getDrawingBufferSize = function(target) {\n    if (target === void 0) {\n      console.warn(\"WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument\");\n      target = new Vector2();\n    }\n    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();\n  };\n  this.setDrawingBufferSize = function(width, height, pixelRatio) {\n    _width = width;\n    _height = height;\n    _pixelRatio = pixelRatio;\n    _canvas2.width = Math.floor(width * pixelRatio);\n    _canvas2.height = Math.floor(height * pixelRatio);\n    this.setViewport(0, 0, width, height);\n  };\n  this.getCurrentViewport = function(target) {\n    if (target === void 0) {\n      console.warn(\"WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument\");\n      target = new Vector4();\n    }\n    return target.copy(_currentViewport);\n  };\n  this.getViewport = function(target) {\n    return target.copy(_viewport);\n  };\n  this.setViewport = function(x, y, width, height) {\n    if (x.isVector4) {\n      _viewport.set(x.x, x.y, x.z, x.w);\n    } else {\n      _viewport.set(x, y, width, height);\n    }\n    state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor());\n  };\n  this.getScissor = function(target) {\n    return target.copy(_scissor);\n  };\n  this.setScissor = function(x, y, width, height) {\n    if (x.isVector4) {\n      _scissor.set(x.x, x.y, x.z, x.w);\n    } else {\n      _scissor.set(x, y, width, height);\n    }\n    state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor());\n  };\n  this.getScissorTest = function() {\n    return _scissorTest;\n  };\n  this.setScissorTest = function(boolean) {\n    state.setScissorTest(_scissorTest = boolean);\n  };\n  this.setOpaqueSort = function(method) {\n    _opaqueSort = method;\n  };\n  this.setTransparentSort = function(method) {\n    _transparentSort = method;\n  };\n  this.getClearColor = function(target) {\n    if (target === void 0) {\n      console.warn(\"WebGLRenderer: .getClearColor() now requires a Color as an argument\");\n      target = new Color();\n    }\n    return target.copy(background.getClearColor());\n  };\n  this.setClearColor = function() {\n    background.setClearColor.apply(background, arguments);\n  };\n  this.getClearAlpha = function() {\n    return background.getClearAlpha();\n  };\n  this.setClearAlpha = function() {\n    background.setClearAlpha.apply(background, arguments);\n  };\n  this.clear = function(color, depth, stencil) {\n    let bits = 0;\n    if (color === void 0 || color)\n      bits |= 16384;\n    if (depth === void 0 || depth)\n      bits |= 256;\n    if (stencil === void 0 || stencil)\n      bits |= 1024;\n    _gl.clear(bits);\n  };\n  this.clearColor = function() {\n    this.clear(true, false, false);\n  };\n  this.clearDepth = function() {\n    this.clear(false, true, false);\n  };\n  this.clearStencil = function() {\n    this.clear(false, false, true);\n  };\n  this.dispose = function() {\n    _canvas2.removeEventListener(\"webglcontextlost\", onContextLost, false);\n    _canvas2.removeEventListener(\"webglcontextrestored\", onContextRestore, false);\n    renderLists.dispose();\n    renderStates.dispose();\n    properties.dispose();\n    cubemaps.dispose();\n    objects.dispose();\n    bindingStates.dispose();\n    xr.dispose();\n    xr.removeEventListener(\"sessionstart\", onXRSessionStart);\n    xr.removeEventListener(\"sessionend\", onXRSessionEnd);\n    animation.stop();\n  };\n  function onContextLost(event) {\n    event.preventDefault();\n    console.log(\"THREE.WebGLRenderer: Context Lost.\");\n    _isContextLost = true;\n  }\n  function onContextRestore() {\n    console.log(\"THREE.WebGLRenderer: Context Restored.\");\n    _isContextLost = false;\n    const infoAutoReset = info.autoReset;\n    const shadowMapEnabled = shadowMap.enabled;\n    const shadowMapAutoUpdate = shadowMap.autoUpdate;\n    const shadowMapNeedsUpdate = shadowMap.needsUpdate;\n    const shadowMapType = shadowMap.type;\n    initGLContext();\n    info.autoReset = infoAutoReset;\n    shadowMap.enabled = shadowMapEnabled;\n    shadowMap.autoUpdate = shadowMapAutoUpdate;\n    shadowMap.needsUpdate = shadowMapNeedsUpdate;\n    shadowMap.type = shadowMapType;\n  }\n  function onMaterialDispose(event) {\n    const material = event.target;\n    material.removeEventListener(\"dispose\", onMaterialDispose);\n    deallocateMaterial(material);\n  }\n  function deallocateMaterial(material) {\n    releaseMaterialProgramReferences(material);\n    properties.remove(material);\n  }\n  function releaseMaterialProgramReferences(material) {\n    const programs = properties.get(material).programs;\n    if (programs !== void 0) {\n      programs.forEach(function(program) {\n        programCache.releaseProgram(program);\n      });\n    }\n  }\n  function renderObjectImmediate(object, program) {\n    object.render(function(object2) {\n      _this.renderBufferImmediate(object2, program);\n    });\n  }\n  this.renderBufferImmediate = function(object, program) {\n    bindingStates.initAttributes();\n    const buffers = properties.get(object);\n    if (object.hasPositions && !buffers.position)\n      buffers.position = _gl.createBuffer();\n    if (object.hasNormals && !buffers.normal)\n      buffers.normal = _gl.createBuffer();\n    if (object.hasUvs && !buffers.uv)\n      buffers.uv = _gl.createBuffer();\n    if (object.hasColors && !buffers.color)\n      buffers.color = _gl.createBuffer();\n    const programAttributes = program.getAttributes();\n    if (object.hasPositions) {\n      _gl.bindBuffer(34962, buffers.position);\n      _gl.bufferData(34962, object.positionArray, 35048);\n      bindingStates.enableAttribute(programAttributes.position);\n      _gl.vertexAttribPointer(programAttributes.position, 3, 5126, false, 0, 0);\n    }\n    if (object.hasNormals) {\n      _gl.bindBuffer(34962, buffers.normal);\n      _gl.bufferData(34962, object.normalArray, 35048);\n      bindingStates.enableAttribute(programAttributes.normal);\n      _gl.vertexAttribPointer(programAttributes.normal, 3, 5126, false, 0, 0);\n    }\n    if (object.hasUvs) {\n      _gl.bindBuffer(34962, buffers.uv);\n      _gl.bufferData(34962, object.uvArray, 35048);\n      bindingStates.enableAttribute(programAttributes.uv);\n      _gl.vertexAttribPointer(programAttributes.uv, 2, 5126, false, 0, 0);\n    }\n    if (object.hasColors) {\n      _gl.bindBuffer(34962, buffers.color);\n      _gl.bufferData(34962, object.colorArray, 35048);\n      bindingStates.enableAttribute(programAttributes.color);\n      _gl.vertexAttribPointer(programAttributes.color, 3, 5126, false, 0, 0);\n    }\n    bindingStates.disableUnusedAttributes();\n    _gl.drawArrays(4, 0, object.count);\n    object.count = 0;\n  };\n  this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {\n    if (scene === null)\n      scene = _emptyScene;\n    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;\n    const program = setProgram(camera, scene, material, object);\n    state.setMaterial(material, frontFaceCW);\n    let index = geometry.index;\n    const position = geometry.attributes.position;\n    if (index === null) {\n      if (position === void 0 || position.count === 0)\n        return;\n    } else if (index.count === 0) {\n      return;\n    }\n    let rangeFactor = 1;\n    if (material.wireframe === true) {\n      index = geometries.getWireframeAttribute(geometry);\n      rangeFactor = 2;\n    }\n    if (material.morphTargets || material.morphNormals) {\n      morphtargets.update(object, geometry, material, program);\n    }\n    bindingStates.setup(object, material, program, geometry, index);\n    let attribute;\n    let renderer = bufferRenderer;\n    if (index !== null) {\n      attribute = attributes.get(index);\n      renderer = indexedBufferRenderer;\n      renderer.setIndex(attribute);\n    }\n    const dataCount = index !== null ? index.count : position.count;\n    const rangeStart = geometry.drawRange.start * rangeFactor;\n    const rangeCount = geometry.drawRange.count * rangeFactor;\n    const groupStart = group !== null ? group.start * rangeFactor : 0;\n    const groupCount = group !== null ? group.count * rangeFactor : Infinity;\n    const drawStart = Math.max(rangeStart, groupStart);\n    const drawEnd = Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1;\n    const drawCount = Math.max(0, drawEnd - drawStart + 1);\n    if (drawCount === 0)\n      return;\n    if (object.isMesh) {\n      if (material.wireframe === true) {\n        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());\n        renderer.setMode(1);\n      } else {\n        renderer.setMode(4);\n      }\n    } else if (object.isLine) {\n      let lineWidth = material.linewidth;\n      if (lineWidth === void 0)\n        lineWidth = 1;\n      state.setLineWidth(lineWidth * getTargetPixelRatio());\n      if (object.isLineSegments) {\n        renderer.setMode(1);\n      } else if (object.isLineLoop) {\n        renderer.setMode(2);\n      } else {\n        renderer.setMode(3);\n      }\n    } else if (object.isPoints) {\n      renderer.setMode(0);\n    } else if (object.isSprite) {\n      renderer.setMode(4);\n    }\n    if (object.isInstancedMesh) {\n      renderer.renderInstances(drawStart, drawCount, object.count);\n    } else if (geometry.isInstancedBufferGeometry) {\n      const instanceCount = Math.min(geometry.instanceCount, geometry._maxInstanceCount);\n      renderer.renderInstances(drawStart, drawCount, instanceCount);\n    } else {\n      renderer.render(drawStart, drawCount);\n    }\n  };\n  this.compile = function(scene, camera) {\n    currentRenderState = renderStates.get(scene);\n    currentRenderState.init();\n    scene.traverseVisible(function(object) {\n      if (object.isLight && object.layers.test(camera.layers)) {\n        currentRenderState.pushLight(object);\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      }\n    });\n    currentRenderState.setupLights();\n    scene.traverse(function(object) {\n      const material = object.material;\n      if (material) {\n        if (Array.isArray(material)) {\n          for (let i = 0; i < material.length; i++) {\n            const material2 = material[i];\n            getProgram(material2, scene, object);\n          }\n        } else {\n          getProgram(material, scene, object);\n        }\n      }\n    });\n  };\n  let onAnimationFrameCallback = null;\n  function onAnimationFrame(time) {\n    if (onAnimationFrameCallback)\n      onAnimationFrameCallback(time);\n  }\n  function onXRSessionStart() {\n    animation.stop();\n  }\n  function onXRSessionEnd() {\n    animation.start();\n  }\n  const animation = new WebGLAnimation();\n  animation.setAnimationLoop(onAnimationFrame);\n  if (typeof window !== \"undefined\")\n    animation.setContext(window);\n  this.setAnimationLoop = function(callback) {\n    onAnimationFrameCallback = callback;\n    xr.setAnimationLoop(callback);\n    callback === null ? animation.stop() : animation.start();\n  };\n  xr.addEventListener(\"sessionstart\", onXRSessionStart);\n  xr.addEventListener(\"sessionend\", onXRSessionEnd);\n  this.render = function(scene, camera) {\n    let renderTarget, forceClear;\n    if (arguments[2] !== void 0) {\n      console.warn(\"THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.\");\n      renderTarget = arguments[2];\n    }\n    if (arguments[3] !== void 0) {\n      console.warn(\"THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.\");\n      forceClear = arguments[3];\n    }\n    if (camera !== void 0 && camera.isCamera !== true) {\n      console.error(\"THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.\");\n      return;\n    }\n    if (_isContextLost === true)\n      return;\n    if (scene.autoUpdate === true)\n      scene.updateMatrixWorld();\n    if (camera.parent === null)\n      camera.updateMatrixWorld();\n    if (xr.enabled === true && xr.isPresenting === true) {\n      camera = xr.getCamera(camera);\n    }\n    if (scene.isScene === true)\n      scene.onBeforeRender(_this, scene, camera, renderTarget || _currentRenderTarget);\n    currentRenderState = renderStates.get(scene, renderStateStack.length);\n    currentRenderState.init();\n    renderStateStack.push(currentRenderState);\n    _projScreenMatrix2.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    _frustum.setFromProjectionMatrix(_projScreenMatrix2);\n    _localClippingEnabled = this.localClippingEnabled;\n    _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled, camera);\n    currentRenderList = renderLists.get(scene, renderListStack.length);\n    currentRenderList.init();\n    renderListStack.push(currentRenderList);\n    projectObject(scene, camera, 0, _this.sortObjects);\n    currentRenderList.finish();\n    if (_this.sortObjects === true) {\n      currentRenderList.sort(_opaqueSort, _transparentSort);\n    }\n    if (_clippingEnabled === true)\n      clipping.beginShadows();\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    shadowMap.render(shadowsArray, scene, camera);\n    currentRenderState.setupLights();\n    currentRenderState.setupLightsView(camera);\n    if (_clippingEnabled === true)\n      clipping.endShadows();\n    if (this.info.autoReset === true)\n      this.info.reset();\n    if (renderTarget !== void 0) {\n      this.setRenderTarget(renderTarget);\n    }\n    background.render(currentRenderList, scene, camera, forceClear);\n    const opaqueObjects = currentRenderList.opaque;\n    const transparentObjects = currentRenderList.transparent;\n    if (opaqueObjects.length > 0)\n      renderObjects(opaqueObjects, scene, camera);\n    if (transparentObjects.length > 0)\n      renderObjects(transparentObjects, scene, camera);\n    if (_currentRenderTarget !== null) {\n      textures.updateRenderTargetMipmap(_currentRenderTarget);\n      textures.updateMultisampleRenderTarget(_currentRenderTarget);\n    }\n    if (scene.isScene === true)\n      scene.onAfterRender(_this, scene, camera);\n    state.buffers.depth.setTest(true);\n    state.buffers.depth.setMask(true);\n    state.buffers.color.setMask(true);\n    state.setPolygonOffset(false);\n    bindingStates.resetDefaultState();\n    _currentMaterialId = -1;\n    _currentCamera = null;\n    renderStateStack.pop();\n    if (renderStateStack.length > 0) {\n      currentRenderState = renderStateStack[renderStateStack.length - 1];\n    } else {\n      currentRenderState = null;\n    }\n    renderListStack.pop();\n    if (renderListStack.length > 0) {\n      currentRenderList = renderListStack[renderListStack.length - 1];\n    } else {\n      currentRenderList = null;\n    }\n  };\n  function projectObject(object, camera, groupOrder, sortObjects) {\n    if (object.visible === false)\n      return;\n    const visible = object.layers.test(camera.layers);\n    if (visible) {\n      if (object.isGroup) {\n        groupOrder = object.renderOrder;\n      } else if (object.isLOD) {\n        if (object.autoUpdate === true)\n          object.update(camera);\n      } else if (object.isLight) {\n        currentRenderState.pushLight(object);\n        if (object.castShadow) {\n          currentRenderState.pushShadow(object);\n        }\n      } else if (object.isSprite) {\n        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);\n          }\n          const geometry = objects.update(object);\n          const material = object.material;\n          if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      } else if (object.isImmediateRenderObject) {\n        if (sortObjects) {\n          _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);\n        }\n        currentRenderList.push(object, null, object.material, groupOrder, _vector3.z, null);\n      } else if (object.isMesh || object.isLine || object.isPoints) {\n        if (object.isSkinnedMesh) {\n          if (object.skeleton.frame !== info.render.frame) {\n            object.skeleton.update();\n            object.skeleton.frame = info.render.frame;\n          }\n        }\n        if (!object.frustumCulled || _frustum.intersectsObject(object)) {\n          if (sortObjects) {\n            _vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix2);\n          }\n          const geometry = objects.update(object);\n          const material = object.material;\n          if (Array.isArray(material)) {\n            const groups = geometry.groups;\n            for (let i = 0, l = groups.length; i < l; i++) {\n              const group = groups[i];\n              const groupMaterial = material[group.materialIndex];\n              if (groupMaterial && groupMaterial.visible) {\n                currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector3.z, group);\n              }\n            }\n          } else if (material.visible) {\n            currentRenderList.push(object, geometry, material, groupOrder, _vector3.z, null);\n          }\n        }\n      }\n    }\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      projectObject(children[i], camera, groupOrder, sortObjects);\n    }\n  }\n  function renderObjects(renderList, scene, camera) {\n    const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;\n    for (let i = 0, l = renderList.length; i < l; i++) {\n      const renderItem = renderList[i];\n      const object = renderItem.object;\n      const geometry = renderItem.geometry;\n      const material = overrideMaterial === null ? renderItem.material : overrideMaterial;\n      const group = renderItem.group;\n      if (camera.isArrayCamera) {\n        const cameras = camera.cameras;\n        for (let j = 0, jl = cameras.length; j < jl; j++) {\n          const camera2 = cameras[j];\n          if (object.layers.test(camera2.layers)) {\n            state.viewport(_currentViewport.copy(camera2.viewport));\n            currentRenderState.setupLightsView(camera2);\n            renderObject(object, scene, camera2, geometry, material, group);\n          }\n        }\n      } else {\n        renderObject(object, scene, camera, geometry, material, group);\n      }\n    }\n  }\n  function renderObject(object, scene, camera, geometry, material, group) {\n    object.onBeforeRender(_this, scene, camera, geometry, material, group);\n    object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);\n    object.normalMatrix.getNormalMatrix(object.modelViewMatrix);\n    if (object.isImmediateRenderObject) {\n      const program = setProgram(camera, scene, material, object);\n      state.setMaterial(material);\n      bindingStates.reset();\n      renderObjectImmediate(object, program);\n    } else {\n      _this.renderBufferDirect(camera, scene, geometry, material, object, group);\n    }\n    object.onAfterRender(_this, scene, camera, geometry, material, group);\n  }\n  function getProgram(material, scene, object) {\n    if (scene.isScene !== true)\n      scene = _emptyScene;\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n    const shadowsArray = currentRenderState.state.shadowsArray;\n    const lightsStateVersion = lights.state.version;\n    const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);\n    const programCacheKey = programCache.getProgramCacheKey(parameters2);\n    let programs = materialProperties.programs;\n    materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;\n    materialProperties.fog = scene.fog;\n    materialProperties.envMap = cubemaps.get(material.envMap || materialProperties.environment);\n    if (programs === void 0) {\n      material.addEventListener(\"dispose\", onMaterialDispose);\n      programs = new Map();\n      materialProperties.programs = programs;\n    }\n    let program = programs.get(programCacheKey);\n    if (program !== void 0) {\n      if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {\n        updateCommonMaterialProperties(material, parameters2);\n        return program;\n      }\n    } else {\n      parameters2.uniforms = programCache.getUniforms(material);\n      material.onBuild(parameters2, _this);\n      material.onBeforeCompile(parameters2, _this);\n      program = programCache.acquireProgram(parameters2, programCacheKey);\n      programs.set(programCacheKey, program);\n      materialProperties.uniforms = parameters2.uniforms;\n    }\n    const uniforms = materialProperties.uniforms;\n    if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {\n      uniforms.clippingPlanes = clipping.uniform;\n    }\n    updateCommonMaterialProperties(material, parameters2);\n    materialProperties.needsLights = materialNeedsLights(material);\n    materialProperties.lightsStateVersion = lightsStateVersion;\n    if (materialProperties.needsLights) {\n      uniforms.ambientLightColor.value = lights.state.ambient;\n      uniforms.lightProbe.value = lights.state.probe;\n      uniforms.directionalLights.value = lights.state.directional;\n      uniforms.directionalLightShadows.value = lights.state.directionalShadow;\n      uniforms.spotLights.value = lights.state.spot;\n      uniforms.spotLightShadows.value = lights.state.spotShadow;\n      uniforms.rectAreaLights.value = lights.state.rectArea;\n      uniforms.ltc_1.value = lights.state.rectAreaLTC1;\n      uniforms.ltc_2.value = lights.state.rectAreaLTC2;\n      uniforms.pointLights.value = lights.state.point;\n      uniforms.pointLightShadows.value = lights.state.pointShadow;\n      uniforms.hemisphereLights.value = lights.state.hemi;\n      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;\n      uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;\n      uniforms.spotShadowMap.value = lights.state.spotShadowMap;\n      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;\n      uniforms.pointShadowMap.value = lights.state.pointShadowMap;\n      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;\n    }\n    const progUniforms = program.getUniforms();\n    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms);\n    materialProperties.currentProgram = program;\n    materialProperties.uniformsList = uniformsList;\n    return program;\n  }\n  function updateCommonMaterialProperties(material, parameters2) {\n    const materialProperties = properties.get(material);\n    materialProperties.outputEncoding = parameters2.outputEncoding;\n    materialProperties.instancing = parameters2.instancing;\n    materialProperties.numClippingPlanes = parameters2.numClippingPlanes;\n    materialProperties.numIntersection = parameters2.numClipIntersection;\n    materialProperties.vertexAlphas = parameters2.vertexAlphas;\n  }\n  function setProgram(camera, scene, material, object) {\n    if (scene.isScene !== true)\n      scene = _emptyScene;\n    textures.resetTextureUnits();\n    const fog = scene.fog;\n    const environment = material.isMeshStandardMaterial ? scene.environment : null;\n    const encoding = _currentRenderTarget === null ? _this.outputEncoding : _currentRenderTarget.texture.encoding;\n    const envMap = cubemaps.get(material.envMap || environment);\n    const vertexAlphas = material.vertexColors === true && object.geometry && object.geometry.attributes.color && object.geometry.attributes.color.itemSize === 4;\n    const materialProperties = properties.get(material);\n    const lights = currentRenderState.state.lights;\n    if (_clippingEnabled === true) {\n      if (_localClippingEnabled === true || camera !== _currentCamera) {\n        const useCache = camera === _currentCamera && material.id === _currentMaterialId;\n        clipping.setState(material, camera, useCache);\n      }\n    }\n    let needsProgramChange = false;\n    if (material.version === materialProperties.__version) {\n      if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {\n        needsProgramChange = true;\n      } else if (materialProperties.outputEncoding !== encoding) {\n        needsProgramChange = true;\n      } else if (object.isInstancedMesh && materialProperties.instancing === false) {\n        needsProgramChange = true;\n      } else if (!object.isInstancedMesh && materialProperties.instancing === true) {\n        needsProgramChange = true;\n      } else if (materialProperties.envMap !== envMap) {\n        needsProgramChange = true;\n      } else if (material.fog && materialProperties.fog !== fog) {\n        needsProgramChange = true;\n      } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {\n        needsProgramChange = true;\n      } else if (materialProperties.vertexAlphas !== vertexAlphas) {\n        needsProgramChange = true;\n      }\n    } else {\n      needsProgramChange = true;\n      materialProperties.__version = material.version;\n    }\n    let program = materialProperties.currentProgram;\n    if (needsProgramChange === true) {\n      program = getProgram(material, scene, object);\n    }\n    let refreshProgram = false;\n    let refreshMaterial = false;\n    let refreshLights = false;\n    const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;\n    if (state.useProgram(program.program)) {\n      refreshProgram = true;\n      refreshMaterial = true;\n      refreshLights = true;\n    }\n    if (material.id !== _currentMaterialId) {\n      _currentMaterialId = material.id;\n      refreshMaterial = true;\n    }\n    if (refreshProgram || _currentCamera !== camera) {\n      p_uniforms.setValue(_gl, \"projectionMatrix\", camera.projectionMatrix);\n      if (capabilities.logarithmicDepthBuffer) {\n        p_uniforms.setValue(_gl, \"logDepthBufFC\", 2 / (Math.log(camera.far + 1) / Math.LN2));\n      }\n      if (_currentCamera !== camera) {\n        _currentCamera = camera;\n        refreshMaterial = true;\n        refreshLights = true;\n      }\n      if (material.isShaderMaterial || material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshStandardMaterial || material.envMap) {\n        const uCamPos = p_uniforms.map.cameraPosition;\n        if (uCamPos !== void 0) {\n          uCamPos.setValue(_gl, _vector3.setFromMatrixPosition(camera.matrixWorld));\n        }\n      }\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {\n        p_uniforms.setValue(_gl, \"isOrthographic\", camera.isOrthographicCamera === true);\n      }\n      if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial || material.isShadowMaterial || material.skinning) {\n        p_uniforms.setValue(_gl, \"viewMatrix\", camera.matrixWorldInverse);\n      }\n    }\n    if (material.skinning) {\n      p_uniforms.setOptional(_gl, object, \"bindMatrix\");\n      p_uniforms.setOptional(_gl, object, \"bindMatrixInverse\");\n      const skeleton = object.skeleton;\n      if (skeleton) {\n        const bones = skeleton.bones;\n        if (capabilities.floatVertexTextures) {\n          if (skeleton.boneTexture === null) {\n            let size = Math.sqrt(bones.length * 4);\n            size = ceilPowerOfTwo(size);\n            size = Math.max(size, 4);\n            const boneMatrices = new Float32Array(size * size * 4);\n            boneMatrices.set(skeleton.boneMatrices);\n            const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);\n            skeleton.boneMatrices = boneMatrices;\n            skeleton.boneTexture = boneTexture;\n            skeleton.boneTextureSize = size;\n          }\n          p_uniforms.setValue(_gl, \"boneTexture\", skeleton.boneTexture, textures);\n          p_uniforms.setValue(_gl, \"boneTextureSize\", skeleton.boneTextureSize);\n        } else {\n          p_uniforms.setOptional(_gl, skeleton, \"boneMatrices\");\n        }\n      }\n    }\n    if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {\n      materialProperties.receiveShadow = object.receiveShadow;\n      p_uniforms.setValue(_gl, \"receiveShadow\", object.receiveShadow);\n    }\n    if (refreshMaterial) {\n      p_uniforms.setValue(_gl, \"toneMappingExposure\", _this.toneMappingExposure);\n      if (materialProperties.needsLights) {\n        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);\n      }\n      if (fog && material.fog) {\n        materials.refreshFogUniforms(m_uniforms, fog);\n      }\n      materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height);\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n    }\n    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {\n      WebGLUniforms.upload(_gl, materialProperties.uniformsList, m_uniforms, textures);\n      material.uniformsNeedUpdate = false;\n    }\n    if (material.isSpriteMaterial) {\n      p_uniforms.setValue(_gl, \"center\", object.center);\n    }\n    p_uniforms.setValue(_gl, \"modelViewMatrix\", object.modelViewMatrix);\n    p_uniforms.setValue(_gl, \"normalMatrix\", object.normalMatrix);\n    p_uniforms.setValue(_gl, \"modelMatrix\", object.matrixWorld);\n    return program;\n  }\n  function markUniformsLightsNeedsUpdate(uniforms, value) {\n    uniforms.ambientLightColor.needsUpdate = value;\n    uniforms.lightProbe.needsUpdate = value;\n    uniforms.directionalLights.needsUpdate = value;\n    uniforms.directionalLightShadows.needsUpdate = value;\n    uniforms.pointLights.needsUpdate = value;\n    uniforms.pointLightShadows.needsUpdate = value;\n    uniforms.spotLights.needsUpdate = value;\n    uniforms.spotLightShadows.needsUpdate = value;\n    uniforms.rectAreaLights.needsUpdate = value;\n    uniforms.hemisphereLights.needsUpdate = value;\n  }\n  function materialNeedsLights(material) {\n    return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;\n  }\n  this.getActiveCubeFace = function() {\n    return _currentActiveCubeFace;\n  };\n  this.getActiveMipmapLevel = function() {\n    return _currentActiveMipmapLevel;\n  };\n  this.getRenderTarget = function() {\n    return _currentRenderTarget;\n  };\n  this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {\n    _currentRenderTarget = renderTarget;\n    _currentActiveCubeFace = activeCubeFace;\n    _currentActiveMipmapLevel = activeMipmapLevel;\n    if (renderTarget && properties.get(renderTarget).__webglFramebuffer === void 0) {\n      textures.setupRenderTarget(renderTarget);\n    }\n    let framebuffer = null;\n    let isCube = false;\n    let isRenderTarget3D = false;\n    if (renderTarget) {\n      const texture = renderTarget.texture;\n      if (texture.isDataTexture3D || texture.isDataTexture2DArray) {\n        isRenderTarget3D = true;\n      }\n      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;\n      if (renderTarget.isWebGLCubeRenderTarget) {\n        framebuffer = __webglFramebuffer[activeCubeFace];\n        isCube = true;\n      } else if (renderTarget.isWebGLMultisampleRenderTarget) {\n        framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;\n      } else {\n        framebuffer = __webglFramebuffer;\n      }\n      _currentViewport.copy(renderTarget.viewport);\n      _currentScissor.copy(renderTarget.scissor);\n      _currentScissorTest = renderTarget.scissorTest;\n    } else {\n      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();\n      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();\n      _currentScissorTest = _scissorTest;\n    }\n    state.bindFramebuffer(36160, framebuffer);\n    state.viewport(_currentViewport);\n    state.scissor(_currentScissor);\n    state.setScissorTest(_currentScissorTest);\n    if (isCube) {\n      const textureProperties = properties.get(renderTarget.texture);\n      _gl.framebufferTexture2D(36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);\n    } else if (isRenderTarget3D) {\n      const textureProperties = properties.get(renderTarget.texture);\n      const layer = activeCubeFace || 0;\n      _gl.framebufferTextureLayer(36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer);\n    }\n  };\n  this.readRenderTargetPixels = function(renderTarget, x, y, width, height, buffer, activeCubeFaceIndex) {\n    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {\n      console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.\");\n      return;\n    }\n    let framebuffer = properties.get(renderTarget).__webglFramebuffer;\n    if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {\n      framebuffer = framebuffer[activeCubeFaceIndex];\n    }\n    if (framebuffer) {\n      state.bindFramebuffer(36160, framebuffer);\n      try {\n        const texture = renderTarget.texture;\n        const textureFormat = texture.format;\n        const textureType = texture.type;\n        if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== _gl.getParameter(35739)) {\n          console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.\");\n          return;\n        }\n        const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has(\"EXT_color_buffer_half_float\") || capabilities.isWebGL2 && extensions.has(\"EXT_color_buffer_float\"));\n        if (textureType !== UnsignedByteType && utils.convert(textureType) !== _gl.getParameter(35738) && !(textureType === FloatType && (capabilities.isWebGL2 || extensions.has(\"OES_texture_float\") || extensions.has(\"WEBGL_color_buffer_float\"))) && !halfFloatSupportedByExt) {\n          console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.\");\n          return;\n        }\n        if (_gl.checkFramebufferStatus(36160) === 36053) {\n          if (x >= 0 && x <= renderTarget.width - width && (y >= 0 && y <= renderTarget.height - height)) {\n            _gl.readPixels(x, y, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);\n          }\n        } else {\n          console.error(\"THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.\");\n        }\n      } finally {\n        const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;\n        state.bindFramebuffer(36160, framebuffer2);\n      }\n    }\n  };\n  this.copyFramebufferToTexture = function(position, texture, level = 0) {\n    const levelScale = Math.pow(2, -level);\n    const width = Math.floor(texture.image.width * levelScale);\n    const height = Math.floor(texture.image.height * levelScale);\n    const glFormat = utils.convert(texture.format);\n    textures.setTexture2D(texture, 0);\n    _gl.copyTexImage2D(3553, level, glFormat, position.x, position.y, width, height, 0);\n    state.unbindTexture();\n  };\n  this.copyTextureToTexture = function(position, srcTexture, dstTexture, level = 0) {\n    const width = srcTexture.image.width;\n    const height = srcTexture.image.height;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    textures.setTexture2D(dstTexture, 0);\n    _gl.pixelStorei(37440, dstTexture.flipY);\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n    if (srcTexture.isDataTexture) {\n      _gl.texSubImage2D(3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data);\n    } else {\n      if (srcTexture.isCompressedTexture) {\n        _gl.compressedTexSubImage2D(3553, level, position.x, position.y, srcTexture.mipmaps[0].width, srcTexture.mipmaps[0].height, glFormat, srcTexture.mipmaps[0].data);\n      } else {\n        _gl.texSubImage2D(3553, level, position.x, position.y, glFormat, glType, srcTexture.image);\n      }\n    }\n    if (level === 0 && dstTexture.generateMipmaps)\n      _gl.generateMipmap(3553);\n    state.unbindTexture();\n  };\n  this.copyTextureToTexture3D = function(sourceBox, position, srcTexture, dstTexture, level = 0) {\n    if (_this.isWebGL1Renderer) {\n      console.warn(\"THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.\");\n      return;\n    }\n    const {width, height, data} = srcTexture.image;\n    const glFormat = utils.convert(dstTexture.format);\n    const glType = utils.convert(dstTexture.type);\n    let glTarget;\n    if (dstTexture.isDataTexture3D) {\n      textures.setTexture3D(dstTexture, 0);\n      glTarget = 32879;\n    } else if (dstTexture.isDataTexture2DArray) {\n      textures.setTexture2DArray(dstTexture, 0);\n      glTarget = 35866;\n    } else {\n      console.warn(\"THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.\");\n      return;\n    }\n    _gl.pixelStorei(37440, dstTexture.flipY);\n    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha);\n    _gl.pixelStorei(3317, dstTexture.unpackAlignment);\n    const unpackRowLen = _gl.getParameter(3314);\n    const unpackImageHeight = _gl.getParameter(32878);\n    const unpackSkipPixels = _gl.getParameter(3316);\n    const unpackSkipRows = _gl.getParameter(3315);\n    const unpackSkipImages = _gl.getParameter(32877);\n    _gl.pixelStorei(3314, width);\n    _gl.pixelStorei(32878, height);\n    _gl.pixelStorei(3316, sourceBox.min.x);\n    _gl.pixelStorei(3315, sourceBox.min.y);\n    _gl.pixelStorei(32877, sourceBox.min.z);\n    _gl.texSubImage3D(glTarget, level, position.x, position.y, position.z, sourceBox.max.x - sourceBox.min.x + 1, sourceBox.max.y - sourceBox.min.y + 1, sourceBox.max.z - sourceBox.min.z + 1, glFormat, glType, data);\n    _gl.pixelStorei(3314, unpackRowLen);\n    _gl.pixelStorei(32878, unpackImageHeight);\n    _gl.pixelStorei(3316, unpackSkipPixels);\n    _gl.pixelStorei(3315, unpackSkipRows);\n    _gl.pixelStorei(32877, unpackSkipImages);\n    if (level === 0 && dstTexture.generateMipmaps)\n      _gl.generateMipmap(glTarget);\n    state.unbindTexture();\n  };\n  this.initTexture = function(texture) {\n    textures.setTexture2D(texture, 0);\n    state.unbindTexture();\n  };\n  this.resetState = function() {\n    _currentActiveCubeFace = 0;\n    _currentActiveMipmapLevel = 0;\n    _currentRenderTarget = null;\n    state.reset();\n    bindingStates.reset();\n  };\n  if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", {detail: this}));\n  }\n}\nclass WebGL1Renderer extends WebGLRenderer {\n}\nWebGL1Renderer.prototype.isWebGL1Renderer = true;\nclass FogExp2 {\n  constructor(color, density = 25e-5) {\n    this.name = \"\";\n    this.color = new Color(color);\n    this.density = density;\n  }\n  clone() {\n    return new FogExp2(this.color, this.density);\n  }\n  toJSON() {\n    return {\n      type: \"FogExp2\",\n      color: this.color.getHex(),\n      density: this.density\n    };\n  }\n}\nFogExp2.prototype.isFogExp2 = true;\nclass Fog {\n  constructor(color, near = 1, far = 1e3) {\n    this.name = \"\";\n    this.color = new Color(color);\n    this.near = near;\n    this.far = far;\n  }\n  clone() {\n    return new Fog(this.color, this.near, this.far);\n  }\n  toJSON() {\n    return {\n      type: \"Fog\",\n      color: this.color.getHex(),\n      near: this.near,\n      far: this.far\n    };\n  }\n}\nFog.prototype.isFog = true;\nclass Scene extends Object3D {\n  constructor() {\n    super();\n    this.type = \"Scene\";\n    this.background = null;\n    this.environment = null;\n    this.fog = null;\n    this.overrideMaterial = null;\n    this.autoUpdate = true;\n    if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", {detail: this}));\n    }\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    if (source.background !== null)\n      this.background = source.background.clone();\n    if (source.environment !== null)\n      this.environment = source.environment.clone();\n    if (source.fog !== null)\n      this.fog = source.fog.clone();\n    if (source.overrideMaterial !== null)\n      this.overrideMaterial = source.overrideMaterial.clone();\n    this.autoUpdate = source.autoUpdate;\n    this.matrixAutoUpdate = source.matrixAutoUpdate;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.background !== null)\n      data.object.background = this.background.toJSON(meta);\n    if (this.environment !== null)\n      data.object.environment = this.environment.toJSON(meta);\n    if (this.fog !== null)\n      data.object.fog = this.fog.toJSON();\n    return data;\n  }\n}\nScene.prototype.isScene = true;\nclass InterleavedBuffer {\n  constructor(array, stride) {\n    this.array = array;\n    this.stride = stride;\n    this.count = array !== void 0 ? array.length / stride : 0;\n    this.usage = StaticDrawUsage;\n    this.updateRange = {offset: 0, count: -1};\n    this.version = 0;\n    this.uuid = generateUUID();\n    this.onUploadCallback = function() {\n    };\n  }\n  set needsUpdate(value) {\n    if (value === true)\n      this.version++;\n  }\n  setUsage(value) {\n    this.usage = value;\n    return this;\n  }\n  copy(source) {\n    this.array = new source.array.constructor(source.array);\n    this.count = source.count;\n    this.stride = source.stride;\n    this.usage = source.usage;\n    return this;\n  }\n  copyAt(index1, attribute, index2) {\n    index1 *= this.stride;\n    index2 *= attribute.stride;\n    for (let i = 0, l = this.stride; i < l; i++) {\n      this.array[index1 + i] = attribute.array[index2 + i];\n    }\n    return this;\n  }\n  set(value, offset = 0) {\n    this.array.set(value, offset);\n    return this;\n  }\n  clone(data) {\n    if (data.arrayBuffers === void 0) {\n      data.arrayBuffers = {};\n    }\n    if (this.array.buffer._uuid === void 0) {\n      this.array.buffer._uuid = generateUUID();\n    }\n    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {\n      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;\n    }\n    const array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);\n    const ib = new InterleavedBuffer(array, this.stride);\n    ib.setUsage(this.usage);\n    return ib;\n  }\n  onUpload(callback) {\n    this.onUploadCallback = callback;\n    return this;\n  }\n  toJSON(data) {\n    if (data.arrayBuffers === void 0) {\n      data.arrayBuffers = {};\n    }\n    if (this.array.buffer._uuid === void 0) {\n      this.array.buffer._uuid = generateUUID();\n    }\n    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {\n      data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer));\n    }\n    return {\n      uuid: this.uuid,\n      buffer: this.array.buffer._uuid,\n      type: this.array.constructor.name,\n      stride: this.stride\n    };\n  }\n}\nInterleavedBuffer.prototype.isInterleavedBuffer = true;\nconst _vector$6 = new Vector3();\nclass InterleavedBufferAttribute {\n  constructor(interleavedBuffer, itemSize, offset, normalized) {\n    this.name = \"\";\n    this.data = interleavedBuffer;\n    this.itemSize = itemSize;\n    this.offset = offset;\n    this.normalized = normalized === true;\n  }\n  get count() {\n    return this.data.count;\n  }\n  get array() {\n    return this.data.array;\n  }\n  set needsUpdate(value) {\n    this.data.needsUpdate = value;\n  }\n  applyMatrix4(m) {\n    for (let i = 0, l = this.data.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n      _vector$6.applyMatrix4(m);\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n    return this;\n  }\n  applyNormalMatrix(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n      _vector$6.applyNormalMatrix(m);\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n    return this;\n  }\n  transformDirection(m) {\n    for (let i = 0, l = this.count; i < l; i++) {\n      _vector$6.x = this.getX(i);\n      _vector$6.y = this.getY(i);\n      _vector$6.z = this.getZ(i);\n      _vector$6.transformDirection(m);\n      this.setXYZ(i, _vector$6.x, _vector$6.y, _vector$6.z);\n    }\n    return this;\n  }\n  setX(index, x) {\n    this.data.array[index * this.data.stride + this.offset] = x;\n    return this;\n  }\n  setY(index, y) {\n    this.data.array[index * this.data.stride + this.offset + 1] = y;\n    return this;\n  }\n  setZ(index, z) {\n    this.data.array[index * this.data.stride + this.offset + 2] = z;\n    return this;\n  }\n  setW(index, w) {\n    this.data.array[index * this.data.stride + this.offset + 3] = w;\n    return this;\n  }\n  getX(index) {\n    return this.data.array[index * this.data.stride + this.offset];\n  }\n  getY(index) {\n    return this.data.array[index * this.data.stride + this.offset + 1];\n  }\n  getZ(index) {\n    return this.data.array[index * this.data.stride + this.offset + 2];\n  }\n  getW(index) {\n    return this.data.array[index * this.data.stride + this.offset + 3];\n  }\n  setXY(index, x, y) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    return this;\n  }\n  setXYZ(index, x, y, z) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    return this;\n  }\n  setXYZW(index, x, y, z, w) {\n    index = index * this.data.stride + this.offset;\n    this.data.array[index + 0] = x;\n    this.data.array[index + 1] = y;\n    this.data.array[index + 2] = z;\n    this.data.array[index + 3] = w;\n    return this;\n  }\n  clone(data) {\n    if (data === void 0) {\n      console.log(\"THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.\");\n      const array = [];\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);\n    } else {\n      if (data.interleavedBuffers === void 0) {\n        data.interleavedBuffers = {};\n      }\n      if (data.interleavedBuffers[this.data.uuid] === void 0) {\n        data.interleavedBuffers[this.data.uuid] = this.data.clone(data);\n      }\n      return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);\n    }\n  }\n  toJSON(data) {\n    if (data === void 0) {\n      console.log(\"THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.\");\n      const array = [];\n      for (let i = 0; i < this.count; i++) {\n        const index = i * this.data.stride + this.offset;\n        for (let j = 0; j < this.itemSize; j++) {\n          array.push(this.data.array[index + j]);\n        }\n      }\n      return {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array,\n        normalized: this.normalized\n      };\n    } else {\n      if (data.interleavedBuffers === void 0) {\n        data.interleavedBuffers = {};\n      }\n      if (data.interleavedBuffers[this.data.uuid] === void 0) {\n        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);\n      }\n      return {\n        isInterleavedBufferAttribute: true,\n        itemSize: this.itemSize,\n        data: this.data.uuid,\n        offset: this.offset,\n        normalized: this.normalized\n      };\n    }\n  }\n}\nInterleavedBufferAttribute.prototype.isInterleavedBufferAttribute = true;\nclass SpriteMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"SpriteMaterial\";\n    this.color = new Color(16777215);\n    this.map = null;\n    this.alphaMap = null;\n    this.rotation = 0;\n    this.sizeAttenuation = true;\n    this.transparent = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.rotation = source.rotation;\n    this.sizeAttenuation = source.sizeAttenuation;\n    return this;\n  }\n}\nSpriteMaterial.prototype.isSpriteMaterial = true;\nlet _geometry;\nconst _intersectPoint = /* @__PURE__ */ new Vector3();\nconst _worldScale = /* @__PURE__ */ new Vector3();\nconst _mvPosition = /* @__PURE__ */ new Vector3();\nconst _alignedPosition = /* @__PURE__ */ new Vector2();\nconst _rotatedPosition = /* @__PURE__ */ new Vector2();\nconst _viewWorldMatrix = /* @__PURE__ */ new Matrix4();\nconst _vA = /* @__PURE__ */ new Vector3();\nconst _vB = /* @__PURE__ */ new Vector3();\nconst _vC = /* @__PURE__ */ new Vector3();\nconst _uvA = /* @__PURE__ */ new Vector2();\nconst _uvB = /* @__PURE__ */ new Vector2();\nconst _uvC = /* @__PURE__ */ new Vector2();\nclass Sprite extends Object3D {\n  constructor(material) {\n    super();\n    this.type = \"Sprite\";\n    if (_geometry === void 0) {\n      _geometry = new BufferGeometry();\n      const float32Array = new Float32Array([\n        -0.5,\n        -0.5,\n        0,\n        0,\n        0,\n        0.5,\n        -0.5,\n        0,\n        1,\n        0,\n        0.5,\n        0.5,\n        0,\n        1,\n        1,\n        -0.5,\n        0.5,\n        0,\n        0,\n        1\n      ]);\n      const interleavedBuffer = new InterleavedBuffer(float32Array, 5);\n      _geometry.setIndex([0, 1, 2, 0, 2, 3]);\n      _geometry.setAttribute(\"position\", new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));\n      _geometry.setAttribute(\"uv\", new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));\n    }\n    this.geometry = _geometry;\n    this.material = material !== void 0 ? material : new SpriteMaterial();\n    this.center = new Vector2(0.5, 0.5);\n  }\n  raycast(raycaster, intersects2) {\n    if (raycaster.camera === null) {\n      console.error('THREE.Sprite: \"Raycaster.camera\" needs to be set in order to raycast against sprites.');\n    }\n    _worldScale.setFromMatrixScale(this.matrixWorld);\n    _viewWorldMatrix.copy(raycaster.camera.matrixWorld);\n    this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);\n    _mvPosition.setFromMatrixPosition(this.modelViewMatrix);\n    if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {\n      _worldScale.multiplyScalar(-_mvPosition.z);\n    }\n    const rotation = this.material.rotation;\n    let sin, cos;\n    if (rotation !== 0) {\n      cos = Math.cos(rotation);\n      sin = Math.sin(rotation);\n    }\n    const center = this.center;\n    transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n    _uvA.set(0, 0);\n    _uvB.set(1, 0);\n    _uvC.set(1, 1);\n    let intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);\n    if (intersect === null) {\n      transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);\n      _uvB.set(0, 1);\n      intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);\n      if (intersect === null) {\n        return;\n      }\n    }\n    const distance = raycaster.ray.origin.distanceTo(_intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far)\n      return;\n    intersects2.push({\n      distance,\n      point: _intersectPoint.clone(),\n      uv: Triangle.getUV(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),\n      face: null,\n      object: this\n    });\n  }\n  copy(source) {\n    super.copy(source);\n    if (source.center !== void 0)\n      this.center.copy(source.center);\n    this.material = source.material;\n    return this;\n  }\n}\nSprite.prototype.isSprite = true;\nfunction transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {\n  _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);\n  if (sin !== void 0) {\n    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;\n    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;\n  } else {\n    _rotatedPosition.copy(_alignedPosition);\n  }\n  vertexPosition.copy(mvPosition);\n  vertexPosition.x += _rotatedPosition.x;\n  vertexPosition.y += _rotatedPosition.y;\n  vertexPosition.applyMatrix4(_viewWorldMatrix);\n}\nconst _v1$2 = /* @__PURE__ */ new Vector3();\nconst _v2$1 = /* @__PURE__ */ new Vector3();\nclass LOD extends Object3D {\n  constructor() {\n    super();\n    this._currentLevel = 0;\n    this.type = \"LOD\";\n    Object.defineProperties(this, {\n      levels: {\n        enumerable: true,\n        value: []\n      },\n      isLOD: {\n        value: true\n      }\n    });\n    this.autoUpdate = true;\n  }\n  copy(source) {\n    super.copy(source, false);\n    const levels = source.levels;\n    for (let i = 0, l = levels.length; i < l; i++) {\n      const level = levels[i];\n      this.addLevel(level.object.clone(), level.distance);\n    }\n    this.autoUpdate = source.autoUpdate;\n    return this;\n  }\n  addLevel(object, distance = 0) {\n    distance = Math.abs(distance);\n    const levels = this.levels;\n    let l;\n    for (l = 0; l < levels.length; l++) {\n      if (distance < levels[l].distance) {\n        break;\n      }\n    }\n    levels.splice(l, 0, {distance, object});\n    this.add(object);\n    return this;\n  }\n  getCurrentLevel() {\n    return this._currentLevel;\n  }\n  getObjectForDistance(distance) {\n    const levels = this.levels;\n    if (levels.length > 0) {\n      let i, l;\n      for (i = 1, l = levels.length; i < l; i++) {\n        if (distance < levels[i].distance) {\n          break;\n        }\n      }\n      return levels[i - 1].object;\n    }\n    return null;\n  }\n  raycast(raycaster, intersects2) {\n    const levels = this.levels;\n    if (levels.length > 0) {\n      _v1$2.setFromMatrixPosition(this.matrixWorld);\n      const distance = raycaster.ray.origin.distanceTo(_v1$2);\n      this.getObjectForDistance(distance).raycast(raycaster, intersects2);\n    }\n  }\n  update(camera) {\n    const levels = this.levels;\n    if (levels.length > 1) {\n      _v1$2.setFromMatrixPosition(camera.matrixWorld);\n      _v2$1.setFromMatrixPosition(this.matrixWorld);\n      const distance = _v1$2.distanceTo(_v2$1) / camera.zoom;\n      levels[0].object.visible = true;\n      let i, l;\n      for (i = 1, l = levels.length; i < l; i++) {\n        if (distance >= levels[i].distance) {\n          levels[i - 1].object.visible = false;\n          levels[i].object.visible = true;\n        } else {\n          break;\n        }\n      }\n      this._currentLevel = i - 1;\n      for (; i < l; i++) {\n        levels[i].object.visible = false;\n      }\n    }\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    if (this.autoUpdate === false)\n      data.object.autoUpdate = false;\n    data.object.levels = [];\n    const levels = this.levels;\n    for (let i = 0, l = levels.length; i < l; i++) {\n      const level = levels[i];\n      data.object.levels.push({\n        object: level.object.uuid,\n        distance: level.distance\n      });\n    }\n    return data;\n  }\n}\nconst _basePosition = /* @__PURE__ */ new Vector3();\nconst _skinIndex = /* @__PURE__ */ new Vector4();\nconst _skinWeight = /* @__PURE__ */ new Vector4();\nconst _vector$5 = /* @__PURE__ */ new Vector3();\nconst _matrix = /* @__PURE__ */ new Matrix4();\nclass SkinnedMesh extends Mesh {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = \"SkinnedMesh\";\n    this.bindMode = \"attached\";\n    this.bindMatrix = new Matrix4();\n    this.bindMatrixInverse = new Matrix4();\n  }\n  copy(source) {\n    super.copy(source);\n    this.bindMode = source.bindMode;\n    this.bindMatrix.copy(source.bindMatrix);\n    this.bindMatrixInverse.copy(source.bindMatrixInverse);\n    this.skeleton = source.skeleton;\n    return this;\n  }\n  bind(skeleton, bindMatrix) {\n    this.skeleton = skeleton;\n    if (bindMatrix === void 0) {\n      this.updateMatrixWorld(true);\n      this.skeleton.calculateInverses();\n      bindMatrix = this.matrixWorld;\n    }\n    this.bindMatrix.copy(bindMatrix);\n    this.bindMatrixInverse.copy(bindMatrix).invert();\n  }\n  pose() {\n    this.skeleton.pose();\n  }\n  normalizeSkinWeights() {\n    const vector = new Vector4();\n    const skinWeight = this.geometry.attributes.skinWeight;\n    for (let i = 0, l = skinWeight.count; i < l; i++) {\n      vector.x = skinWeight.getX(i);\n      vector.y = skinWeight.getY(i);\n      vector.z = skinWeight.getZ(i);\n      vector.w = skinWeight.getW(i);\n      const scale = 1 / vector.manhattanLength();\n      if (scale !== Infinity) {\n        vector.multiplyScalar(scale);\n      } else {\n        vector.set(1, 0, 0, 0);\n      }\n      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);\n    }\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.bindMode === \"attached\") {\n      this.bindMatrixInverse.copy(this.matrixWorld).invert();\n    } else if (this.bindMode === \"detached\") {\n      this.bindMatrixInverse.copy(this.bindMatrix).invert();\n    } else {\n      console.warn(\"THREE.SkinnedMesh: Unrecognized bindMode: \" + this.bindMode);\n    }\n  }\n  boneTransform(index, target) {\n    const skeleton = this.skeleton;\n    const geometry = this.geometry;\n    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);\n    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);\n    _basePosition.fromBufferAttribute(geometry.attributes.position, index).applyMatrix4(this.bindMatrix);\n    target.set(0, 0, 0);\n    for (let i = 0; i < 4; i++) {\n      const weight = _skinWeight.getComponent(i);\n      if (weight !== 0) {\n        const boneIndex = _skinIndex.getComponent(i);\n        _matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);\n        target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix), weight);\n      }\n    }\n    return target.applyMatrix4(this.bindMatrixInverse);\n  }\n}\nSkinnedMesh.prototype.isSkinnedMesh = true;\nclass Bone extends Object3D {\n  constructor() {\n    super();\n    this.type = \"Bone\";\n  }\n}\nBone.prototype.isBone = true;\nconst _offsetMatrix = /* @__PURE__ */ new Matrix4();\nconst _identityMatrix = /* @__PURE__ */ new Matrix4();\nclass Skeleton {\n  constructor(bones = [], boneInverses = []) {\n    this.uuid = generateUUID();\n    this.bones = bones.slice(0);\n    this.boneInverses = boneInverses;\n    this.boneMatrices = null;\n    this.boneTexture = null;\n    this.boneTextureSize = 0;\n    this.frame = -1;\n    this.init();\n  }\n  init() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    this.boneMatrices = new Float32Array(bones.length * 16);\n    if (boneInverses.length === 0) {\n      this.calculateInverses();\n    } else {\n      if (bones.length !== boneInverses.length) {\n        console.warn(\"THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.\");\n        this.boneInverses = [];\n        for (let i = 0, il = this.bones.length; i < il; i++) {\n          this.boneInverses.push(new Matrix4());\n        }\n      }\n    }\n  }\n  calculateInverses() {\n    this.boneInverses.length = 0;\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const inverse = new Matrix4();\n      if (this.bones[i]) {\n        inverse.copy(this.bones[i].matrixWorld).invert();\n      }\n      this.boneInverses.push(inverse);\n    }\n  }\n  pose() {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        bone.matrixWorld.copy(this.boneInverses[i]).invert();\n      }\n    }\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone) {\n        if (bone.parent && bone.parent.isBone) {\n          bone.matrix.copy(bone.parent.matrixWorld).invert();\n          bone.matrix.multiply(bone.matrixWorld);\n        } else {\n          bone.matrix.copy(bone.matrixWorld);\n        }\n        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);\n      }\n    }\n  }\n  update() {\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    const boneMatrices = this.boneMatrices;\n    const boneTexture = this.boneTexture;\n    for (let i = 0, il = bones.length; i < il; i++) {\n      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;\n      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);\n      _offsetMatrix.toArray(boneMatrices, i * 16);\n    }\n    if (boneTexture !== null) {\n      boneTexture.needsUpdate = true;\n    }\n  }\n  clone() {\n    return new Skeleton(this.bones, this.boneInverses);\n  }\n  getBoneByName(name) {\n    for (let i = 0, il = this.bones.length; i < il; i++) {\n      const bone = this.bones[i];\n      if (bone.name === name) {\n        return bone;\n      }\n    }\n    return void 0;\n  }\n  dispose() {\n    if (this.boneTexture !== null) {\n      this.boneTexture.dispose();\n      this.boneTexture = null;\n    }\n  }\n  fromJSON(json, bones) {\n    this.uuid = json.uuid;\n    for (let i = 0, l = json.bones.length; i < l; i++) {\n      const uuid = json.bones[i];\n      let bone = bones[uuid];\n      if (bone === void 0) {\n        console.warn(\"THREE.Skeleton: No bone found with UUID:\", uuid);\n        bone = new Bone();\n      }\n      this.bones.push(bone);\n      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));\n    }\n    this.init();\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Skeleton\",\n        generator: \"Skeleton.toJSON\"\n      },\n      bones: [],\n      boneInverses: []\n    };\n    data.uuid = this.uuid;\n    const bones = this.bones;\n    const boneInverses = this.boneInverses;\n    for (let i = 0, l = bones.length; i < l; i++) {\n      const bone = bones[i];\n      data.bones.push(bone.uuid);\n      const boneInverse = boneInverses[i];\n      data.boneInverses.push(boneInverse.toArray());\n    }\n    return data;\n  }\n}\nconst _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();\nconst _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();\nconst _instanceIntersects = [];\nconst _mesh = /* @__PURE__ */ new Mesh();\nclass InstancedMesh extends Mesh {\n  constructor(geometry, material, count) {\n    super(geometry, material);\n    this.instanceMatrix = new BufferAttribute(new Float32Array(count * 16), 16);\n    this.instanceColor = null;\n    this.count = count;\n    this.frustumCulled = false;\n  }\n  copy(source) {\n    super.copy(source);\n    this.instanceMatrix.copy(source.instanceMatrix);\n    if (source.instanceColor !== null)\n      this.instanceColor = source.instanceColor.clone();\n    this.count = source.count;\n    return this;\n  }\n  getColorAt(index, color) {\n    color.fromArray(this.instanceColor.array, index * 3);\n  }\n  getMatrixAt(index, matrix) {\n    matrix.fromArray(this.instanceMatrix.array, index * 16);\n  }\n  raycast(raycaster, intersects2) {\n    const matrixWorld = this.matrixWorld;\n    const raycastTimes = this.count;\n    _mesh.geometry = this.geometry;\n    _mesh.material = this.material;\n    if (_mesh.material === void 0)\n      return;\n    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {\n      this.getMatrixAt(instanceId, _instanceLocalMatrix);\n      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);\n      _mesh.matrixWorld = _instanceWorldMatrix;\n      _mesh.raycast(raycaster, _instanceIntersects);\n      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {\n        const intersect = _instanceIntersects[i];\n        intersect.instanceId = instanceId;\n        intersect.object = this;\n        intersects2.push(intersect);\n      }\n      _instanceIntersects.length = 0;\n    }\n  }\n  setColorAt(index, color) {\n    if (this.instanceColor === null) {\n      this.instanceColor = new BufferAttribute(new Float32Array(this.count * 3), 3);\n    }\n    color.toArray(this.instanceColor.array, index * 3);\n  }\n  setMatrixAt(index, matrix) {\n    matrix.toArray(this.instanceMatrix.array, index * 16);\n  }\n  updateMorphTargets() {\n  }\n  dispose() {\n    this.dispatchEvent({type: \"dispose\"});\n  }\n}\nInstancedMesh.prototype.isInstancedMesh = true;\nclass LineBasicMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"LineBasicMaterial\";\n    this.color = new Color(16777215);\n    this.linewidth = 1;\n    this.linecap = \"round\";\n    this.linejoin = \"round\";\n    this.morphTargets = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.linewidth = source.linewidth;\n    this.linecap = source.linecap;\n    this.linejoin = source.linejoin;\n    this.morphTargets = source.morphTargets;\n    return this;\n  }\n}\nLineBasicMaterial.prototype.isLineBasicMaterial = true;\nconst _start$1 = /* @__PURE__ */ new Vector3();\nconst _end$1 = /* @__PURE__ */ new Vector3();\nconst _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();\nconst _ray$1 = /* @__PURE__ */ new Ray();\nconst _sphere$1 = /* @__PURE__ */ new Sphere();\nclass Line extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {\n    super();\n    this.type = \"Line\";\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source) {\n    super.copy(source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  computeLineDistances() {\n    const geometry = this.geometry;\n    if (geometry.isBufferGeometry) {\n      if (geometry.index === null) {\n        const positionAttribute = geometry.attributes.position;\n        const lineDistances = [0];\n        for (let i = 1, l = positionAttribute.count; i < l; i++) {\n          _start$1.fromBufferAttribute(positionAttribute, i - 1);\n          _end$1.fromBufferAttribute(positionAttribute, i);\n          lineDistances[i] = lineDistances[i - 1];\n          lineDistances[i] += _start$1.distanceTo(_end$1);\n        }\n        geometry.setAttribute(\"lineDistance\", new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn(\"THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\");\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\"THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n    }\n    return this;\n  }\n  raycast(raycaster, intersects2) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Line.threshold;\n    const drawRange = geometry.drawRange;\n    if (geometry.boundingSphere === null)\n      geometry.computeBoundingSphere();\n    _sphere$1.copy(geometry.boundingSphere);\n    _sphere$1.applyMatrix4(matrixWorld);\n    _sphere$1.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere$1) === false)\n      return;\n    _inverseMatrix$1.copy(matrixWorld).invert();\n    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    const vStart = new Vector3();\n    const vEnd = new Vector3();\n    const interSegment = new Vector3();\n    const interRay = new Vector3();\n    const step = this.isLineSegments ? 2 : 1;\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start, l = end - 1; i < l; i += step) {\n          const a = index.getX(i);\n          const b = index.getX(i + 1);\n          vStart.fromBufferAttribute(positionAttribute, a);\n          vEnd.fromBufferAttribute(positionAttribute, b);\n          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n          if (distSq > localThresholdSq)\n            continue;\n          interRay.applyMatrix4(this.matrixWorld);\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far)\n            continue;\n          intersects2.push({\n            distance,\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n        for (let i = start, l = end - 1; i < l; i += step) {\n          vStart.fromBufferAttribute(positionAttribute, i);\n          vEnd.fromBufferAttribute(positionAttribute, i + 1);\n          const distSq = _ray$1.distanceSqToSegment(vStart, vEnd, interRay, interSegment);\n          if (distSq > localThresholdSq)\n            continue;\n          interRay.applyMatrix4(this.matrixWorld);\n          const distance = raycaster.ray.origin.distanceTo(interRay);\n          if (distance < raycaster.near || distance > raycaster.far)\n            continue;\n          intersects2.push({\n            distance,\n            point: interSegment.clone().applyMatrix4(this.matrixWorld),\n            index: i,\n            face: null,\n            faceIndex: null,\n            object: this\n          });\n        }\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\"THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n      if (morphTargets !== void 0 && morphTargets.length > 0) {\n        console.error(\"THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      }\n    }\n  }\n}\nLine.prototype.isLine = true;\nconst _start = /* @__PURE__ */ new Vector3();\nconst _end = /* @__PURE__ */ new Vector3();\nclass LineSegments extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = \"LineSegments\";\n  }\n  computeLineDistances() {\n    const geometry = this.geometry;\n    if (geometry.isBufferGeometry) {\n      if (geometry.index === null) {\n        const positionAttribute = geometry.attributes.position;\n        const lineDistances = [];\n        for (let i = 0, l = positionAttribute.count; i < l; i += 2) {\n          _start.fromBufferAttribute(positionAttribute, i);\n          _end.fromBufferAttribute(positionAttribute, i + 1);\n          lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];\n          lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);\n        }\n        geometry.setAttribute(\"lineDistance\", new Float32BufferAttribute(lineDistances, 1));\n      } else {\n        console.warn(\"THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.\");\n      }\n    } else if (geometry.isGeometry) {\n      console.error(\"THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n    }\n    return this;\n  }\n}\nLineSegments.prototype.isLineSegments = true;\nclass LineLoop extends Line {\n  constructor(geometry, material) {\n    super(geometry, material);\n    this.type = \"LineLoop\";\n  }\n}\nLineLoop.prototype.isLineLoop = true;\nclass PointsMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"PointsMaterial\";\n    this.color = new Color(16777215);\n    this.map = null;\n    this.alphaMap = null;\n    this.size = 1;\n    this.sizeAttenuation = true;\n    this.morphTargets = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.alphaMap = source.alphaMap;\n    this.size = source.size;\n    this.sizeAttenuation = source.sizeAttenuation;\n    this.morphTargets = source.morphTargets;\n    return this;\n  }\n}\nPointsMaterial.prototype.isPointsMaterial = true;\nconst _inverseMatrix = /* @__PURE__ */ new Matrix4();\nconst _ray = /* @__PURE__ */ new Ray();\nconst _sphere = /* @__PURE__ */ new Sphere();\nconst _position$2 = /* @__PURE__ */ new Vector3();\nclass Points extends Object3D {\n  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {\n    super();\n    this.type = \"Points\";\n    this.geometry = geometry;\n    this.material = material;\n    this.updateMorphTargets();\n  }\n  copy(source) {\n    super.copy(source);\n    this.material = source.material;\n    this.geometry = source.geometry;\n    return this;\n  }\n  raycast(raycaster, intersects2) {\n    const geometry = this.geometry;\n    const matrixWorld = this.matrixWorld;\n    const threshold = raycaster.params.Points.threshold;\n    const drawRange = geometry.drawRange;\n    if (geometry.boundingSphere === null)\n      geometry.computeBoundingSphere();\n    _sphere.copy(geometry.boundingSphere);\n    _sphere.applyMatrix4(matrixWorld);\n    _sphere.radius += threshold;\n    if (raycaster.ray.intersectsSphere(_sphere) === false)\n      return;\n    _inverseMatrix.copy(matrixWorld).invert();\n    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);\n    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);\n    const localThresholdSq = localThreshold * localThreshold;\n    if (geometry.isBufferGeometry) {\n      const index = geometry.index;\n      const attributes = geometry.attributes;\n      const positionAttribute = attributes.position;\n      if (index !== null) {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(index.count, drawRange.start + drawRange.count);\n        for (let i = start, il = end; i < il; i++) {\n          const a = index.getX(i);\n          _position$2.fromBufferAttribute(positionAttribute, a);\n          testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects2, this);\n        }\n      } else {\n        const start = Math.max(0, drawRange.start);\n        const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);\n        for (let i = start, l = end; i < l; i++) {\n          _position$2.fromBufferAttribute(positionAttribute, i);\n          testPoint(_position$2, i, localThresholdSq, matrixWorld, raycaster, intersects2, this);\n        }\n      }\n    } else {\n      console.error(\"THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n    }\n  }\n  updateMorphTargets() {\n    const geometry = this.geometry;\n    if (geometry.isBufferGeometry) {\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    } else {\n      const morphTargets = geometry.morphTargets;\n      if (morphTargets !== void 0 && morphTargets.length > 0) {\n        console.error(\"THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      }\n    }\n  }\n}\nPoints.prototype.isPoints = true;\nfunction testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects2, object) {\n  const rayPointDistanceSq = _ray.distanceSqToPoint(point);\n  if (rayPointDistanceSq < localThresholdSq) {\n    const intersectPoint = new Vector3();\n    _ray.closestPointToPoint(point, intersectPoint);\n    intersectPoint.applyMatrix4(matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(intersectPoint);\n    if (distance < raycaster.near || distance > raycaster.far)\n      return;\n    intersects2.push({\n      distance,\n      distanceToRay: Math.sqrt(rayPointDistanceSq),\n      point: intersectPoint,\n      index,\n      face: null,\n      object\n    });\n  }\n}\nclass VideoTexture extends Texture {\n  constructor(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.format = format !== void 0 ? format : RGBFormat;\n    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter;\n    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter;\n    this.generateMipmaps = false;\n    const scope = this;\n    function updateVideo() {\n      scope.needsUpdate = true;\n      video.requestVideoFrameCallback(updateVideo);\n    }\n    if (\"requestVideoFrameCallback\" in video) {\n      video.requestVideoFrameCallback(updateVideo);\n    }\n  }\n  clone() {\n    return new this.constructor(this.image).copy(this);\n  }\n  update() {\n    const video = this.image;\n    const hasVideoFrameCallback = \"requestVideoFrameCallback\" in video;\n    if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {\n      this.needsUpdate = true;\n    }\n  }\n}\nVideoTexture.prototype.isVideoTexture = true;\nclass CompressedTexture extends Texture {\n  constructor(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding) {\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding);\n    this.image = {width, height};\n    this.mipmaps = mipmaps;\n    this.flipY = false;\n    this.generateMipmaps = false;\n  }\n}\nCompressedTexture.prototype.isCompressedTexture = true;\nclass CanvasTexture extends Texture {\n  constructor(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {\n    super(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.needsUpdate = true;\n  }\n}\nCanvasTexture.prototype.isCanvasTexture = true;\nclass DepthTexture extends Texture {\n  constructor(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format) {\n    format = format !== void 0 ? format : DepthFormat;\n    if (format !== DepthFormat && format !== DepthStencilFormat) {\n      throw new Error(\"DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat\");\n    }\n    if (type === void 0 && format === DepthFormat)\n      type = UnsignedShortType;\n    if (type === void 0 && format === DepthStencilFormat)\n      type = UnsignedInt248Type;\n    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);\n    this.image = {width, height};\n    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter;\n    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter;\n    this.flipY = false;\n    this.generateMipmaps = false;\n  }\n}\nDepthTexture.prototype.isDepthTexture = true;\nclass CircleGeometry extends BufferGeometry {\n  constructor(radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = \"CircleGeometry\";\n    this.parameters = {\n      radius,\n      segments,\n      thetaStart,\n      thetaLength\n    };\n    segments = Math.max(3, segments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const vertex = new Vector3();\n    const uv = new Vector2();\n    vertices.push(0, 0, 0);\n    normals.push(0, 0, 1);\n    uvs.push(0.5, 0.5);\n    for (let s = 0, i = 3; s <= segments; s++, i += 3) {\n      const segment = thetaStart + s / segments * thetaLength;\n      vertex.x = radius * Math.cos(segment);\n      vertex.y = radius * Math.sin(segment);\n      vertices.push(vertex.x, vertex.y, vertex.z);\n      normals.push(0, 0, 1);\n      uv.x = (vertices[i] / radius + 1) / 2;\n      uv.y = (vertices[i + 1] / radius + 1) / 2;\n      uvs.push(uv.x, uv.y);\n    }\n    for (let i = 1; i <= segments; i++) {\n      indices.push(i, i + 1, 0);\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n}\nclass CylinderGeometry extends BufferGeometry {\n  constructor(radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = \"CylinderGeometry\";\n    this.parameters = {\n      radiusTop,\n      radiusBottom,\n      height,\n      radialSegments,\n      heightSegments,\n      openEnded,\n      thetaStart,\n      thetaLength\n    };\n    const scope = this;\n    radialSegments = Math.floor(radialSegments);\n    heightSegments = Math.floor(heightSegments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    let index = 0;\n    const indexArray = [];\n    const halfHeight = height / 2;\n    let groupStart = 0;\n    generateTorso();\n    if (openEnded === false) {\n      if (radiusTop > 0)\n        generateCap(true);\n      if (radiusBottom > 0)\n        generateCap(false);\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function generateTorso() {\n      const normal = new Vector3();\n      const vertex = new Vector3();\n      let groupCount = 0;\n      const slope = (radiusBottom - radiusTop) / height;\n      for (let y = 0; y <= heightSegments; y++) {\n        const indexRow = [];\n        const v = y / heightSegments;\n        const radius = v * (radiusBottom - radiusTop) + radiusTop;\n        for (let x = 0; x <= radialSegments; x++) {\n          const u = x / radialSegments;\n          const theta = u * thetaLength + thetaStart;\n          const sinTheta = Math.sin(theta);\n          const cosTheta = Math.cos(theta);\n          vertex.x = radius * sinTheta;\n          vertex.y = -v * height + halfHeight;\n          vertex.z = radius * cosTheta;\n          vertices.push(vertex.x, vertex.y, vertex.z);\n          normal.set(sinTheta, slope, cosTheta).normalize();\n          normals.push(normal.x, normal.y, normal.z);\n          uvs.push(u, 1 - v);\n          indexRow.push(index++);\n        }\n        indexArray.push(indexRow);\n      }\n      for (let x = 0; x < radialSegments; x++) {\n        for (let y = 0; y < heightSegments; y++) {\n          const a = indexArray[y][x];\n          const b = indexArray[y + 1][x];\n          const c = indexArray[y + 1][x + 1];\n          const d = indexArray[y][x + 1];\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n          groupCount += 6;\n        }\n      }\n      scope.addGroup(groupStart, groupCount, 0);\n      groupStart += groupCount;\n    }\n    function generateCap(top) {\n      const centerIndexStart = index;\n      const uv = new Vector2();\n      const vertex = new Vector3();\n      let groupCount = 0;\n      const radius = top === true ? radiusTop : radiusBottom;\n      const sign2 = top === true ? 1 : -1;\n      for (let x = 1; x <= radialSegments; x++) {\n        vertices.push(0, halfHeight * sign2, 0);\n        normals.push(0, sign2, 0);\n        uvs.push(0.5, 0.5);\n        index++;\n      }\n      const centerIndexEnd = index;\n      for (let x = 0; x <= radialSegments; x++) {\n        const u = x / radialSegments;\n        const theta = u * thetaLength + thetaStart;\n        const cosTheta = Math.cos(theta);\n        const sinTheta = Math.sin(theta);\n        vertex.x = radius * sinTheta;\n        vertex.y = halfHeight * sign2;\n        vertex.z = radius * cosTheta;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        normals.push(0, sign2, 0);\n        uv.x = cosTheta * 0.5 + 0.5;\n        uv.y = sinTheta * 0.5 * sign2 + 0.5;\n        uvs.push(uv.x, uv.y);\n        index++;\n      }\n      for (let x = 0; x < radialSegments; x++) {\n        const c = centerIndexStart + x;\n        const i = centerIndexEnd + x;\n        if (top === true) {\n          indices.push(i, i + 1, c);\n        } else {\n          indices.push(i + 1, i, c);\n        }\n        groupCount += 3;\n      }\n      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);\n      groupStart += groupCount;\n    }\n  }\n}\nclass ConeGeometry extends CylinderGeometry {\n  constructor(radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super(0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength);\n    this.type = \"ConeGeometry\";\n    this.parameters = {\n      radius,\n      height,\n      radialSegments,\n      heightSegments,\n      openEnded,\n      thetaStart,\n      thetaLength\n    };\n  }\n}\nclass PolyhedronGeometry extends BufferGeometry {\n  constructor(vertices, indices, radius = 1, detail = 0) {\n    super();\n    this.type = \"PolyhedronGeometry\";\n    this.parameters = {\n      vertices,\n      indices,\n      radius,\n      detail\n    };\n    const vertexBuffer = [];\n    const uvBuffer = [];\n    subdivide(detail);\n    applyRadius(radius);\n    generateUVs();\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertexBuffer, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(vertexBuffer.slice(), 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvBuffer, 2));\n    if (detail === 0) {\n      this.computeVertexNormals();\n    } else {\n      this.normalizeNormals();\n    }\n    function subdivide(detail2) {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3();\n      for (let i = 0; i < indices.length; i += 3) {\n        getVertexByIndex(indices[i + 0], a);\n        getVertexByIndex(indices[i + 1], b);\n        getVertexByIndex(indices[i + 2], c);\n        subdivideFace(a, b, c, detail2);\n      }\n    }\n    function subdivideFace(a, b, c, detail2) {\n      const cols = detail2 + 1;\n      const v = [];\n      for (let i = 0; i <= cols; i++) {\n        v[i] = [];\n        const aj = a.clone().lerp(c, i / cols);\n        const bj = b.clone().lerp(c, i / cols);\n        const rows = cols - i;\n        for (let j = 0; j <= rows; j++) {\n          if (j === 0 && i === cols) {\n            v[i][j] = aj;\n          } else {\n            v[i][j] = aj.clone().lerp(bj, j / rows);\n          }\n        }\n      }\n      for (let i = 0; i < cols; i++) {\n        for (let j = 0; j < 2 * (cols - i) - 1; j++) {\n          const k = Math.floor(j / 2);\n          if (j % 2 === 0) {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k]);\n            pushVertex(v[i][k]);\n          } else {\n            pushVertex(v[i][k + 1]);\n            pushVertex(v[i + 1][k + 1]);\n            pushVertex(v[i + 1][k]);\n          }\n        }\n      }\n    }\n    function applyRadius(radius2) {\n      const vertex = new Vector3();\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        vertex.normalize().multiplyScalar(radius2);\n        vertexBuffer[i + 0] = vertex.x;\n        vertexBuffer[i + 1] = vertex.y;\n        vertexBuffer[i + 2] = vertex.z;\n      }\n    }\n    function generateUVs() {\n      const vertex = new Vector3();\n      for (let i = 0; i < vertexBuffer.length; i += 3) {\n        vertex.x = vertexBuffer[i + 0];\n        vertex.y = vertexBuffer[i + 1];\n        vertex.z = vertexBuffer[i + 2];\n        const u = azimuth(vertex) / 2 / Math.PI + 0.5;\n        const v = inclination(vertex) / Math.PI + 0.5;\n        uvBuffer.push(u, 1 - v);\n      }\n      correctUVs();\n      correctSeam();\n    }\n    function correctSeam() {\n      for (let i = 0; i < uvBuffer.length; i += 6) {\n        const x0 = uvBuffer[i + 0];\n        const x1 = uvBuffer[i + 2];\n        const x2 = uvBuffer[i + 4];\n        const max = Math.max(x0, x1, x2);\n        const min = Math.min(x0, x1, x2);\n        if (max > 0.9 && min < 0.1) {\n          if (x0 < 0.2)\n            uvBuffer[i + 0] += 1;\n          if (x1 < 0.2)\n            uvBuffer[i + 2] += 1;\n          if (x2 < 0.2)\n            uvBuffer[i + 4] += 1;\n        }\n      }\n    }\n    function pushVertex(vertex) {\n      vertexBuffer.push(vertex.x, vertex.y, vertex.z);\n    }\n    function getVertexByIndex(index, vertex) {\n      const stride = index * 3;\n      vertex.x = vertices[stride + 0];\n      vertex.y = vertices[stride + 1];\n      vertex.z = vertices[stride + 2];\n    }\n    function correctUVs() {\n      const a = new Vector3();\n      const b = new Vector3();\n      const c = new Vector3();\n      const centroid = new Vector3();\n      const uvA = new Vector2();\n      const uvB = new Vector2();\n      const uvC = new Vector2();\n      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {\n        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);\n        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);\n        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);\n        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);\n        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);\n        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);\n        centroid.copy(a).add(b).add(c).divideScalar(3);\n        const azi = azimuth(centroid);\n        correctUV(uvA, j + 0, a, azi);\n        correctUV(uvB, j + 2, b, azi);\n        correctUV(uvC, j + 4, c, azi);\n      }\n    }\n    function correctUV(uv, stride, vector, azimuth2) {\n      if (azimuth2 < 0 && uv.x === 1) {\n        uvBuffer[stride] = uv.x - 1;\n      }\n      if (vector.x === 0 && vector.z === 0) {\n        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5;\n      }\n    }\n    function azimuth(vector) {\n      return Math.atan2(vector.z, -vector.x);\n    }\n    function inclination(vector) {\n      return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));\n    }\n  }\n}\nclass DodecahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const t = (1 + Math.sqrt(5)) / 2;\n    const r = 1 / t;\n    const vertices = [\n      -1,\n      -1,\n      -1,\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      -1,\n      -1,\n      1,\n      1,\n      1,\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      1,\n      1,\n      -1,\n      1,\n      1,\n      1,\n      0,\n      -r,\n      -t,\n      0,\n      -r,\n      t,\n      0,\n      r,\n      -t,\n      0,\n      r,\n      t,\n      -r,\n      -t,\n      0,\n      -r,\n      t,\n      0,\n      r,\n      -t,\n      0,\n      r,\n      t,\n      0,\n      -t,\n      0,\n      -r,\n      t,\n      0,\n      -r,\n      -t,\n      0,\n      r,\n      t,\n      0,\n      r\n    ];\n    const indices = [\n      3,\n      11,\n      7,\n      3,\n      7,\n      15,\n      3,\n      15,\n      13,\n      7,\n      19,\n      17,\n      7,\n      17,\n      6,\n      7,\n      6,\n      15,\n      17,\n      4,\n      8,\n      17,\n      8,\n      10,\n      17,\n      10,\n      6,\n      8,\n      0,\n      16,\n      8,\n      16,\n      2,\n      8,\n      2,\n      10,\n      0,\n      12,\n      1,\n      0,\n      1,\n      18,\n      0,\n      18,\n      16,\n      6,\n      10,\n      2,\n      6,\n      2,\n      13,\n      6,\n      13,\n      15,\n      2,\n      16,\n      18,\n      2,\n      18,\n      3,\n      2,\n      3,\n      13,\n      18,\n      1,\n      9,\n      18,\n      9,\n      11,\n      18,\n      11,\n      3,\n      4,\n      14,\n      12,\n      4,\n      12,\n      0,\n      4,\n      0,\n      8,\n      11,\n      9,\n      5,\n      11,\n      5,\n      19,\n      11,\n      19,\n      7,\n      19,\n      5,\n      14,\n      19,\n      14,\n      4,\n      19,\n      4,\n      17,\n      1,\n      12,\n      14,\n      1,\n      14,\n      5,\n      1,\n      5,\n      9\n    ];\n    super(vertices, indices, radius, detail);\n    this.type = \"DodecahedronGeometry\";\n    this.parameters = {\n      radius,\n      detail\n    };\n  }\n}\nconst _v0 = new Vector3();\nconst _v1$1 = new Vector3();\nconst _normal = new Vector3();\nconst _triangle = new Triangle();\nclass EdgesGeometry extends BufferGeometry {\n  constructor(geometry, thresholdAngle) {\n    super();\n    this.type = \"EdgesGeometry\";\n    this.parameters = {\n      thresholdAngle\n    };\n    thresholdAngle = thresholdAngle !== void 0 ? thresholdAngle : 1;\n    if (geometry.isGeometry === true) {\n      console.error(\"THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      return;\n    }\n    const precisionPoints = 4;\n    const precision = Math.pow(10, precisionPoints);\n    const thresholdDot = Math.cos(DEG2RAD * thresholdAngle);\n    const indexAttr = geometry.getIndex();\n    const positionAttr = geometry.getAttribute(\"position\");\n    const indexCount = indexAttr ? indexAttr.count : positionAttr.count;\n    const indexArr = [0, 0, 0];\n    const vertKeys = [\"a\", \"b\", \"c\"];\n    const hashes = new Array(3);\n    const edgeData = {};\n    const vertices = [];\n    for (let i = 0; i < indexCount; i += 3) {\n      if (indexAttr) {\n        indexArr[0] = indexAttr.getX(i);\n        indexArr[1] = indexAttr.getX(i + 1);\n        indexArr[2] = indexAttr.getX(i + 2);\n      } else {\n        indexArr[0] = i;\n        indexArr[1] = i + 1;\n        indexArr[2] = i + 2;\n      }\n      const {a, b, c} = _triangle;\n      a.fromBufferAttribute(positionAttr, indexArr[0]);\n      b.fromBufferAttribute(positionAttr, indexArr[1]);\n      c.fromBufferAttribute(positionAttr, indexArr[2]);\n      _triangle.getNormal(_normal);\n      hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;\n      hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;\n      hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;\n      if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {\n        continue;\n      }\n      for (let j = 0; j < 3; j++) {\n        const jNext = (j + 1) % 3;\n        const vecHash0 = hashes[j];\n        const vecHash1 = hashes[jNext];\n        const v0 = _triangle[vertKeys[j]];\n        const v1 = _triangle[vertKeys[jNext]];\n        const hash = `${vecHash0}_${vecHash1}`;\n        const reverseHash = `${vecHash1}_${vecHash0}`;\n        if (reverseHash in edgeData && edgeData[reverseHash]) {\n          if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {\n            vertices.push(v0.x, v0.y, v0.z);\n            vertices.push(v1.x, v1.y, v1.z);\n          }\n          edgeData[reverseHash] = null;\n        } else if (!(hash in edgeData)) {\n          edgeData[hash] = {\n            index0: indexArr[j],\n            index1: indexArr[jNext],\n            normal: _normal.clone()\n          };\n        }\n      }\n    }\n    for (const key in edgeData) {\n      if (edgeData[key]) {\n        const {index0, index1} = edgeData[key];\n        _v0.fromBufferAttribute(positionAttr, index0);\n        _v1$1.fromBufferAttribute(positionAttr, index1);\n        vertices.push(_v0.x, _v0.y, _v0.z);\n        vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);\n      }\n    }\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n  }\n}\nconst Earcut = {\n  triangulate: function(data, holeIndices, dim) {\n    dim = dim || 2;\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n    let outerNode = linkedList(data, 0, outerLen, dim, true);\n    const triangles = [];\n    if (!outerNode || outerNode.next === outerNode.prev)\n      return triangles;\n    let minX, minY, maxX, maxY, x, y, invSize;\n    if (hasHoles)\n      outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n    if (data.length > 80 * dim) {\n      minX = maxX = data[0];\n      minY = maxY = data[1];\n      for (let i = dim; i < outerLen; i += dim) {\n        x = data[i];\n        y = data[i + 1];\n        if (x < minX)\n          minX = x;\n        if (y < minY)\n          minY = y;\n        if (x > maxX)\n          maxX = x;\n        if (y > maxY)\n          maxY = y;\n      }\n      invSize = Math.max(maxX - minX, maxY - minY);\n      invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n    return triangles;\n  }\n};\nfunction linkedList(data, start, end, dim, clockwise) {\n  let i, last;\n  if (clockwise === signedArea(data, start, end, dim) > 0) {\n    for (i = start; i < end; i += dim)\n      last = insertNode(i, data[i], data[i + 1], last);\n  } else {\n    for (i = end - dim; i >= start; i -= dim)\n      last = insertNode(i, data[i], data[i + 1], last);\n  }\n  if (last && equals(last, last.next)) {\n    removeNode(last);\n    last = last.next;\n  }\n  return last;\n}\nfunction filterPoints(start, end) {\n  if (!start)\n    return start;\n  if (!end)\n    end = start;\n  let p = start, again;\n  do {\n    again = false;\n    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n      removeNode(p);\n      p = end = p.prev;\n      if (p === p.next)\n        break;\n      again = true;\n    } else {\n      p = p.next;\n    }\n  } while (again || p !== end);\n  return end;\n}\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n  if (!ear)\n    return;\n  if (!pass && invSize)\n    indexCurve(ear, minX, minY, invSize);\n  let stop = ear, prev, next;\n  while (ear.prev !== ear.next) {\n    prev = ear.prev;\n    next = ear.next;\n    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n      triangles.push(prev.i / dim);\n      triangles.push(ear.i / dim);\n      triangles.push(next.i / dim);\n      removeNode(ear);\n      ear = next.next;\n      stop = next.next;\n      continue;\n    }\n    ear = next;\n    if (ear === stop) {\n      if (!pass) {\n        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n      } else if (pass === 1) {\n        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n      } else if (pass === 2) {\n        splitEarcut(ear, triangles, dim, minX, minY, invSize);\n      }\n      break;\n    }\n  }\n}\nfunction isEar(ear) {\n  const a = ear.prev, b = ear, c = ear.next;\n  if (area(a, b, c) >= 0)\n    return false;\n  let p = ear.next.next;\n  while (p !== ear.prev) {\n    if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)\n      return false;\n    p = p.next;\n  }\n  return true;\n}\nfunction isEarHashed(ear, minX, minY, invSize) {\n  const a = ear.prev, b = ear, c = ear.next;\n  if (area(a, b, c) >= 0)\n    return false;\n  const minTX = a.x < b.x ? a.x < c.x ? a.x : c.x : b.x < c.x ? b.x : c.x, minTY = a.y < b.y ? a.y < c.y ? a.y : c.y : b.y < c.y ? b.y : c.y, maxTX = a.x > b.x ? a.x > c.x ? a.x : c.x : b.x > c.x ? b.x : c.x, maxTY = a.y > b.y ? a.y > c.y ? a.y : c.y : b.y > c.y ? b.y : c.y;\n  const minZ = zOrder(minTX, minTY, minX, minY, invSize), maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n  let p = ear.prevZ, n = ear.nextZ;\n  while (p && p.z >= minZ && n && n.z <= maxZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)\n      return false;\n    p = p.prevZ;\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)\n      return false;\n    n = n.nextZ;\n  }\n  while (p && p.z >= minZ) {\n    if (p !== ear.prev && p !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && area(p.prev, p, p.next) >= 0)\n      return false;\n    p = p.prevZ;\n  }\n  while (n && n.z <= maxZ) {\n    if (n !== ear.prev && n !== ear.next && pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && area(n.prev, n, n.next) >= 0)\n      return false;\n    n = n.nextZ;\n  }\n  return true;\n}\nfunction cureLocalIntersections(start, triangles, dim) {\n  let p = start;\n  do {\n    const a = p.prev, b = p.next.next;\n    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n      triangles.push(a.i / dim);\n      triangles.push(p.i / dim);\n      triangles.push(b.i / dim);\n      removeNode(p);\n      removeNode(p.next);\n      p = start = b;\n    }\n    p = p.next;\n  } while (p !== start);\n  return filterPoints(p);\n}\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n  let a = start;\n  do {\n    let b = a.next.next;\n    while (b !== a.prev) {\n      if (a.i !== b.i && isValidDiagonal(a, b)) {\n        let c = splitPolygon(a, b);\n        a = filterPoints(a, a.next);\n        c = filterPoints(c, c.next);\n        earcutLinked(a, triangles, dim, minX, minY, invSize);\n        earcutLinked(c, triangles, dim, minX, minY, invSize);\n        return;\n      }\n      b = b.next;\n    }\n    a = a.next;\n  } while (a !== start);\n}\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n  const queue = [];\n  let i, len, start, end, list;\n  for (i = 0, len = holeIndices.length; i < len; i++) {\n    start = holeIndices[i] * dim;\n    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n    list = linkedList(data, start, end, dim, false);\n    if (list === list.next)\n      list.steiner = true;\n    queue.push(getLeftmost(list));\n  }\n  queue.sort(compareX);\n  for (i = 0; i < queue.length; i++) {\n    eliminateHole(queue[i], outerNode);\n    outerNode = filterPoints(outerNode, outerNode.next);\n  }\n  return outerNode;\n}\nfunction compareX(a, b) {\n  return a.x - b.x;\n}\nfunction eliminateHole(hole, outerNode) {\n  outerNode = findHoleBridge(hole, outerNode);\n  if (outerNode) {\n    const b = splitPolygon(outerNode, hole);\n    filterPoints(outerNode, outerNode.next);\n    filterPoints(b, b.next);\n  }\n}\nfunction findHoleBridge(hole, outerNode) {\n  let p = outerNode;\n  const hx = hole.x;\n  const hy = hole.y;\n  let qx = -Infinity, m;\n  do {\n    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n      const x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n      if (x <= hx && x > qx) {\n        qx = x;\n        if (x === hx) {\n          if (hy === p.y)\n            return p;\n          if (hy === p.next.y)\n            return p.next;\n        }\n        m = p.x < p.next.x ? p : p.next;\n      }\n    }\n    p = p.next;\n  } while (p !== outerNode);\n  if (!m)\n    return null;\n  if (hx === qx)\n    return m;\n  const stop = m, mx = m.x, my = m.y;\n  let tanMin = Infinity, tan;\n  p = m;\n  do {\n    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n      tan = Math.abs(hy - p.y) / (hx - p.x);\n      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {\n        m = p;\n        tanMin = tan;\n      }\n    }\n    p = p.next;\n  } while (p !== stop);\n  return m;\n}\nfunction sectorContainsSector(m, p) {\n  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\nfunction indexCurve(start, minX, minY, invSize) {\n  let p = start;\n  do {\n    if (p.z === null)\n      p.z = zOrder(p.x, p.y, minX, minY, invSize);\n    p.prevZ = p.prev;\n    p.nextZ = p.next;\n    p = p.next;\n  } while (p !== start);\n  p.prevZ.nextZ = null;\n  p.prevZ = null;\n  sortLinked(p);\n}\nfunction sortLinked(list) {\n  let i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;\n  do {\n    p = list;\n    list = null;\n    tail = null;\n    numMerges = 0;\n    while (p) {\n      numMerges++;\n      q = p;\n      pSize = 0;\n      for (i = 0; i < inSize; i++) {\n        pSize++;\n        q = q.nextZ;\n        if (!q)\n          break;\n      }\n      qSize = inSize;\n      while (pSize > 0 || qSize > 0 && q) {\n        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n          e = p;\n          p = p.nextZ;\n          pSize--;\n        } else {\n          e = q;\n          q = q.nextZ;\n          qSize--;\n        }\n        if (tail)\n          tail.nextZ = e;\n        else\n          list = e;\n        e.prevZ = tail;\n        tail = e;\n      }\n      p = q;\n    }\n    tail.nextZ = null;\n    inSize *= 2;\n  } while (numMerges > 1);\n  return list;\n}\nfunction zOrder(x, y, minX, minY, invSize) {\n  x = 32767 * (x - minX) * invSize;\n  y = 32767 * (y - minY) * invSize;\n  x = (x | x << 8) & 16711935;\n  x = (x | x << 4) & 252645135;\n  x = (x | x << 2) & 858993459;\n  x = (x | x << 1) & 1431655765;\n  y = (y | y << 8) & 16711935;\n  y = (y | y << 4) & 252645135;\n  y = (y | y << 2) & 858993459;\n  y = (y | y << 1) & 1431655765;\n  return x | y << 1;\n}\nfunction getLeftmost(start) {\n  let p = start, leftmost = start;\n  do {\n    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)\n      leftmost = p;\n    p = p.next;\n  } while (p !== start);\n  return leftmost;\n}\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {\n  return (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 && (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 && (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0;\n}\nfunction isValidDiagonal(a, b) {\n  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);\n}\nfunction area(p, q, r) {\n  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\nfunction equals(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\nfunction intersects(p1, q1, p2, q2) {\n  const o1 = sign(area(p1, q1, p2));\n  const o2 = sign(area(p1, q1, q2));\n  const o3 = sign(area(p2, q2, p1));\n  const o4 = sign(area(p2, q2, q1));\n  if (o1 !== o2 && o3 !== o4)\n    return true;\n  if (o1 === 0 && onSegment(p1, p2, q1))\n    return true;\n  if (o2 === 0 && onSegment(p1, q2, q1))\n    return true;\n  if (o3 === 0 && onSegment(p2, p1, q2))\n    return true;\n  if (o4 === 0 && onSegment(p2, q1, q2))\n    return true;\n  return false;\n}\nfunction onSegment(p, q, r) {\n  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\nfunction sign(num) {\n  return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\nfunction intersectsPolygon(a, b) {\n  let p = a;\n  do {\n    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))\n      return true;\n    p = p.next;\n  } while (p !== a);\n  return false;\n}\nfunction locallyInside(a, b) {\n  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\nfunction middleInside(a, b) {\n  let p = a, inside = false;\n  const px2 = (a.x + b.x) / 2, py2 = (a.y + b.y) / 2;\n  do {\n    if (p.y > py2 !== p.next.y > py2 && p.next.y !== p.y && px2 < (p.next.x - p.x) * (py2 - p.y) / (p.next.y - p.y) + p.x)\n      inside = !inside;\n    p = p.next;\n  } while (p !== a);\n  return inside;\n}\nfunction splitPolygon(a, b) {\n  const a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;\n  a.next = b;\n  b.prev = a;\n  a2.next = an;\n  an.prev = a2;\n  b2.next = a2;\n  a2.prev = b2;\n  bp.next = b2;\n  b2.prev = bp;\n  return b2;\n}\nfunction insertNode(i, x, y, last) {\n  const p = new Node(i, x, y);\n  if (!last) {\n    p.prev = p;\n    p.next = p;\n  } else {\n    p.next = last.next;\n    p.prev = last;\n    last.next.prev = p;\n    last.next = p;\n  }\n  return p;\n}\nfunction removeNode(p) {\n  p.next.prev = p.prev;\n  p.prev.next = p.next;\n  if (p.prevZ)\n    p.prevZ.nextZ = p.nextZ;\n  if (p.nextZ)\n    p.nextZ.prevZ = p.prevZ;\n}\nfunction Node(i, x, y) {\n  this.i = i;\n  this.x = x;\n  this.y = y;\n  this.prev = null;\n  this.next = null;\n  this.z = null;\n  this.prevZ = null;\n  this.nextZ = null;\n  this.steiner = false;\n}\nfunction signedArea(data, start, end, dim) {\n  let sum = 0;\n  for (let i = start, j = end - dim; i < end; i += dim) {\n    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n    j = i;\n  }\n  return sum;\n}\nclass ShapeUtils {\n  static area(contour) {\n    const n = contour.length;\n    let a = 0;\n    for (let p = n - 1, q = 0; q < n; p = q++) {\n      a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;\n    }\n    return a * 0.5;\n  }\n  static isClockWise(pts) {\n    return ShapeUtils.area(pts) < 0;\n  }\n  static triangulateShape(contour, holes) {\n    const vertices = [];\n    const holeIndices = [];\n    const faces = [];\n    removeDupEndPts(contour);\n    addContour(vertices, contour);\n    let holeIndex = contour.length;\n    holes.forEach(removeDupEndPts);\n    for (let i = 0; i < holes.length; i++) {\n      holeIndices.push(holeIndex);\n      holeIndex += holes[i].length;\n      addContour(vertices, holes[i]);\n    }\n    const triangles = Earcut.triangulate(vertices, holeIndices);\n    for (let i = 0; i < triangles.length; i += 3) {\n      faces.push(triangles.slice(i, i + 3));\n    }\n    return faces;\n  }\n}\nfunction removeDupEndPts(points) {\n  const l = points.length;\n  if (l > 2 && points[l - 1].equals(points[0])) {\n    points.pop();\n  }\n}\nfunction addContour(vertices, contour) {\n  for (let i = 0; i < contour.length; i++) {\n    vertices.push(contour[i].x);\n    vertices.push(contour[i].y);\n  }\n}\nclass ExtrudeGeometry extends BufferGeometry {\n  constructor(shapes, options) {\n    super();\n    this.type = \"ExtrudeGeometry\";\n    this.parameters = {\n      shapes,\n      options\n    };\n    shapes = Array.isArray(shapes) ? shapes : [shapes];\n    const scope = this;\n    const verticesArray = [];\n    const uvArray = [];\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      addShape(shape);\n    }\n    this.setAttribute(\"position\", new Float32BufferAttribute(verticesArray, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvArray, 2));\n    this.computeVertexNormals();\n    function addShape(shape) {\n      const placeholder = [];\n      const curveSegments = options.curveSegments !== void 0 ? options.curveSegments : 12;\n      const steps = options.steps !== void 0 ? options.steps : 1;\n      let depth = options.depth !== void 0 ? options.depth : 100;\n      let bevelEnabled = options.bevelEnabled !== void 0 ? options.bevelEnabled : true;\n      let bevelThickness = options.bevelThickness !== void 0 ? options.bevelThickness : 6;\n      let bevelSize = options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 2;\n      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0;\n      let bevelSegments = options.bevelSegments !== void 0 ? options.bevelSegments : 3;\n      const extrudePath = options.extrudePath;\n      const uvgen = options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator;\n      if (options.amount !== void 0) {\n        console.warn(\"THREE.ExtrudeBufferGeometry: amount has been renamed to depth.\");\n        depth = options.amount;\n      }\n      let extrudePts, extrudeByPath = false;\n      let splineTube, binormal, normal, position2;\n      if (extrudePath) {\n        extrudePts = extrudePath.getSpacedPoints(steps);\n        extrudeByPath = true;\n        bevelEnabled = false;\n        splineTube = extrudePath.computeFrenetFrames(steps, false);\n        binormal = new Vector3();\n        normal = new Vector3();\n        position2 = new Vector3();\n      }\n      if (!bevelEnabled) {\n        bevelSegments = 0;\n        bevelThickness = 0;\n        bevelSize = 0;\n        bevelOffset = 0;\n      }\n      const shapePoints = shape.extractPoints(curveSegments);\n      let vertices = shapePoints.shape;\n      const holes = shapePoints.holes;\n      const reverse = !ShapeUtils.isClockWise(vertices);\n      if (reverse) {\n        vertices = vertices.reverse();\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          if (ShapeUtils.isClockWise(ahole)) {\n            holes[h] = ahole.reverse();\n          }\n        }\n      }\n      const faces = ShapeUtils.triangulateShape(vertices, holes);\n      const contour = vertices;\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        vertices = vertices.concat(ahole);\n      }\n      function scalePt2(pt, vec, size) {\n        if (!vec)\n          console.error(\"THREE.ExtrudeGeometry: vec does not exist\");\n        return vec.clone().multiplyScalar(size).add(pt);\n      }\n      const vlen = vertices.length, flen = faces.length;\n      function getBevelVec(inPt, inPrev, inNext) {\n        let v_trans_x, v_trans_y, shrink_by;\n        const v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\n        const v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\n        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;\n        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;\n        if (Math.abs(collinear0) > Number.EPSILON) {\n          const v_prev_len = Math.sqrt(v_prev_lensq);\n          const v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);\n          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;\n          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;\n          const ptNextShift_x = inNext.x - v_next_y / v_next_len;\n          const ptNextShift_y = inNext.y + v_next_x / v_next_len;\n          const sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);\n          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;\n          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;\n          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;\n          if (v_trans_lensq <= 2) {\n            return new Vector2(v_trans_x, v_trans_y);\n          } else {\n            shrink_by = Math.sqrt(v_trans_lensq / 2);\n          }\n        } else {\n          let direction_eq = false;\n          if (v_prev_x > Number.EPSILON) {\n            if (v_next_x > Number.EPSILON) {\n              direction_eq = true;\n            }\n          } else {\n            if (v_prev_x < -Number.EPSILON) {\n              if (v_next_x < -Number.EPSILON) {\n                direction_eq = true;\n              }\n            } else {\n              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {\n                direction_eq = true;\n              }\n            }\n          }\n          if (direction_eq) {\n            v_trans_x = -v_prev_y;\n            v_trans_y = v_prev_x;\n            shrink_by = Math.sqrt(v_prev_lensq);\n          } else {\n            v_trans_x = v_prev_x;\n            v_trans_y = v_prev_y;\n            shrink_by = Math.sqrt(v_prev_lensq / 2);\n          }\n        }\n        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);\n      }\n      const contourMovements = [];\n      for (let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n        if (j === il)\n          j = 0;\n        if (k === il)\n          k = 0;\n        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k]);\n      }\n      const holesMovements = [];\n      let oneHoleMovements, verticesMovements = contourMovements.concat();\n      for (let h = 0, hl = holes.length; h < hl; h++) {\n        const ahole = holes[h];\n        oneHoleMovements = [];\n        for (let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i++, j++, k++) {\n          if (j === il)\n            j = 0;\n          if (k === il)\n            k = 0;\n          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k]);\n        }\n        holesMovements.push(oneHoleMovements);\n        verticesMovements = verticesMovements.concat(oneHoleMovements);\n      }\n      for (let b = 0; b < bevelSegments; b++) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs2);\n          v(vert.x, vert.y, -z);\n        }\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);\n            v(vert.x, vert.y, -z);\n          }\n        }\n      }\n      const bs = bevelSize + bevelOffset;\n      for (let i = 0; i < vlen; i++) {\n        const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n        if (!extrudeByPath) {\n          v(vert.x, vert.y, 0);\n        } else {\n          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x);\n          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y);\n          position2.copy(extrudePts[0]).add(normal).add(binormal);\n          v(position2.x, position2.y, position2.z);\n        }\n      }\n      for (let s = 1; s <= steps; s++) {\n        for (let i = 0; i < vlen; i++) {\n          const vert = bevelEnabled ? scalePt2(vertices[i], verticesMovements[i], bs) : vertices[i];\n          if (!extrudeByPath) {\n            v(vert.x, vert.y, depth / steps * s);\n          } else {\n            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x);\n            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y);\n            position2.copy(extrudePts[s]).add(normal).add(binormal);\n            v(position2.x, position2.y, position2.z);\n          }\n        }\n      }\n      for (let b = bevelSegments - 1; b >= 0; b--) {\n        const t = b / bevelSegments;\n        const z = bevelThickness * Math.cos(t * Math.PI / 2);\n        const bs2 = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;\n        for (let i = 0, il = contour.length; i < il; i++) {\n          const vert = scalePt2(contour[i], contourMovements[i], bs2);\n          v(vert.x, vert.y, depth + z);\n        }\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          oneHoleMovements = holesMovements[h];\n          for (let i = 0, il = ahole.length; i < il; i++) {\n            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2);\n            if (!extrudeByPath) {\n              v(vert.x, vert.y, depth + z);\n            } else {\n              v(vert.x, vert.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + z);\n            }\n          }\n        }\n      }\n      buildLidFaces();\n      buildSideFaces();\n      function buildLidFaces() {\n        const start = verticesArray.length / 3;\n        if (bevelEnabled) {\n          let layer = 0;\n          let offset = vlen * layer;\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2] + offset, face[1] + offset, face[0] + offset);\n          }\n          layer = steps + bevelSegments * 2;\n          offset = vlen * layer;\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + offset, face[1] + offset, face[2] + offset);\n          }\n        } else {\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[2], face[1], face[0]);\n          }\n          for (let i = 0; i < flen; i++) {\n            const face = faces[i];\n            f3(face[0] + vlen * steps, face[1] + vlen * steps, face[2] + vlen * steps);\n          }\n        }\n        scope.addGroup(start, verticesArray.length / 3 - start, 0);\n      }\n      function buildSideFaces() {\n        const start = verticesArray.length / 3;\n        let layeroffset = 0;\n        sidewalls(contour, layeroffset);\n        layeroffset += contour.length;\n        for (let h = 0, hl = holes.length; h < hl; h++) {\n          const ahole = holes[h];\n          sidewalls(ahole, layeroffset);\n          layeroffset += ahole.length;\n        }\n        scope.addGroup(start, verticesArray.length / 3 - start, 1);\n      }\n      function sidewalls(contour2, layeroffset) {\n        let i = contour2.length;\n        while (--i >= 0) {\n          const j = i;\n          let k = i - 1;\n          if (k < 0)\n            k = contour2.length - 1;\n          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {\n            const slen1 = vlen * s;\n            const slen2 = vlen * (s + 1);\n            const a = layeroffset + j + slen1, b = layeroffset + k + slen1, c = layeroffset + k + slen2, d = layeroffset + j + slen2;\n            f4(a, b, c, d);\n          }\n        }\n      }\n      function v(x, y, z) {\n        placeholder.push(x);\n        placeholder.push(y);\n        placeholder.push(z);\n      }\n      function f3(a, b, c) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(c);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n      }\n      function f4(a, b, c, d) {\n        addVertex(a);\n        addVertex(b);\n        addVertex(d);\n        addVertex(b);\n        addVertex(c);\n        addVertex(d);\n        const nextIndex = verticesArray.length / 3;\n        const uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);\n        addUV(uvs[0]);\n        addUV(uvs[1]);\n        addUV(uvs[3]);\n        addUV(uvs[1]);\n        addUV(uvs[2]);\n        addUV(uvs[3]);\n      }\n      function addVertex(index) {\n        verticesArray.push(placeholder[index * 3 + 0]);\n        verticesArray.push(placeholder[index * 3 + 1]);\n        verticesArray.push(placeholder[index * 3 + 2]);\n      }\n      function addUV(vector2) {\n        uvArray.push(vector2.x);\n        uvArray.push(vector2.y);\n      }\n    }\n  }\n  toJSON() {\n    const data = BufferGeometry.prototype.toJSON.call(this);\n    const shapes = this.parameters.shapes;\n    const options = this.parameters.options;\n    return toJSON$1(shapes, options, data);\n  }\n}\nconst WorldUVGenerator = {\n  generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    return [\n      new Vector2(a_x, a_y),\n      new Vector2(b_x, b_y),\n      new Vector2(c_x, c_y)\n    ];\n  },\n  generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {\n    const a_x = vertices[indexA * 3];\n    const a_y = vertices[indexA * 3 + 1];\n    const a_z = vertices[indexA * 3 + 2];\n    const b_x = vertices[indexB * 3];\n    const b_y = vertices[indexB * 3 + 1];\n    const b_z = vertices[indexB * 3 + 2];\n    const c_x = vertices[indexC * 3];\n    const c_y = vertices[indexC * 3 + 1];\n    const c_z = vertices[indexC * 3 + 2];\n    const d_x = vertices[indexD * 3];\n    const d_y = vertices[indexD * 3 + 1];\n    const d_z = vertices[indexD * 3 + 2];\n    if (Math.abs(a_y - b_y) < 0.01) {\n      return [\n        new Vector2(a_x, 1 - a_z),\n        new Vector2(b_x, 1 - b_z),\n        new Vector2(c_x, 1 - c_z),\n        new Vector2(d_x, 1 - d_z)\n      ];\n    } else {\n      return [\n        new Vector2(a_y, 1 - a_z),\n        new Vector2(b_y, 1 - b_z),\n        new Vector2(c_y, 1 - c_z),\n        new Vector2(d_y, 1 - d_z)\n      ];\n    }\n  }\n};\nfunction toJSON$1(shapes, options, data) {\n  data.shapes = [];\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n  if (options.extrudePath !== void 0)\n    data.options.extrudePath = options.extrudePath.toJSON();\n  return data;\n}\nclass IcosahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const t = (1 + Math.sqrt(5)) / 2;\n    const vertices = [\n      -1,\n      t,\n      0,\n      1,\n      t,\n      0,\n      -1,\n      -t,\n      0,\n      1,\n      -t,\n      0,\n      0,\n      -1,\n      t,\n      0,\n      1,\n      t,\n      0,\n      -1,\n      -t,\n      0,\n      1,\n      -t,\n      t,\n      0,\n      -1,\n      t,\n      0,\n      1,\n      -t,\n      0,\n      -1,\n      -t,\n      0,\n      1\n    ];\n    const indices = [\n      0,\n      11,\n      5,\n      0,\n      5,\n      1,\n      0,\n      1,\n      7,\n      0,\n      7,\n      10,\n      0,\n      10,\n      11,\n      1,\n      5,\n      9,\n      5,\n      11,\n      4,\n      11,\n      10,\n      2,\n      10,\n      7,\n      6,\n      7,\n      1,\n      8,\n      3,\n      9,\n      4,\n      3,\n      4,\n      2,\n      3,\n      2,\n      6,\n      3,\n      6,\n      8,\n      3,\n      8,\n      9,\n      4,\n      9,\n      5,\n      2,\n      4,\n      11,\n      6,\n      2,\n      10,\n      8,\n      6,\n      7,\n      9,\n      8,\n      1\n    ];\n    super(vertices, indices, radius, detail);\n    this.type = \"IcosahedronGeometry\";\n    this.parameters = {\n      radius,\n      detail\n    };\n  }\n}\nclass LatheGeometry extends BufferGeometry {\n  constructor(points, segments = 12, phiStart = 0, phiLength = Math.PI * 2) {\n    super();\n    this.type = \"LatheGeometry\";\n    this.parameters = {\n      points,\n      segments,\n      phiStart,\n      phiLength\n    };\n    segments = Math.floor(segments);\n    phiLength = clamp(phiLength, 0, Math.PI * 2);\n    const indices = [];\n    const vertices = [];\n    const uvs = [];\n    const inverseSegments = 1 / segments;\n    const vertex = new Vector3();\n    const uv = new Vector2();\n    for (let i = 0; i <= segments; i++) {\n      const phi = phiStart + i * inverseSegments * phiLength;\n      const sin = Math.sin(phi);\n      const cos = Math.cos(phi);\n      for (let j = 0; j <= points.length - 1; j++) {\n        vertex.x = points[j].x * sin;\n        vertex.y = points[j].y;\n        vertex.z = points[j].x * cos;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        uv.x = i / segments;\n        uv.y = j / (points.length - 1);\n        uvs.push(uv.x, uv.y);\n      }\n    }\n    for (let i = 0; i < segments; i++) {\n      for (let j = 0; j < points.length - 1; j++) {\n        const base = j + i * points.length;\n        const a = base;\n        const b = base + points.length;\n        const c = base + points.length + 1;\n        const d = base + 1;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    this.computeVertexNormals();\n    if (phiLength === Math.PI * 2) {\n      const normals = this.attributes.normal.array;\n      const n1 = new Vector3();\n      const n2 = new Vector3();\n      const n = new Vector3();\n      const base = segments * points.length * 3;\n      for (let i = 0, j = 0; i < points.length; i++, j += 3) {\n        n1.x = normals[j + 0];\n        n1.y = normals[j + 1];\n        n1.z = normals[j + 2];\n        n2.x = normals[base + j + 0];\n        n2.y = normals[base + j + 1];\n        n2.z = normals[base + j + 2];\n        n.addVectors(n1, n2).normalize();\n        normals[j + 0] = normals[base + j + 0] = n.x;\n        normals[j + 1] = normals[base + j + 1] = n.y;\n        normals[j + 2] = normals[base + j + 2] = n.z;\n      }\n    }\n  }\n}\nclass OctahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const vertices = [\n      1,\n      0,\n      0,\n      -1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      -1\n    ];\n    const indices = [\n      0,\n      2,\n      4,\n      0,\n      4,\n      3,\n      0,\n      3,\n      5,\n      0,\n      5,\n      2,\n      1,\n      2,\n      5,\n      1,\n      5,\n      3,\n      1,\n      3,\n      4,\n      1,\n      4,\n      2\n    ];\n    super(vertices, indices, radius, detail);\n    this.type = \"OctahedronGeometry\";\n    this.parameters = {\n      radius,\n      detail\n    };\n  }\n}\nclass ParametricGeometry extends BufferGeometry {\n  constructor(func, slices, stacks) {\n    super();\n    this.type = \"ParametricGeometry\";\n    this.parameters = {\n      func,\n      slices,\n      stacks\n    };\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const EPS = 1e-5;\n    const normal = new Vector3();\n    const p0 = new Vector3(), p1 = new Vector3();\n    const pu = new Vector3(), pv = new Vector3();\n    if (func.length < 3) {\n      console.error(\"THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.\");\n    }\n    const sliceCount = slices + 1;\n    for (let i = 0; i <= stacks; i++) {\n      const v = i / stacks;\n      for (let j = 0; j <= slices; j++) {\n        const u = j / slices;\n        func(u, v, p0);\n        vertices.push(p0.x, p0.y, p0.z);\n        if (u - EPS >= 0) {\n          func(u - EPS, v, p1);\n          pu.subVectors(p0, p1);\n        } else {\n          func(u + EPS, v, p1);\n          pu.subVectors(p1, p0);\n        }\n        if (v - EPS >= 0) {\n          func(u, v - EPS, p1);\n          pv.subVectors(p0, p1);\n        } else {\n          func(u, v + EPS, p1);\n          pv.subVectors(p1, p0);\n        }\n        normal.crossVectors(pu, pv).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(u, v);\n      }\n    }\n    for (let i = 0; i < stacks; i++) {\n      for (let j = 0; j < slices; j++) {\n        const a = i * sliceCount + j;\n        const b = i * sliceCount + j + 1;\n        const c = (i + 1) * sliceCount + j + 1;\n        const d = (i + 1) * sliceCount + j;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n}\nclass RingGeometry extends BufferGeometry {\n  constructor(innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2) {\n    super();\n    this.type = \"RingGeometry\";\n    this.parameters = {\n      innerRadius,\n      outerRadius,\n      thetaSegments,\n      phiSegments,\n      thetaStart,\n      thetaLength\n    };\n    thetaSegments = Math.max(3, thetaSegments);\n    phiSegments = Math.max(1, phiSegments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    let radius = innerRadius;\n    const radiusStep = (outerRadius - innerRadius) / phiSegments;\n    const vertex = new Vector3();\n    const uv = new Vector2();\n    for (let j = 0; j <= phiSegments; j++) {\n      for (let i = 0; i <= thetaSegments; i++) {\n        const segment = thetaStart + i / thetaSegments * thetaLength;\n        vertex.x = radius * Math.cos(segment);\n        vertex.y = radius * Math.sin(segment);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        normals.push(0, 0, 1);\n        uv.x = (vertex.x / outerRadius + 1) / 2;\n        uv.y = (vertex.y / outerRadius + 1) / 2;\n        uvs.push(uv.x, uv.y);\n      }\n      radius += radiusStep;\n    }\n    for (let j = 0; j < phiSegments; j++) {\n      const thetaSegmentLevel = j * (thetaSegments + 1);\n      for (let i = 0; i < thetaSegments; i++) {\n        const segment = i + thetaSegmentLevel;\n        const a = segment;\n        const b = segment + thetaSegments + 1;\n        const c = segment + thetaSegments + 2;\n        const d = segment + 1;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n}\nclass ShapeGeometry extends BufferGeometry {\n  constructor(shapes, curveSegments = 12) {\n    super();\n    this.type = \"ShapeGeometry\";\n    this.parameters = {\n      shapes,\n      curveSegments\n    };\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    let groupStart = 0;\n    let groupCount = 0;\n    if (Array.isArray(shapes) === false) {\n      addShape(shapes);\n    } else {\n      for (let i = 0; i < shapes.length; i++) {\n        addShape(shapes[i]);\n        this.addGroup(groupStart, groupCount, i);\n        groupStart += groupCount;\n        groupCount = 0;\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function addShape(shape) {\n      const indexOffset = vertices.length / 3;\n      const points = shape.extractPoints(curveSegments);\n      let shapeVertices = points.shape;\n      const shapeHoles = points.holes;\n      if (ShapeUtils.isClockWise(shapeVertices) === false) {\n        shapeVertices = shapeVertices.reverse();\n      }\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        if (ShapeUtils.isClockWise(shapeHole) === true) {\n          shapeHoles[i] = shapeHole.reverse();\n        }\n      }\n      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);\n      for (let i = 0, l = shapeHoles.length; i < l; i++) {\n        const shapeHole = shapeHoles[i];\n        shapeVertices = shapeVertices.concat(shapeHole);\n      }\n      for (let i = 0, l = shapeVertices.length; i < l; i++) {\n        const vertex = shapeVertices[i];\n        vertices.push(vertex.x, vertex.y, 0);\n        normals.push(0, 0, 1);\n        uvs.push(vertex.x, vertex.y);\n      }\n      for (let i = 0, l = faces.length; i < l; i++) {\n        const face = faces[i];\n        const a = face[0] + indexOffset;\n        const b = face[1] + indexOffset;\n        const c = face[2] + indexOffset;\n        indices.push(a, b, c);\n        groupCount += 3;\n      }\n    }\n  }\n  toJSON() {\n    const data = BufferGeometry.prototype.toJSON.call(this);\n    const shapes = this.parameters.shapes;\n    return toJSON(shapes, data);\n  }\n}\nfunction toJSON(shapes, data) {\n  data.shapes = [];\n  if (Array.isArray(shapes)) {\n    for (let i = 0, l = shapes.length; i < l; i++) {\n      const shape = shapes[i];\n      data.shapes.push(shape.uuid);\n    }\n  } else {\n    data.shapes.push(shapes.uuid);\n  }\n  return data;\n}\nclass SphereGeometry extends BufferGeometry {\n  constructor(radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI) {\n    super();\n    this.type = \"SphereGeometry\";\n    this.parameters = {\n      radius,\n      widthSegments,\n      heightSegments,\n      phiStart,\n      phiLength,\n      thetaStart,\n      thetaLength\n    };\n    widthSegments = Math.max(3, Math.floor(widthSegments));\n    heightSegments = Math.max(2, Math.floor(heightSegments));\n    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);\n    let index = 0;\n    const grid = [];\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    for (let iy = 0; iy <= heightSegments; iy++) {\n      const verticesRow = [];\n      const v = iy / heightSegments;\n      let uOffset = 0;\n      if (iy == 0 && thetaStart == 0) {\n        uOffset = 0.5 / widthSegments;\n      } else if (iy == heightSegments && thetaEnd == Math.PI) {\n        uOffset = -0.5 / widthSegments;\n      }\n      for (let ix = 0; ix <= widthSegments; ix++) {\n        const u = ix / widthSegments;\n        vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertex.y = radius * Math.cos(thetaStart + v * thetaLength);\n        vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        normal.copy(vertex).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(u + uOffset, 1 - v);\n        verticesRow.push(index++);\n      }\n      grid.push(verticesRow);\n    }\n    for (let iy = 0; iy < heightSegments; iy++) {\n      for (let ix = 0; ix < widthSegments; ix++) {\n        const a = grid[iy][ix + 1];\n        const b = grid[iy][ix];\n        const c = grid[iy + 1][ix];\n        const d = grid[iy + 1][ix + 1];\n        if (iy !== 0 || thetaStart > 0)\n          indices.push(a, b, d);\n        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)\n          indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n}\nclass TetrahedronGeometry extends PolyhedronGeometry {\n  constructor(radius = 1, detail = 0) {\n    const vertices = [\n      1,\n      1,\n      1,\n      -1,\n      -1,\n      1,\n      -1,\n      1,\n      -1,\n      1,\n      -1,\n      -1\n    ];\n    const indices = [\n      2,\n      1,\n      0,\n      0,\n      3,\n      2,\n      1,\n      3,\n      0,\n      2,\n      3,\n      1\n    ];\n    super(vertices, indices, radius, detail);\n    this.type = \"TetrahedronGeometry\";\n    this.parameters = {\n      radius,\n      detail\n    };\n  }\n}\nclass TextGeometry extends ExtrudeGeometry {\n  constructor(text, parameters = {}) {\n    const font = parameters.font;\n    if (!(font && font.isFont)) {\n      console.error(\"THREE.TextGeometry: font parameter is not an instance of THREE.Font.\");\n      return new BufferGeometry();\n    }\n    const shapes = font.generateShapes(text, parameters.size);\n    parameters.depth = parameters.height !== void 0 ? parameters.height : 50;\n    if (parameters.bevelThickness === void 0)\n      parameters.bevelThickness = 10;\n    if (parameters.bevelSize === void 0)\n      parameters.bevelSize = 8;\n    if (parameters.bevelEnabled === void 0)\n      parameters.bevelEnabled = false;\n    super(shapes, parameters);\n    this.type = \"TextGeometry\";\n  }\n}\nclass TorusGeometry extends BufferGeometry {\n  constructor(radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2) {\n    super();\n    this.type = \"TorusGeometry\";\n    this.parameters = {\n      radius,\n      tube,\n      radialSegments,\n      tubularSegments,\n      arc\n    };\n    radialSegments = Math.floor(radialSegments);\n    tubularSegments = Math.floor(tubularSegments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const center = new Vector3();\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    for (let j = 0; j <= radialSegments; j++) {\n      for (let i = 0; i <= tubularSegments; i++) {\n        const u = i / tubularSegments * arc;\n        const v = j / radialSegments * Math.PI * 2;\n        vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);\n        vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);\n        vertex.z = tube * Math.sin(v);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        center.x = radius * Math.cos(u);\n        center.y = radius * Math.sin(u);\n        normal.subVectors(vertex, center).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    }\n    for (let j = 1; j <= radialSegments; j++) {\n      for (let i = 1; i <= tubularSegments; i++) {\n        const a = (tubularSegments + 1) * j + i - 1;\n        const b = (tubularSegments + 1) * (j - 1) + i - 1;\n        const c = (tubularSegments + 1) * (j - 1) + i;\n        const d = (tubularSegments + 1) * j + i;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n  }\n}\nclass TorusKnotGeometry extends BufferGeometry {\n  constructor(radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3) {\n    super();\n    this.type = \"TorusKnotGeometry\";\n    this.parameters = {\n      radius,\n      tube,\n      tubularSegments,\n      radialSegments,\n      p,\n      q\n    };\n    tubularSegments = Math.floor(tubularSegments);\n    radialSegments = Math.floor(radialSegments);\n    const indices = [];\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const P1 = new Vector3();\n    const P2 = new Vector3();\n    const B = new Vector3();\n    const T = new Vector3();\n    const N = new Vector3();\n    for (let i = 0; i <= tubularSegments; ++i) {\n      const u = i / tubularSegments * p * Math.PI * 2;\n      calculatePositionOnCurve(u, p, q, radius, P1);\n      calculatePositionOnCurve(u + 0.01, p, q, radius, P2);\n      T.subVectors(P2, P1);\n      N.addVectors(P2, P1);\n      B.crossVectors(T, N);\n      N.crossVectors(B, T);\n      B.normalize();\n      N.normalize();\n      for (let j = 0; j <= radialSegments; ++j) {\n        const v = j / radialSegments * Math.PI * 2;\n        const cx = -tube * Math.cos(v);\n        const cy = tube * Math.sin(v);\n        vertex.x = P1.x + (cx * N.x + cy * B.x);\n        vertex.y = P1.y + (cx * N.y + cy * B.y);\n        vertex.z = P1.z + (cx * N.z + cy * B.z);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        normal.subVectors(vertex, P1).normalize();\n        normals.push(normal.x, normal.y, normal.z);\n        uvs.push(i / tubularSegments);\n        uvs.push(j / radialSegments);\n      }\n    }\n    for (let j = 1; j <= tubularSegments; j++) {\n      for (let i = 1; i <= radialSegments; i++) {\n        const a = (radialSegments + 1) * (j - 1) + (i - 1);\n        const b = (radialSegments + 1) * j + (i - 1);\n        const c = (radialSegments + 1) * j + i;\n        const d = (radialSegments + 1) * (j - 1) + i;\n        indices.push(a, b, d);\n        indices.push(b, c, d);\n      }\n    }\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function calculatePositionOnCurve(u, p2, q2, radius2, position) {\n      const cu = Math.cos(u);\n      const su = Math.sin(u);\n      const quOverP = q2 / p2 * u;\n      const cs = Math.cos(quOverP);\n      position.x = radius2 * (2 + cs) * 0.5 * cu;\n      position.y = radius2 * (2 + cs) * su * 0.5;\n      position.z = radius2 * Math.sin(quOverP) * 0.5;\n    }\n  }\n}\nclass TubeGeometry extends BufferGeometry {\n  constructor(path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false) {\n    super();\n    this.type = \"TubeGeometry\";\n    this.parameters = {\n      path,\n      tubularSegments,\n      radius,\n      radialSegments,\n      closed\n    };\n    const frames = path.computeFrenetFrames(tubularSegments, closed);\n    this.tangents = frames.tangents;\n    this.normals = frames.normals;\n    this.binormals = frames.binormals;\n    const vertex = new Vector3();\n    const normal = new Vector3();\n    const uv = new Vector2();\n    let P = new Vector3();\n    const vertices = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n    generateBufferData();\n    this.setIndex(indices);\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n    this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    function generateBufferData() {\n      for (let i = 0; i < tubularSegments; i++) {\n        generateSegment(i);\n      }\n      generateSegment(closed === false ? tubularSegments : 0);\n      generateUVs();\n      generateIndices();\n    }\n    function generateSegment(i) {\n      P = path.getPointAt(i / tubularSegments, P);\n      const N = frames.normals[i];\n      const B = frames.binormals[i];\n      for (let j = 0; j <= radialSegments; j++) {\n        const v = j / radialSegments * Math.PI * 2;\n        const sin = Math.sin(v);\n        const cos = -Math.cos(v);\n        normal.x = cos * N.x + sin * B.x;\n        normal.y = cos * N.y + sin * B.y;\n        normal.z = cos * N.z + sin * B.z;\n        normal.normalize();\n        normals.push(normal.x, normal.y, normal.z);\n        vertex.x = P.x + radius * normal.x;\n        vertex.y = P.y + radius * normal.y;\n        vertex.z = P.z + radius * normal.z;\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    }\n    function generateIndices() {\n      for (let j = 1; j <= tubularSegments; j++) {\n        for (let i = 1; i <= radialSegments; i++) {\n          const a = (radialSegments + 1) * (j - 1) + (i - 1);\n          const b = (radialSegments + 1) * j + (i - 1);\n          const c = (radialSegments + 1) * j + i;\n          const d = (radialSegments + 1) * (j - 1) + i;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n    }\n    function generateUVs() {\n      for (let i = 0; i <= tubularSegments; i++) {\n        for (let j = 0; j <= radialSegments; j++) {\n          uv.x = i / tubularSegments;\n          uv.y = j / radialSegments;\n          uvs.push(uv.x, uv.y);\n        }\n      }\n    }\n  }\n  toJSON() {\n    const data = BufferGeometry.prototype.toJSON.call(this);\n    data.path = this.parameters.path.toJSON();\n    return data;\n  }\n}\nclass WireframeGeometry extends BufferGeometry {\n  constructor(geometry) {\n    super();\n    this.type = \"WireframeGeometry\";\n    if (geometry.isGeometry === true) {\n      console.error(\"THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.\");\n      return;\n    }\n    const vertices = [];\n    const edge = [0, 0], edges = {};\n    const vertex = new Vector3();\n    if (geometry.index !== null) {\n      const position = geometry.attributes.position;\n      const indices = geometry.index;\n      let groups = geometry.groups;\n      if (groups.length === 0) {\n        groups = [{start: 0, count: indices.count, materialIndex: 0}];\n      }\n      for (let o = 0, ol = groups.length; o < ol; ++o) {\n        const group = groups[o];\n        const start = group.start;\n        const count = group.count;\n        for (let i = start, l = start + count; i < l; i += 3) {\n          for (let j = 0; j < 3; j++) {\n            const edge1 = indices.getX(i + j);\n            const edge2 = indices.getX(i + (j + 1) % 3);\n            edge[0] = Math.min(edge1, edge2);\n            edge[1] = Math.max(edge1, edge2);\n            const key = edge[0] + \",\" + edge[1];\n            if (edges[key] === void 0) {\n              edges[key] = {index1: edge[0], index2: edge[1]};\n            }\n          }\n        }\n      }\n      for (const key in edges) {\n        const e = edges[key];\n        vertex.fromBufferAttribute(position, e.index1);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n        vertex.fromBufferAttribute(position, e.index2);\n        vertices.push(vertex.x, vertex.y, vertex.z);\n      }\n    } else {\n      const position = geometry.attributes.position;\n      for (let i = 0, l = position.count / 3; i < l; i++) {\n        for (let j = 0; j < 3; j++) {\n          const index1 = 3 * i + j;\n          vertex.fromBufferAttribute(position, index1);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n          const index2 = 3 * i + (j + 1) % 3;\n          vertex.fromBufferAttribute(position, index2);\n          vertices.push(vertex.x, vertex.y, vertex.z);\n        }\n      }\n    }\n    this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n  }\n}\nvar Geometries = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  BoxGeometry,\n  BoxBufferGeometry: BoxGeometry,\n  CircleGeometry,\n  CircleBufferGeometry: CircleGeometry,\n  ConeGeometry,\n  ConeBufferGeometry: ConeGeometry,\n  CylinderGeometry,\n  CylinderBufferGeometry: CylinderGeometry,\n  DodecahedronGeometry,\n  DodecahedronBufferGeometry: DodecahedronGeometry,\n  EdgesGeometry,\n  ExtrudeGeometry,\n  ExtrudeBufferGeometry: ExtrudeGeometry,\n  IcosahedronGeometry,\n  IcosahedronBufferGeometry: IcosahedronGeometry,\n  LatheGeometry,\n  LatheBufferGeometry: LatheGeometry,\n  OctahedronGeometry,\n  OctahedronBufferGeometry: OctahedronGeometry,\n  ParametricGeometry,\n  ParametricBufferGeometry: ParametricGeometry,\n  PlaneGeometry,\n  PlaneBufferGeometry: PlaneGeometry,\n  PolyhedronGeometry,\n  PolyhedronBufferGeometry: PolyhedronGeometry,\n  RingGeometry,\n  RingBufferGeometry: RingGeometry,\n  ShapeGeometry,\n  ShapeBufferGeometry: ShapeGeometry,\n  SphereGeometry,\n  SphereBufferGeometry: SphereGeometry,\n  TetrahedronGeometry,\n  TetrahedronBufferGeometry: TetrahedronGeometry,\n  TextGeometry,\n  TextBufferGeometry: TextGeometry,\n  TorusGeometry,\n  TorusBufferGeometry: TorusGeometry,\n  TorusKnotGeometry,\n  TorusKnotBufferGeometry: TorusKnotGeometry,\n  TubeGeometry,\n  TubeBufferGeometry: TubeGeometry,\n  WireframeGeometry\n});\nclass ShadowMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"ShadowMaterial\";\n    this.color = new Color(0);\n    this.transparent = true;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    return this;\n  }\n}\nShadowMaterial.prototype.isShadowMaterial = true;\nclass RawShaderMaterial extends ShaderMaterial {\n  constructor(parameters) {\n    super(parameters);\n    this.type = \"RawShaderMaterial\";\n  }\n}\nRawShaderMaterial.prototype.isRawShaderMaterial = true;\nclass MeshStandardMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.defines = {\"STANDARD\": \"\"};\n    this.type = \"MeshStandardMaterial\";\n    this.color = new Color(16777215);\n    this.roughness = 1;\n    this.metalness = 0;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.roughnessMap = null;\n    this.metalnessMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.envMapIntensity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.flatShading = false;\n    this.vertexTangents = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = {\"STANDARD\": \"\"};\n    this.color.copy(source.color);\n    this.roughness = source.roughness;\n    this.metalness = source.metalness;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.roughnessMap = source.roughnessMap;\n    this.metalnessMap = source.metalnessMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.envMapIntensity = source.envMapIntensity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    this.flatShading = source.flatShading;\n    this.vertexTangents = source.vertexTangents;\n    return this;\n  }\n}\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\nclass MeshPhysicalMaterial extends MeshStandardMaterial {\n  constructor(parameters) {\n    super();\n    this.defines = {\n      \"STANDARD\": \"\",\n      \"PHYSICAL\": \"\"\n    };\n    this.type = \"MeshPhysicalMaterial\";\n    this.clearcoat = 0;\n    this.clearcoatMap = null;\n    this.clearcoatRoughness = 0;\n    this.clearcoatRoughnessMap = null;\n    this.clearcoatNormalScale = new Vector2(1, 1);\n    this.clearcoatNormalMap = null;\n    this.reflectivity = 0.5;\n    Object.defineProperty(this, \"ior\", {\n      get: function() {\n        return (1 + 0.4 * this.reflectivity) / (1 - 0.4 * this.reflectivity);\n      },\n      set: function(ior) {\n        this.reflectivity = clamp(2.5 * (ior - 1) / (ior + 1), 0, 1);\n      }\n    });\n    this.sheen = null;\n    this.transmission = 0;\n    this.transmissionMap = null;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = {\n      \"STANDARD\": \"\",\n      \"PHYSICAL\": \"\"\n    };\n    this.clearcoat = source.clearcoat;\n    this.clearcoatMap = source.clearcoatMap;\n    this.clearcoatRoughness = source.clearcoatRoughness;\n    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;\n    this.clearcoatNormalMap = source.clearcoatNormalMap;\n    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);\n    this.reflectivity = source.reflectivity;\n    if (source.sheen) {\n      this.sheen = (this.sheen || new Color()).copy(source.sheen);\n    } else {\n      this.sheen = null;\n    }\n    this.transmission = source.transmission;\n    this.transmissionMap = source.transmissionMap;\n    return this;\n  }\n}\nMeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;\nclass MeshPhongMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"MeshPhongMaterial\";\n    this.color = new Color(16777215);\n    this.specular = new Color(1118481);\n    this.shininess = 30;\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.specular.copy(source.specular);\n    this.shininess = source.shininess;\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n}\nMeshPhongMaterial.prototype.isMeshPhongMaterial = true;\nclass MeshToonMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.defines = {\"TOON\": \"\"};\n    this.type = \"MeshToonMaterial\";\n    this.color = new Color(16777215);\n    this.map = null;\n    this.gradientMap = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.alphaMap = null;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.gradientMap = source.gradientMap;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    return this;\n  }\n}\nMeshToonMaterial.prototype.isMeshToonMaterial = true;\nclass MeshNormalMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"MeshNormalMaterial\";\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.fog = false;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n}\nMeshNormalMaterial.prototype.isMeshNormalMaterial = true;\nclass MeshLambertMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.type = \"MeshLambertMaterial\";\n    this.color = new Color(16777215);\n    this.map = null;\n    this.lightMap = null;\n    this.lightMapIntensity = 1;\n    this.aoMap = null;\n    this.aoMapIntensity = 1;\n    this.emissive = new Color(0);\n    this.emissiveIntensity = 1;\n    this.emissiveMap = null;\n    this.specularMap = null;\n    this.alphaMap = null;\n    this.envMap = null;\n    this.combine = MultiplyOperation;\n    this.reflectivity = 1;\n    this.refractionRatio = 0.98;\n    this.wireframe = false;\n    this.wireframeLinewidth = 1;\n    this.wireframeLinecap = \"round\";\n    this.wireframeLinejoin = \"round\";\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.map = source.map;\n    this.lightMap = source.lightMap;\n    this.lightMapIntensity = source.lightMapIntensity;\n    this.aoMap = source.aoMap;\n    this.aoMapIntensity = source.aoMapIntensity;\n    this.emissive.copy(source.emissive);\n    this.emissiveMap = source.emissiveMap;\n    this.emissiveIntensity = source.emissiveIntensity;\n    this.specularMap = source.specularMap;\n    this.alphaMap = source.alphaMap;\n    this.envMap = source.envMap;\n    this.combine = source.combine;\n    this.reflectivity = source.reflectivity;\n    this.refractionRatio = source.refractionRatio;\n    this.wireframe = source.wireframe;\n    this.wireframeLinewidth = source.wireframeLinewidth;\n    this.wireframeLinecap = source.wireframeLinecap;\n    this.wireframeLinejoin = source.wireframeLinejoin;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    return this;\n  }\n}\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\nclass MeshMatcapMaterial extends Material {\n  constructor(parameters) {\n    super();\n    this.defines = {\"MATCAP\": \"\"};\n    this.type = \"MeshMatcapMaterial\";\n    this.color = new Color(16777215);\n    this.matcap = null;\n    this.map = null;\n    this.bumpMap = null;\n    this.bumpScale = 1;\n    this.normalMap = null;\n    this.normalMapType = TangentSpaceNormalMap;\n    this.normalScale = new Vector2(1, 1);\n    this.displacementMap = null;\n    this.displacementScale = 1;\n    this.displacementBias = 0;\n    this.alphaMap = null;\n    this.skinning = false;\n    this.morphTargets = false;\n    this.morphNormals = false;\n    this.flatShading = false;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.defines = {\"MATCAP\": \"\"};\n    this.color.copy(source.color);\n    this.matcap = source.matcap;\n    this.map = source.map;\n    this.bumpMap = source.bumpMap;\n    this.bumpScale = source.bumpScale;\n    this.normalMap = source.normalMap;\n    this.normalMapType = source.normalMapType;\n    this.normalScale.copy(source.normalScale);\n    this.displacementMap = source.displacementMap;\n    this.displacementScale = source.displacementScale;\n    this.displacementBias = source.displacementBias;\n    this.alphaMap = source.alphaMap;\n    this.skinning = source.skinning;\n    this.morphTargets = source.morphTargets;\n    this.morphNormals = source.morphNormals;\n    this.flatShading = source.flatShading;\n    return this;\n  }\n}\nMeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;\nclass LineDashedMaterial extends LineBasicMaterial {\n  constructor(parameters) {\n    super();\n    this.type = \"LineDashedMaterial\";\n    this.scale = 1;\n    this.dashSize = 3;\n    this.gapSize = 1;\n    this.setValues(parameters);\n  }\n  copy(source) {\n    super.copy(source);\n    this.scale = source.scale;\n    this.dashSize = source.dashSize;\n    this.gapSize = source.gapSize;\n    return this;\n  }\n}\nLineDashedMaterial.prototype.isLineDashedMaterial = true;\nvar Materials = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  ShadowMaterial,\n  SpriteMaterial,\n  RawShaderMaterial,\n  ShaderMaterial,\n  PointsMaterial,\n  MeshPhysicalMaterial,\n  MeshStandardMaterial,\n  MeshPhongMaterial,\n  MeshToonMaterial,\n  MeshNormalMaterial,\n  MeshLambertMaterial,\n  MeshDepthMaterial,\n  MeshDistanceMaterial,\n  MeshBasicMaterial,\n  MeshMatcapMaterial,\n  LineDashedMaterial,\n  LineBasicMaterial,\n  Material\n});\nconst AnimationUtils = {\n  arraySlice: function(array, from, to) {\n    if (AnimationUtils.isTypedArray(array)) {\n      return new array.constructor(array.subarray(from, to !== void 0 ? to : array.length));\n    }\n    return array.slice(from, to);\n  },\n  convertArray: function(array, type, forceClone) {\n    if (!array || !forceClone && array.constructor === type)\n      return array;\n    if (typeof type.BYTES_PER_ELEMENT === \"number\") {\n      return new type(array);\n    }\n    return Array.prototype.slice.call(array);\n  },\n  isTypedArray: function(object) {\n    return ArrayBuffer.isView(object) && !(object instanceof DataView);\n  },\n  getKeyframeOrder: function(times) {\n    function compareTime(i, j) {\n      return times[i] - times[j];\n    }\n    const n = times.length;\n    const result = new Array(n);\n    for (let i = 0; i !== n; ++i)\n      result[i] = i;\n    result.sort(compareTime);\n    return result;\n  },\n  sortedArray: function(values, stride, order) {\n    const nValues = values.length;\n    const result = new values.constructor(nValues);\n    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {\n      const srcOffset = order[i] * stride;\n      for (let j = 0; j !== stride; ++j) {\n        result[dstOffset++] = values[srcOffset + j];\n      }\n    }\n    return result;\n  },\n  flattenJSON: function(jsonKeys, times, values, valuePropertyName) {\n    let i = 1, key = jsonKeys[0];\n    while (key !== void 0 && key[valuePropertyName] === void 0) {\n      key = jsonKeys[i++];\n    }\n    if (key === void 0)\n      return;\n    let value = key[valuePropertyName];\n    if (value === void 0)\n      return;\n    if (Array.isArray(value)) {\n      do {\n        value = key[valuePropertyName];\n        if (value !== void 0) {\n          times.push(key.time);\n          values.push.apply(values, value);\n        }\n        key = jsonKeys[i++];\n      } while (key !== void 0);\n    } else if (value.toArray !== void 0) {\n      do {\n        value = key[valuePropertyName];\n        if (value !== void 0) {\n          times.push(key.time);\n          value.toArray(values, values.length);\n        }\n        key = jsonKeys[i++];\n      } while (key !== void 0);\n    } else {\n      do {\n        value = key[valuePropertyName];\n        if (value !== void 0) {\n          times.push(key.time);\n          values.push(value);\n        }\n        key = jsonKeys[i++];\n      } while (key !== void 0);\n    }\n  },\n  subclip: function(sourceClip, name, startFrame, endFrame, fps = 30) {\n    const clip = sourceClip.clone();\n    clip.name = name;\n    const tracks = [];\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      const track = clip.tracks[i];\n      const valueSize = track.getValueSize();\n      const times = [];\n      const values = [];\n      for (let j = 0; j < track.times.length; ++j) {\n        const frame = track.times[j] * fps;\n        if (frame < startFrame || frame >= endFrame)\n          continue;\n        times.push(track.times[j]);\n        for (let k = 0; k < valueSize; ++k) {\n          values.push(track.values[j * valueSize + k]);\n        }\n      }\n      if (times.length === 0)\n        continue;\n      track.times = AnimationUtils.convertArray(times, track.times.constructor);\n      track.values = AnimationUtils.convertArray(values, track.values.constructor);\n      tracks.push(track);\n    }\n    clip.tracks = tracks;\n    let minStartTime = Infinity;\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      if (minStartTime > clip.tracks[i].times[0]) {\n        minStartTime = clip.tracks[i].times[0];\n      }\n    }\n    for (let i = 0; i < clip.tracks.length; ++i) {\n      clip.tracks[i].shift(-1 * minStartTime);\n    }\n    clip.resetDuration();\n    return clip;\n  },\n  makeClipAdditive: function(targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30) {\n    if (fps <= 0)\n      fps = 30;\n    const numTracks = referenceClip.tracks.length;\n    const referenceTime = referenceFrame / fps;\n    for (let i = 0; i < numTracks; ++i) {\n      const referenceTrack = referenceClip.tracks[i];\n      const referenceTrackType = referenceTrack.ValueTypeName;\n      if (referenceTrackType === \"bool\" || referenceTrackType === \"string\")\n        continue;\n      const targetTrack = targetClip.tracks.find(function(track) {\n        return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;\n      });\n      if (targetTrack === void 0)\n        continue;\n      let referenceOffset = 0;\n      const referenceValueSize = referenceTrack.getValueSize();\n      if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        referenceOffset = referenceValueSize / 3;\n      }\n      let targetOffset = 0;\n      const targetValueSize = targetTrack.getValueSize();\n      if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {\n        targetOffset = targetValueSize / 3;\n      }\n      const lastIndex = referenceTrack.times.length - 1;\n      let referenceValue;\n      if (referenceTime <= referenceTrack.times[0]) {\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else if (referenceTime >= referenceTrack.times[lastIndex]) {\n        const startIndex = lastIndex * referenceValueSize + referenceOffset;\n        const endIndex = startIndex + referenceValueSize - referenceOffset;\n        referenceValue = AnimationUtils.arraySlice(referenceTrack.values, startIndex, endIndex);\n      } else {\n        const interpolant = referenceTrack.createInterpolant();\n        const startIndex = referenceOffset;\n        const endIndex = referenceValueSize - referenceOffset;\n        interpolant.evaluate(referenceTime);\n        referenceValue = AnimationUtils.arraySlice(interpolant.resultBuffer, startIndex, endIndex);\n      }\n      if (referenceTrackType === \"quaternion\") {\n        const referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();\n        referenceQuat.toArray(referenceValue);\n      }\n      const numTimes = targetTrack.times.length;\n      for (let j = 0; j < numTimes; ++j) {\n        const valueStart = j * targetValueSize + targetOffset;\n        if (referenceTrackType === \"quaternion\") {\n          Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);\n        } else {\n          const valueEnd = targetValueSize - targetOffset * 2;\n          for (let k = 0; k < valueEnd; ++k) {\n            targetTrack.values[valueStart + k] -= referenceValue[k];\n          }\n        }\n      }\n    }\n    targetClip.blendMode = AdditiveAnimationBlendMode;\n    return targetClip;\n  }\n};\nclass Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    this.parameterPositions = parameterPositions;\n    this._cachedIndex = 0;\n    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);\n    this.sampleValues = sampleValues;\n    this.valueSize = sampleSize;\n    this.settings = null;\n    this.DefaultSettings_ = {};\n  }\n  evaluate(t) {\n    const pp = this.parameterPositions;\n    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];\n    validate_interval: {\n      seek: {\n        let right;\n        linear_scan: {\n          forward_scan:\n            if (!(t < t1)) {\n              for (let giveUpAt = i1 + 2; ; ) {\n                if (t1 === void 0) {\n                  if (t < t0)\n                    break forward_scan;\n                  i1 = pp.length;\n                  this._cachedIndex = i1;\n                  return this.afterEnd_(i1 - 1, t, t0);\n                }\n                if (i1 === giveUpAt)\n                  break;\n                t0 = t1;\n                t1 = pp[++i1];\n                if (t < t1) {\n                  break seek;\n                }\n              }\n              right = pp.length;\n              break linear_scan;\n            }\n          if (!(t >= t0)) {\n            const t1global = pp[1];\n            if (t < t1global) {\n              i1 = 2;\n              t0 = t1global;\n            }\n            for (let giveUpAt = i1 - 2; ; ) {\n              if (t0 === void 0) {\n                this._cachedIndex = 0;\n                return this.beforeStart_(0, t, t1);\n              }\n              if (i1 === giveUpAt)\n                break;\n              t1 = t0;\n              t0 = pp[--i1 - 1];\n              if (t >= t0) {\n                break seek;\n              }\n            }\n            right = i1;\n            i1 = 0;\n            break linear_scan;\n          }\n          break validate_interval;\n        }\n        while (i1 < right) {\n          const mid = i1 + right >>> 1;\n          if (t < pp[mid]) {\n            right = mid;\n          } else {\n            i1 = mid + 1;\n          }\n        }\n        t1 = pp[i1];\n        t0 = pp[i1 - 1];\n        if (t0 === void 0) {\n          this._cachedIndex = 0;\n          return this.beforeStart_(0, t, t1);\n        }\n        if (t1 === void 0) {\n          i1 = pp.length;\n          this._cachedIndex = i1;\n          return this.afterEnd_(i1 - 1, t0, t);\n        }\n      }\n      this._cachedIndex = i1;\n      this.intervalChanged_(i1, t0, t1);\n    }\n    return this.interpolate_(i1, t0, t, t1);\n  }\n  getSettings_() {\n    return this.settings || this.DefaultSettings_;\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n  interpolate_() {\n    throw new Error(\"call to abstract method\");\n  }\n  intervalChanged_() {\n  }\n}\nInterpolant.prototype.beforeStart_ = Interpolant.prototype.copySampleValue_;\nInterpolant.prototype.afterEnd_ = Interpolant.prototype.copySampleValue_;\nclass CubicInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n    this._weightPrev = -0;\n    this._offsetPrev = -0;\n    this._weightNext = -0;\n    this._offsetNext = -0;\n    this.DefaultSettings_ = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n  }\n  intervalChanged_(i1, t0, t1) {\n    const pp = this.parameterPositions;\n    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];\n    if (tPrev === void 0) {\n      switch (this.getSettings_().endingStart) {\n        case ZeroSlopeEnding:\n          iPrev = i1;\n          tPrev = 2 * t0 - t1;\n          break;\n        case WrapAroundEnding:\n          iPrev = pp.length - 2;\n          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];\n          break;\n        default:\n          iPrev = i1;\n          tPrev = t1;\n      }\n    }\n    if (tNext === void 0) {\n      switch (this.getSettings_().endingEnd) {\n        case ZeroSlopeEnding:\n          iNext = i1;\n          tNext = 2 * t1 - t0;\n          break;\n        case WrapAroundEnding:\n          iNext = 1;\n          tNext = t1 + pp[1] - pp[0];\n          break;\n        default:\n          iNext = i1 - 1;\n          tNext = t0;\n      }\n    }\n    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;\n    this._weightPrev = halfDt / (t0 - tPrev);\n    this._weightNext = halfDt / (tNext - t1);\n    this._offsetPrev = iPrev * stride;\n    this._offsetNext = iNext * stride;\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p = (t - t0) / (t1 - t0), pp = p * p, ppp = pp * p;\n    const sP = -wP * ppp + 2 * wP * pp - wP * p;\n    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;\n    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;\n    const sN = wN * ppp - wN * pp;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];\n    }\n    return result;\n  }\n}\nclass LinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t - t0) / (t1 - t0), weight0 = 1 - weight1;\n    for (let i = 0; i !== stride; ++i) {\n      result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;\n    }\n    return result;\n  }\n}\nclass DiscreteInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1) {\n    return this.copySampleValue_(i1 - 1);\n  }\n}\nclass KeyframeTrack {\n  constructor(name, times, values, interpolation) {\n    if (name === void 0)\n      throw new Error(\"THREE.KeyframeTrack: track name is undefined\");\n    if (times === void 0 || times.length === 0)\n      throw new Error(\"THREE.KeyframeTrack: no keyframes in track named \" + name);\n    this.name = name;\n    this.times = AnimationUtils.convertArray(times, this.TimeBufferType);\n    this.values = AnimationUtils.convertArray(values, this.ValueBufferType);\n    this.setInterpolation(interpolation || this.DefaultInterpolation);\n  }\n  static toJSON(track) {\n    const trackType = track.constructor;\n    let json;\n    if (trackType.toJSON !== this.toJSON) {\n      json = trackType.toJSON(track);\n    } else {\n      json = {\n        \"name\": track.name,\n        \"times\": AnimationUtils.convertArray(track.times, Array),\n        \"values\": AnimationUtils.convertArray(track.values, Array)\n      };\n      const interpolation = track.getInterpolation();\n      if (interpolation !== track.DefaultInterpolation) {\n        json.interpolation = interpolation;\n      }\n    }\n    json.type = track.ValueTypeName;\n    return json;\n  }\n  InterpolantFactoryMethodDiscrete(result) {\n    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodLinear(result) {\n    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  InterpolantFactoryMethodSmooth(result) {\n    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n  setInterpolation(interpolation) {\n    let factoryMethod;\n    switch (interpolation) {\n      case InterpolateDiscrete:\n        factoryMethod = this.InterpolantFactoryMethodDiscrete;\n        break;\n      case InterpolateLinear:\n        factoryMethod = this.InterpolantFactoryMethodLinear;\n        break;\n      case InterpolateSmooth:\n        factoryMethod = this.InterpolantFactoryMethodSmooth;\n        break;\n    }\n    if (factoryMethod === void 0) {\n      const message = \"unsupported interpolation for \" + this.ValueTypeName + \" keyframe track named \" + this.name;\n      if (this.createInterpolant === void 0) {\n        if (interpolation !== this.DefaultInterpolation) {\n          this.setInterpolation(this.DefaultInterpolation);\n        } else {\n          throw new Error(message);\n        }\n      }\n      console.warn(\"THREE.KeyframeTrack:\", message);\n      return this;\n    }\n    this.createInterpolant = factoryMethod;\n    return this;\n  }\n  getInterpolation() {\n    switch (this.createInterpolant) {\n      case this.InterpolantFactoryMethodDiscrete:\n        return InterpolateDiscrete;\n      case this.InterpolantFactoryMethodLinear:\n        return InterpolateLinear;\n      case this.InterpolantFactoryMethodSmooth:\n        return InterpolateSmooth;\n    }\n  }\n  getValueSize() {\n    return this.values.length / this.times.length;\n  }\n  shift(timeOffset) {\n    if (timeOffset !== 0) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] += timeOffset;\n      }\n    }\n    return this;\n  }\n  scale(timeScale) {\n    if (timeScale !== 1) {\n      const times = this.times;\n      for (let i = 0, n = times.length; i !== n; ++i) {\n        times[i] *= timeScale;\n      }\n    }\n    return this;\n  }\n  trim(startTime, endTime) {\n    const times = this.times, nKeys = times.length;\n    let from = 0, to = nKeys - 1;\n    while (from !== nKeys && times[from] < startTime) {\n      ++from;\n    }\n    while (to !== -1 && times[to] > endTime) {\n      --to;\n    }\n    ++to;\n    if (from !== 0 || to !== nKeys) {\n      if (from >= to) {\n        to = Math.max(to, 1);\n        from = to - 1;\n      }\n      const stride = this.getValueSize();\n      this.times = AnimationUtils.arraySlice(times, from, to);\n      this.values = AnimationUtils.arraySlice(this.values, from * stride, to * stride);\n    }\n    return this;\n  }\n  validate() {\n    let valid = true;\n    const valueSize = this.getValueSize();\n    if (valueSize - Math.floor(valueSize) !== 0) {\n      console.error(\"THREE.KeyframeTrack: Invalid value size in track.\", this);\n      valid = false;\n    }\n    const times = this.times, values = this.values, nKeys = times.length;\n    if (nKeys === 0) {\n      console.error(\"THREE.KeyframeTrack: Track is empty.\", this);\n      valid = false;\n    }\n    let prevTime = null;\n    for (let i = 0; i !== nKeys; i++) {\n      const currTime = times[i];\n      if (typeof currTime === \"number\" && isNaN(currTime)) {\n        console.error(\"THREE.KeyframeTrack: Time is not a valid number.\", this, i, currTime);\n        valid = false;\n        break;\n      }\n      if (prevTime !== null && prevTime > currTime) {\n        console.error(\"THREE.KeyframeTrack: Out of order keys.\", this, i, currTime, prevTime);\n        valid = false;\n        break;\n      }\n      prevTime = currTime;\n    }\n    if (values !== void 0) {\n      if (AnimationUtils.isTypedArray(values)) {\n        for (let i = 0, n = values.length; i !== n; ++i) {\n          const value = values[i];\n          if (isNaN(value)) {\n            console.error(\"THREE.KeyframeTrack: Value is not a valid number.\", this, i, value);\n            valid = false;\n            break;\n          }\n        }\n      }\n    }\n    return valid;\n  }\n  optimize() {\n    const times = AnimationUtils.arraySlice(this.times), values = AnimationUtils.arraySlice(this.values), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;\n    let writeIndex = 1;\n    for (let i = 1; i < lastIndex; ++i) {\n      let keep = false;\n      const time = times[i];\n      const timeNext = times[i + 1];\n      if (time !== timeNext && (i !== 1 || time !== times[0])) {\n        if (!smoothInterpolation) {\n          const offset = i * stride, offsetP = offset - stride, offsetN = offset + stride;\n          for (let j = 0; j !== stride; ++j) {\n            const value = values[offset + j];\n            if (value !== values[offsetP + j] || value !== values[offsetN + j]) {\n              keep = true;\n              break;\n            }\n          }\n        } else {\n          keep = true;\n        }\n      }\n      if (keep) {\n        if (i !== writeIndex) {\n          times[writeIndex] = times[i];\n          const readOffset = i * stride, writeOffset = writeIndex * stride;\n          for (let j = 0; j !== stride; ++j) {\n            values[writeOffset + j] = values[readOffset + j];\n          }\n        }\n        ++writeIndex;\n      }\n    }\n    if (lastIndex > 0) {\n      times[writeIndex] = times[lastIndex];\n      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++j) {\n        values[writeOffset + j] = values[readOffset + j];\n      }\n      ++writeIndex;\n    }\n    if (writeIndex !== times.length) {\n      this.times = AnimationUtils.arraySlice(times, 0, writeIndex);\n      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride);\n    } else {\n      this.times = times;\n      this.values = values;\n    }\n    return this;\n  }\n  clone() {\n    const times = AnimationUtils.arraySlice(this.times, 0);\n    const values = AnimationUtils.arraySlice(this.values, 0);\n    const TypedKeyframeTrack = this.constructor;\n    const track = new TypedKeyframeTrack(this.name, times, values);\n    track.createInterpolant = this.createInterpolant;\n    return track;\n  }\n}\nKeyframeTrack.prototype.TimeBufferType = Float32Array;\nKeyframeTrack.prototype.ValueBufferType = Float32Array;\nKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nclass BooleanKeyframeTrack extends KeyframeTrack {\n}\nBooleanKeyframeTrack.prototype.ValueTypeName = \"bool\";\nBooleanKeyframeTrack.prototype.ValueBufferType = Array;\nBooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;\nBooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;\nclass ColorKeyframeTrack extends KeyframeTrack {\n}\nColorKeyframeTrack.prototype.ValueTypeName = \"color\";\nclass NumberKeyframeTrack extends KeyframeTrack {\n}\nNumberKeyframeTrack.prototype.ValueTypeName = \"number\";\nclass QuaternionLinearInterpolant extends Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  interpolate_(i1, t0, t, t1) {\n    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t - t0) / (t1 - t0);\n    let offset = i1 * stride;\n    for (let end = offset + stride; offset !== end; offset += 4) {\n      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);\n    }\n    return result;\n  }\n}\nclass QuaternionKeyframeTrack extends KeyframeTrack {\n  InterpolantFactoryMethodLinear(result) {\n    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);\n  }\n}\nQuaternionKeyframeTrack.prototype.ValueTypeName = \"quaternion\";\nQuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;\nQuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;\nclass StringKeyframeTrack extends KeyframeTrack {\n}\nStringKeyframeTrack.prototype.ValueTypeName = \"string\";\nStringKeyframeTrack.prototype.ValueBufferType = Array;\nStringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;\nStringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;\nclass VectorKeyframeTrack extends KeyframeTrack {\n}\nVectorKeyframeTrack.prototype.ValueTypeName = \"vector\";\nclass AnimationClip {\n  constructor(name, duration = -1, tracks, blendMode = NormalAnimationBlendMode) {\n    this.name = name;\n    this.tracks = tracks;\n    this.duration = duration;\n    this.blendMode = blendMode;\n    this.uuid = generateUUID();\n    if (this.duration < 0) {\n      this.resetDuration();\n    }\n  }\n  static parse(json) {\n    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);\n    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {\n      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));\n    }\n    const clip = new this(json.name, json.duration, tracks, json.blendMode);\n    clip.uuid = json.uuid;\n    return clip;\n  }\n  static toJSON(clip) {\n    const tracks = [], clipTracks = clip.tracks;\n    const json = {\n      \"name\": clip.name,\n      \"duration\": clip.duration,\n      \"tracks\": tracks,\n      \"uuid\": clip.uuid,\n      \"blendMode\": clip.blendMode\n    };\n    for (let i = 0, n = clipTracks.length; i !== n; ++i) {\n      tracks.push(KeyframeTrack.toJSON(clipTracks[i]));\n    }\n    return json;\n  }\n  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {\n    const numMorphTargets = morphTargetSequence.length;\n    const tracks = [];\n    for (let i = 0; i < numMorphTargets; i++) {\n      let times = [];\n      let values = [];\n      times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);\n      values.push(0, 1, 0);\n      const order = AnimationUtils.getKeyframeOrder(times);\n      times = AnimationUtils.sortedArray(times, 1, order);\n      values = AnimationUtils.sortedArray(values, 1, order);\n      if (!noLoop && times[0] === 0) {\n        times.push(numMorphTargets);\n        values.push(values[0]);\n      }\n      tracks.push(new NumberKeyframeTrack(\".morphTargetInfluences[\" + morphTargetSequence[i].name + \"]\", times, values).scale(1 / fps));\n    }\n    return new this(name, -1, tracks);\n  }\n  static findByName(objectOrClipArray, name) {\n    let clipArray = objectOrClipArray;\n    if (!Array.isArray(objectOrClipArray)) {\n      const o = objectOrClipArray;\n      clipArray = o.geometry && o.geometry.animations || o.animations;\n    }\n    for (let i = 0; i < clipArray.length; i++) {\n      if (clipArray[i].name === name) {\n        return clipArray[i];\n      }\n    }\n    return null;\n  }\n  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {\n    const animationToMorphTargets = {};\n    const pattern = /^([\\w-]*?)([\\d]+)$/;\n    for (let i = 0, il = morphTargets.length; i < il; i++) {\n      const morphTarget = morphTargets[i];\n      const parts = morphTarget.name.match(pattern);\n      if (parts && parts.length > 1) {\n        const name = parts[1];\n        let animationMorphTargets = animationToMorphTargets[name];\n        if (!animationMorphTargets) {\n          animationToMorphTargets[name] = animationMorphTargets = [];\n        }\n        animationMorphTargets.push(morphTarget);\n      }\n    }\n    const clips = [];\n    for (const name in animationToMorphTargets) {\n      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));\n    }\n    return clips;\n  }\n  static parseAnimation(animation, bones) {\n    if (!animation) {\n      console.error(\"THREE.AnimationClip: No animation in JSONLoader data.\");\n      return null;\n    }\n    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {\n      if (animationKeys.length !== 0) {\n        const times = [];\n        const values = [];\n        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName);\n        if (times.length !== 0) {\n          destTracks.push(new trackType(trackName, times, values));\n        }\n      }\n    };\n    const tracks = [];\n    const clipName = animation.name || \"default\";\n    const fps = animation.fps || 30;\n    const blendMode = animation.blendMode;\n    let duration = animation.length || -1;\n    const hierarchyTracks = animation.hierarchy || [];\n    for (let h = 0; h < hierarchyTracks.length; h++) {\n      const animationKeys = hierarchyTracks[h].keys;\n      if (!animationKeys || animationKeys.length === 0)\n        continue;\n      if (animationKeys[0].morphTargets) {\n        const morphTargetNames = {};\n        let k;\n        for (k = 0; k < animationKeys.length; k++) {\n          if (animationKeys[k].morphTargets) {\n            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {\n              morphTargetNames[animationKeys[k].morphTargets[m]] = -1;\n            }\n          }\n        }\n        for (const morphTargetName in morphTargetNames) {\n          const times = [];\n          const values = [];\n          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {\n            const animationKey = animationKeys[k];\n            times.push(animationKey.time);\n            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);\n          }\n          tracks.push(new NumberKeyframeTrack(\".morphTargetInfluence[\" + morphTargetName + \"]\", times, values));\n        }\n        duration = morphTargetNames.length * (fps || 1);\n      } else {\n        const boneName = \".bones[\" + bones[h].name + \"]\";\n        addNonemptyTrack(VectorKeyframeTrack, boneName + \".position\", animationKeys, \"pos\", tracks);\n        addNonemptyTrack(QuaternionKeyframeTrack, boneName + \".quaternion\", animationKeys, \"rot\", tracks);\n        addNonemptyTrack(VectorKeyframeTrack, boneName + \".scale\", animationKeys, \"scl\", tracks);\n      }\n    }\n    if (tracks.length === 0) {\n      return null;\n    }\n    const clip = new this(clipName, duration, tracks, blendMode);\n    return clip;\n  }\n  resetDuration() {\n    const tracks = this.tracks;\n    let duration = 0;\n    for (let i = 0, n = tracks.length; i !== n; ++i) {\n      const track = this.tracks[i];\n      duration = Math.max(duration, track.times[track.times.length - 1]);\n    }\n    this.duration = duration;\n    return this;\n  }\n  trim() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].trim(0, this.duration);\n    }\n    return this;\n  }\n  validate() {\n    let valid = true;\n    for (let i = 0; i < this.tracks.length; i++) {\n      valid = valid && this.tracks[i].validate();\n    }\n    return valid;\n  }\n  optimize() {\n    for (let i = 0; i < this.tracks.length; i++) {\n      this.tracks[i].optimize();\n    }\n    return this;\n  }\n  clone() {\n    const tracks = [];\n    for (let i = 0; i < this.tracks.length; i++) {\n      tracks.push(this.tracks[i].clone());\n    }\n    return new this.constructor(this.name, this.duration, tracks, this.blendMode);\n  }\n  toJSON() {\n    return this.constructor.toJSON(this);\n  }\n}\nfunction getTrackTypeForValueTypeName(typeName) {\n  switch (typeName.toLowerCase()) {\n    case \"scalar\":\n    case \"double\":\n    case \"float\":\n    case \"number\":\n    case \"integer\":\n      return NumberKeyframeTrack;\n    case \"vector\":\n    case \"vector2\":\n    case \"vector3\":\n    case \"vector4\":\n      return VectorKeyframeTrack;\n    case \"color\":\n      return ColorKeyframeTrack;\n    case \"quaternion\":\n      return QuaternionKeyframeTrack;\n    case \"bool\":\n    case \"boolean\":\n      return BooleanKeyframeTrack;\n    case \"string\":\n      return StringKeyframeTrack;\n  }\n  throw new Error(\"THREE.KeyframeTrack: Unsupported typeName: \" + typeName);\n}\nfunction parseKeyframeTrack(json) {\n  if (json.type === void 0) {\n    throw new Error(\"THREE.KeyframeTrack: track type undefined, can not parse\");\n  }\n  const trackType = getTrackTypeForValueTypeName(json.type);\n  if (json.times === void 0) {\n    const times = [], values = [];\n    AnimationUtils.flattenJSON(json.keys, times, values, \"value\");\n    json.times = times;\n    json.values = values;\n  }\n  if (trackType.parse !== void 0) {\n    return trackType.parse(json);\n  } else {\n    return new trackType(json.name, json.times, json.values, json.interpolation);\n  }\n}\nconst Cache = {\n  enabled: false,\n  files: {},\n  add: function(key, file) {\n    if (this.enabled === false)\n      return;\n    this.files[key] = file;\n  },\n  get: function(key) {\n    if (this.enabled === false)\n      return;\n    return this.files[key];\n  },\n  remove: function(key) {\n    delete this.files[key];\n  },\n  clear: function() {\n    this.files = {};\n  }\n};\nclass LoadingManager {\n  constructor(onLoad, onProgress, onError) {\n    const scope = this;\n    let isLoading = false;\n    let itemsLoaded = 0;\n    let itemsTotal = 0;\n    let urlModifier = void 0;\n    const handlers = [];\n    this.onStart = void 0;\n    this.onLoad = onLoad;\n    this.onProgress = onProgress;\n    this.onError = onError;\n    this.itemStart = function(url) {\n      itemsTotal++;\n      if (isLoading === false) {\n        if (scope.onStart !== void 0) {\n          scope.onStart(url, itemsLoaded, itemsTotal);\n        }\n      }\n      isLoading = true;\n    };\n    this.itemEnd = function(url) {\n      itemsLoaded++;\n      if (scope.onProgress !== void 0) {\n        scope.onProgress(url, itemsLoaded, itemsTotal);\n      }\n      if (itemsLoaded === itemsTotal) {\n        isLoading = false;\n        if (scope.onLoad !== void 0) {\n          scope.onLoad();\n        }\n      }\n    };\n    this.itemError = function(url) {\n      if (scope.onError !== void 0) {\n        scope.onError(url);\n      }\n    };\n    this.resolveURL = function(url) {\n      if (urlModifier) {\n        return urlModifier(url);\n      }\n      return url;\n    };\n    this.setURLModifier = function(transform) {\n      urlModifier = transform;\n      return this;\n    };\n    this.addHandler = function(regex, loader) {\n      handlers.push(regex, loader);\n      return this;\n    };\n    this.removeHandler = function(regex) {\n      const index = handlers.indexOf(regex);\n      if (index !== -1) {\n        handlers.splice(index, 2);\n      }\n      return this;\n    };\n    this.getHandler = function(file) {\n      for (let i = 0, l = handlers.length; i < l; i += 2) {\n        const regex = handlers[i];\n        const loader = handlers[i + 1];\n        if (regex.global)\n          regex.lastIndex = 0;\n        if (regex.test(file)) {\n          return loader;\n        }\n      }\n      return null;\n    };\n  }\n}\nconst DefaultLoadingManager = new LoadingManager();\nclass Loader {\n  constructor(manager) {\n    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;\n    this.crossOrigin = \"anonymous\";\n    this.withCredentials = false;\n    this.path = \"\";\n    this.resourcePath = \"\";\n    this.requestHeader = {};\n  }\n  load() {\n  }\n  loadAsync(url, onProgress) {\n    const scope = this;\n    return new Promise(function(resolve, reject) {\n      scope.load(url, resolve, onProgress, reject);\n    });\n  }\n  parse() {\n  }\n  setCrossOrigin(crossOrigin) {\n    this.crossOrigin = crossOrigin;\n    return this;\n  }\n  setWithCredentials(value) {\n    this.withCredentials = value;\n    return this;\n  }\n  setPath(path) {\n    this.path = path;\n    return this;\n  }\n  setResourcePath(resourcePath) {\n    this.resourcePath = resourcePath;\n    return this;\n  }\n  setRequestHeader(requestHeader) {\n    this.requestHeader = requestHeader;\n    return this;\n  }\n}\nconst loading = {};\nclass FileLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (url === void 0)\n      url = \"\";\n    if (this.path !== void 0)\n      url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n    if (cached !== void 0) {\n      scope.manager.itemStart(url);\n      setTimeout(function() {\n        if (onLoad)\n          onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n    if (loading[url] !== void 0) {\n      loading[url].push({\n        onLoad,\n        onProgress,\n        onError\n      });\n      return;\n    }\n    const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;\n    const dataUriRegexResult = url.match(dataUriRegex);\n    let request;\n    if (dataUriRegexResult) {\n      const mimeType = dataUriRegexResult[1];\n      const isBase64 = !!dataUriRegexResult[2];\n      let data = dataUriRegexResult[3];\n      data = decodeURIComponent(data);\n      if (isBase64)\n        data = atob(data);\n      try {\n        let response;\n        const responseType = (this.responseType || \"\").toLowerCase();\n        switch (responseType) {\n          case \"arraybuffer\":\n          case \"blob\":\n            const view = new Uint8Array(data.length);\n            for (let i = 0; i < data.length; i++) {\n              view[i] = data.charCodeAt(i);\n            }\n            if (responseType === \"blob\") {\n              response = new Blob([view.buffer], {type: mimeType});\n            } else {\n              response = view.buffer;\n            }\n            break;\n          case \"document\":\n            const parser = new DOMParser();\n            response = parser.parseFromString(data, mimeType);\n            break;\n          case \"json\":\n            response = JSON.parse(data);\n            break;\n          default:\n            response = data;\n            break;\n        }\n        setTimeout(function() {\n          if (onLoad)\n            onLoad(response);\n          scope.manager.itemEnd(url);\n        }, 0);\n      } catch (error) {\n        setTimeout(function() {\n          if (onError)\n            onError(error);\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        }, 0);\n      }\n    } else {\n      loading[url] = [];\n      loading[url].push({\n        onLoad,\n        onProgress,\n        onError\n      });\n      request = new XMLHttpRequest();\n      request.open(\"GET\", url, true);\n      request.addEventListener(\"load\", function(event) {\n        const response = this.response;\n        const callbacks = loading[url];\n        delete loading[url];\n        if (this.status === 200 || this.status === 0) {\n          if (this.status === 0)\n            console.warn(\"THREE.FileLoader: HTTP Status 0 received.\");\n          Cache.add(url, response);\n          for (let i = 0, il = callbacks.length; i < il; i++) {\n            const callback = callbacks[i];\n            if (callback.onLoad)\n              callback.onLoad(response);\n          }\n          scope.manager.itemEnd(url);\n        } else {\n          for (let i = 0, il = callbacks.length; i < il; i++) {\n            const callback = callbacks[i];\n            if (callback.onError)\n              callback.onError(event);\n          }\n          scope.manager.itemError(url);\n          scope.manager.itemEnd(url);\n        }\n      }, false);\n      request.addEventListener(\"progress\", function(event) {\n        const callbacks = loading[url];\n        for (let i = 0, il = callbacks.length; i < il; i++) {\n          const callback = callbacks[i];\n          if (callback.onProgress)\n            callback.onProgress(event);\n        }\n      }, false);\n      request.addEventListener(\"error\", function(event) {\n        const callbacks = loading[url];\n        delete loading[url];\n        for (let i = 0, il = callbacks.length; i < il; i++) {\n          const callback = callbacks[i];\n          if (callback.onError)\n            callback.onError(event);\n        }\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      }, false);\n      request.addEventListener(\"abort\", function(event) {\n        const callbacks = loading[url];\n        delete loading[url];\n        for (let i = 0, il = callbacks.length; i < il; i++) {\n          const callback = callbacks[i];\n          if (callback.onError)\n            callback.onError(event);\n        }\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      }, false);\n      if (this.responseType !== void 0)\n        request.responseType = this.responseType;\n      if (this.withCredentials !== void 0)\n        request.withCredentials = this.withCredentials;\n      if (request.overrideMimeType)\n        request.overrideMimeType(this.mimeType !== void 0 ? this.mimeType : \"text/plain\");\n      for (const header in this.requestHeader) {\n        request.setRequestHeader(header, this.requestHeader[header]);\n      }\n      request.send(null);\n    }\n    scope.manager.itemStart(url);\n    return request;\n  }\n  setResponseType(value) {\n    this.responseType = value;\n    return this;\n  }\n  setMimeType(value) {\n    this.mimeType = value;\n    return this;\n  }\n}\nclass AnimationLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function(text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(json) {\n    const animations = [];\n    for (let i = 0; i < json.length; i++) {\n      const clip = AnimationClip.parse(json[i]);\n      animations.push(clip);\n    }\n    return animations;\n  }\n}\nclass CompressedTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const images = [];\n    const texture = new CompressedTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    let loaded = 0;\n    function loadTexture(i) {\n      loader.load(url[i], function(buffer) {\n        const texDatas = scope.parse(buffer, true);\n        images[i] = {\n          width: texDatas.width,\n          height: texDatas.height,\n          format: texDatas.format,\n          mipmaps: texDatas.mipmaps\n        };\n        loaded += 1;\n        if (loaded === 6) {\n          if (texDatas.mipmapCount === 1)\n            texture.minFilter = LinearFilter;\n          texture.image = images;\n          texture.format = texDatas.format;\n          texture.needsUpdate = true;\n          if (onLoad)\n            onLoad(texture);\n        }\n      }, onProgress, onError);\n    }\n    if (Array.isArray(url)) {\n      for (let i = 0, il = url.length; i < il; ++i) {\n        loadTexture(i);\n      }\n    } else {\n      loader.load(url, function(buffer) {\n        const texDatas = scope.parse(buffer, true);\n        if (texDatas.isCubemap) {\n          const faces = texDatas.mipmaps.length / texDatas.mipmapCount;\n          for (let f = 0; f < faces; f++) {\n            images[f] = {mipmaps: []};\n            for (let i = 0; i < texDatas.mipmapCount; i++) {\n              images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + i]);\n              images[f].format = texDatas.format;\n              images[f].width = texDatas.width;\n              images[f].height = texDatas.height;\n            }\n          }\n          texture.image = images;\n        } else {\n          texture.image.width = texDatas.width;\n          texture.image.height = texDatas.height;\n          texture.mipmaps = texDatas.mipmaps;\n        }\n        if (texDatas.mipmapCount === 1) {\n          texture.minFilter = LinearFilter;\n        }\n        texture.format = texDatas.format;\n        texture.needsUpdate = true;\n        if (onLoad)\n          onLoad(texture);\n      }, onProgress, onError);\n    }\n    return texture;\n  }\n}\nclass ImageLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (this.path !== void 0)\n      url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n    if (cached !== void 0) {\n      scope.manager.itemStart(url);\n      setTimeout(function() {\n        if (onLoad)\n          onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n    const image = document.createElementNS(\"http://www.w3.org/1999/xhtml\", \"img\");\n    function onImageLoad() {\n      image.removeEventListener(\"load\", onImageLoad, false);\n      image.removeEventListener(\"error\", onImageError, false);\n      Cache.add(url, this);\n      if (onLoad)\n        onLoad(this);\n      scope.manager.itemEnd(url);\n    }\n    function onImageError(event) {\n      image.removeEventListener(\"load\", onImageLoad, false);\n      image.removeEventListener(\"error\", onImageError, false);\n      if (onError)\n        onError(event);\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    }\n    image.addEventListener(\"load\", onImageLoad, false);\n    image.addEventListener(\"error\", onImageError, false);\n    if (url.substr(0, 5) !== \"data:\") {\n      if (this.crossOrigin !== void 0)\n        image.crossOrigin = this.crossOrigin;\n    }\n    scope.manager.itemStart(url);\n    image.src = url;\n    return image;\n  }\n}\nclass CubeTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(urls, onLoad, onProgress, onError) {\n    const texture = new CubeTexture();\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    let loaded = 0;\n    function loadTexture(i) {\n      loader.load(urls[i], function(image) {\n        texture.images[i] = image;\n        loaded++;\n        if (loaded === 6) {\n          texture.needsUpdate = true;\n          if (onLoad)\n            onLoad(texture);\n        }\n      }, void 0, onError);\n    }\n    for (let i = 0; i < urls.length; ++i) {\n      loadTexture(i);\n    }\n    return texture;\n  }\n}\nclass DataTextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const texture = new DataTexture();\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setPath(this.path);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function(buffer) {\n      const texData = scope.parse(buffer);\n      if (!texData)\n        return;\n      if (texData.image !== void 0) {\n        texture.image = texData.image;\n      } else if (texData.data !== void 0) {\n        texture.image.width = texData.width;\n        texture.image.height = texData.height;\n        texture.image.data = texData.data;\n      }\n      texture.wrapS = texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping;\n      texture.wrapT = texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping;\n      texture.magFilter = texData.magFilter !== void 0 ? texData.magFilter : LinearFilter;\n      texture.minFilter = texData.minFilter !== void 0 ? texData.minFilter : LinearFilter;\n      texture.anisotropy = texData.anisotropy !== void 0 ? texData.anisotropy : 1;\n      if (texData.encoding !== void 0) {\n        texture.encoding = texData.encoding;\n      }\n      if (texData.flipY !== void 0) {\n        texture.flipY = texData.flipY;\n      }\n      if (texData.format !== void 0) {\n        texture.format = texData.format;\n      }\n      if (texData.type !== void 0) {\n        texture.type = texData.type;\n      }\n      if (texData.mipmaps !== void 0) {\n        texture.mipmaps = texData.mipmaps;\n        texture.minFilter = LinearMipmapLinearFilter;\n      }\n      if (texData.mipmapCount === 1) {\n        texture.minFilter = LinearFilter;\n      }\n      if (texData.generateMipmaps !== void 0) {\n        texture.generateMipmaps = texData.generateMipmaps;\n      }\n      texture.needsUpdate = true;\n      if (onLoad)\n        onLoad(texture, texData);\n    }, onProgress, onError);\n    return texture;\n  }\n}\nclass TextureLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const texture = new Texture();\n    const loader = new ImageLoader(this.manager);\n    loader.setCrossOrigin(this.crossOrigin);\n    loader.setPath(this.path);\n    loader.load(url, function(image) {\n      texture.image = image;\n      const isJPEG = url.search(/\\.jpe?g($|\\?)/i) > 0 || url.search(/^data\\:image\\/jpeg/) === 0;\n      texture.format = isJPEG ? RGBFormat : RGBAFormat;\n      texture.needsUpdate = true;\n      if (onLoad !== void 0) {\n        onLoad(texture);\n      }\n    }, onProgress, onError);\n    return texture;\n  }\n}\nclass Curve {\n  constructor() {\n    this.type = \"Curve\";\n    this.arcLengthDivisions = 200;\n  }\n  getPoint() {\n    console.warn(\"THREE.Curve: .getPoint() not implemented.\");\n    return null;\n  }\n  getPointAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getPoint(t, optionalTarget);\n  }\n  getPoints(divisions = 5) {\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPoint(d / divisions));\n    }\n    return points;\n  }\n  getSpacedPoints(divisions = 5) {\n    const points = [];\n    for (let d = 0; d <= divisions; d++) {\n      points.push(this.getPointAt(d / divisions));\n    }\n    return points;\n  }\n  getLength() {\n    const lengths = this.getLengths();\n    return lengths[lengths.length - 1];\n  }\n  getLengths(divisions = this.arcLengthDivisions) {\n    if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {\n      return this.cacheArcLengths;\n    }\n    this.needsUpdate = false;\n    const cache = [];\n    let current, last = this.getPoint(0);\n    let sum = 0;\n    cache.push(0);\n    for (let p = 1; p <= divisions; p++) {\n      current = this.getPoint(p / divisions);\n      sum += current.distanceTo(last);\n      cache.push(sum);\n      last = current;\n    }\n    this.cacheArcLengths = cache;\n    return cache;\n  }\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.getLengths();\n  }\n  getUtoTmapping(u, distance) {\n    const arcLengths = this.getLengths();\n    let i = 0;\n    const il = arcLengths.length;\n    let targetArcLength;\n    if (distance) {\n      targetArcLength = distance;\n    } else {\n      targetArcLength = u * arcLengths[il - 1];\n    }\n    let low = 0, high = il - 1, comparison;\n    while (low <= high) {\n      i = Math.floor(low + (high - low) / 2);\n      comparison = arcLengths[i] - targetArcLength;\n      if (comparison < 0) {\n        low = i + 1;\n      } else if (comparison > 0) {\n        high = i - 1;\n      } else {\n        high = i;\n        break;\n      }\n    }\n    i = high;\n    if (arcLengths[i] === targetArcLength) {\n      return i / (il - 1);\n    }\n    const lengthBefore = arcLengths[i];\n    const lengthAfter = arcLengths[i + 1];\n    const segmentLength = lengthAfter - lengthBefore;\n    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\n    const t = (i + segmentFraction) / (il - 1);\n    return t;\n  }\n  getTangent(t, optionalTarget) {\n    const delta = 1e-4;\n    let t1 = t - delta;\n    let t2 = t + delta;\n    if (t1 < 0)\n      t1 = 0;\n    if (t2 > 1)\n      t2 = 1;\n    const pt1 = this.getPoint(t1);\n    const pt2 = this.getPoint(t2);\n    const tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());\n    tangent.copy(pt2).sub(pt1).normalize();\n    return tangent;\n  }\n  getTangentAt(u, optionalTarget) {\n    const t = this.getUtoTmapping(u);\n    return this.getTangent(t, optionalTarget);\n  }\n  computeFrenetFrames(segments, closed) {\n    const normal = new Vector3();\n    const tangents = [];\n    const normals = [];\n    const binormals = [];\n    const vec = new Vector3();\n    const mat = new Matrix4();\n    for (let i = 0; i <= segments; i++) {\n      const u = i / segments;\n      tangents[i] = this.getTangentAt(u, new Vector3());\n      tangents[i].normalize();\n    }\n    normals[0] = new Vector3();\n    binormals[0] = new Vector3();\n    let min = Number.MAX_VALUE;\n    const tx = Math.abs(tangents[0].x);\n    const ty = Math.abs(tangents[0].y);\n    const tz = Math.abs(tangents[0].z);\n    if (tx <= min) {\n      min = tx;\n      normal.set(1, 0, 0);\n    }\n    if (ty <= min) {\n      min = ty;\n      normal.set(0, 1, 0);\n    }\n    if (tz <= min) {\n      normal.set(0, 0, 1);\n    }\n    vec.crossVectors(tangents[0], normal).normalize();\n    normals[0].crossVectors(tangents[0], vec);\n    binormals[0].crossVectors(tangents[0], normals[0]);\n    for (let i = 1; i <= segments; i++) {\n      normals[i] = normals[i - 1].clone();\n      binormals[i] = binormals[i - 1].clone();\n      vec.crossVectors(tangents[i - 1], tangents[i]);\n      if (vec.length() > Number.EPSILON) {\n        vec.normalize();\n        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1));\n        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta));\n      }\n      binormals[i].crossVectors(tangents[i], normals[i]);\n    }\n    if (closed === true) {\n      let theta = Math.acos(clamp(normals[0].dot(normals[segments]), -1, 1));\n      theta /= segments;\n      if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {\n        theta = -theta;\n      }\n      for (let i = 1; i <= segments; i++) {\n        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i));\n        binormals[i].crossVectors(tangents[i], normals[i]);\n      }\n    }\n    return {\n      tangents,\n      normals,\n      binormals\n    };\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(source) {\n    this.arcLengthDivisions = source.arcLengthDivisions;\n    return this;\n  }\n  toJSON() {\n    const data = {\n      metadata: {\n        version: 4.5,\n        type: \"Curve\",\n        generator: \"Curve.toJSON\"\n      }\n    };\n    data.arcLengthDivisions = this.arcLengthDivisions;\n    data.type = this.type;\n    return data;\n  }\n  fromJSON(json) {\n    this.arcLengthDivisions = json.arcLengthDivisions;\n    return this;\n  }\n}\nclass EllipseCurve extends Curve {\n  constructor(aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0) {\n    super();\n    this.type = \"EllipseCurve\";\n    this.aX = aX;\n    this.aY = aY;\n    this.xRadius = xRadius;\n    this.yRadius = yRadius;\n    this.aStartAngle = aStartAngle;\n    this.aEndAngle = aEndAngle;\n    this.aClockwise = aClockwise;\n    this.aRotation = aRotation;\n  }\n  getPoint(t, optionalTarget) {\n    const point = optionalTarget || new Vector2();\n    const twoPi = Math.PI * 2;\n    let deltaAngle = this.aEndAngle - this.aStartAngle;\n    const samePoints = Math.abs(deltaAngle) < Number.EPSILON;\n    while (deltaAngle < 0)\n      deltaAngle += twoPi;\n    while (deltaAngle > twoPi)\n      deltaAngle -= twoPi;\n    if (deltaAngle < Number.EPSILON) {\n      if (samePoints) {\n        deltaAngle = 0;\n      } else {\n        deltaAngle = twoPi;\n      }\n    }\n    if (this.aClockwise === true && !samePoints) {\n      if (deltaAngle === twoPi) {\n        deltaAngle = -twoPi;\n      } else {\n        deltaAngle = deltaAngle - twoPi;\n      }\n    }\n    const angle = this.aStartAngle + t * deltaAngle;\n    let x = this.aX + this.xRadius * Math.cos(angle);\n    let y = this.aY + this.yRadius * Math.sin(angle);\n    if (this.aRotation !== 0) {\n      const cos = Math.cos(this.aRotation);\n      const sin = Math.sin(this.aRotation);\n      const tx = x - this.aX;\n      const ty = y - this.aY;\n      x = tx * cos - ty * sin + this.aX;\n      y = tx * sin + ty * cos + this.aY;\n    }\n    return point.set(x, y);\n  }\n  copy(source) {\n    super.copy(source);\n    this.aX = source.aX;\n    this.aY = source.aY;\n    this.xRadius = source.xRadius;\n    this.yRadius = source.yRadius;\n    this.aStartAngle = source.aStartAngle;\n    this.aEndAngle = source.aEndAngle;\n    this.aClockwise = source.aClockwise;\n    this.aRotation = source.aRotation;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.aX = this.aX;\n    data.aY = this.aY;\n    data.xRadius = this.xRadius;\n    data.yRadius = this.yRadius;\n    data.aStartAngle = this.aStartAngle;\n    data.aEndAngle = this.aEndAngle;\n    data.aClockwise = this.aClockwise;\n    data.aRotation = this.aRotation;\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.aX = json.aX;\n    this.aY = json.aY;\n    this.xRadius = json.xRadius;\n    this.yRadius = json.yRadius;\n    this.aStartAngle = json.aStartAngle;\n    this.aEndAngle = json.aEndAngle;\n    this.aClockwise = json.aClockwise;\n    this.aRotation = json.aRotation;\n    return this;\n  }\n}\nEllipseCurve.prototype.isEllipseCurve = true;\nclass ArcCurve extends EllipseCurve {\n  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    this.type = \"ArcCurve\";\n  }\n}\nArcCurve.prototype.isArcCurve = true;\nfunction CubicPoly() {\n  let c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n  function init(x0, x1, t0, t1) {\n    c0 = x0;\n    c1 = t0;\n    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;\n    c3 = 2 * x0 - 2 * x1 + t0 + t1;\n  }\n  return {\n    initCatmullRom: function(x0, x1, x2, x3, tension) {\n      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));\n    },\n    initNonuniformCatmullRom: function(x0, x1, x2, x3, dt0, dt1, dt2) {\n      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;\n      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;\n      t1 *= dt1;\n      t2 *= dt1;\n      init(x1, x2, t1, t2);\n    },\n    calc: function(t) {\n      const t2 = t * t;\n      const t3 = t2 * t;\n      return c0 + c1 * t + c2 * t2 + c3 * t3;\n    }\n  };\n}\nconst tmp = new Vector3();\nconst px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\nclass CatmullRomCurve3 extends Curve {\n  constructor(points = [], closed = false, curveType = \"centripetal\", tension = 0.5) {\n    super();\n    this.type = \"CatmullRomCurve3\";\n    this.points = points;\n    this.closed = closed;\n    this.curveType = curveType;\n    this.tension = tension;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const points = this.points;\n    const l = points.length;\n    const p = (l - (this.closed ? 0 : 1)) * t;\n    let intPoint = Math.floor(p);\n    let weight = p - intPoint;\n    if (this.closed) {\n      intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;\n    } else if (weight === 0 && intPoint === l - 1) {\n      intPoint = l - 2;\n      weight = 1;\n    }\n    let p0, p3;\n    if (this.closed || intPoint > 0) {\n      p0 = points[(intPoint - 1) % l];\n    } else {\n      tmp.subVectors(points[0], points[1]).add(points[0]);\n      p0 = tmp;\n    }\n    const p1 = points[intPoint % l];\n    const p2 = points[(intPoint + 1) % l];\n    if (this.closed || intPoint + 2 < l) {\n      p3 = points[(intPoint + 2) % l];\n    } else {\n      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);\n      p3 = tmp;\n    }\n    if (this.curveType === \"centripetal\" || this.curveType === \"chordal\") {\n      const pow = this.curveType === \"chordal\" ? 0.5 : 0.25;\n      let dt0 = Math.pow(p0.distanceToSquared(p1), pow);\n      let dt1 = Math.pow(p1.distanceToSquared(p2), pow);\n      let dt2 = Math.pow(p2.distanceToSquared(p3), pow);\n      if (dt1 < 1e-4)\n        dt1 = 1;\n      if (dt0 < 1e-4)\n        dt0 = dt1;\n      if (dt2 < 1e-4)\n        dt2 = dt1;\n      px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);\n      py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);\n      pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);\n    } else if (this.curveType === \"catmullrom\") {\n      px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);\n      py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);\n      pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);\n    }\n    point.set(px.calc(weight), py.calc(weight), pz.calc(weight));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.points = [];\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n      this.points.push(point.clone());\n    }\n    this.closed = source.closed;\n    this.curveType = source.curveType;\n    this.tension = source.tension;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.points = [];\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n    data.closed = this.closed;\n    data.curveType = this.curveType;\n    data.tension = this.tension;\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.points = [];\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector3().fromArray(point));\n    }\n    this.closed = json.closed;\n    this.curveType = json.curveType;\n    this.tension = json.tension;\n    return this;\n  }\n}\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\nfunction CatmullRom(t, p0, p1, p2, p3) {\n  const v0 = (p2 - p0) * 0.5;\n  const v1 = (p3 - p1) * 0.5;\n  const t2 = t * t;\n  const t3 = t * t2;\n  return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;\n}\nfunction QuadraticBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * p;\n}\nfunction QuadraticBezierP1(t, p) {\n  return 2 * (1 - t) * t * p;\n}\nfunction QuadraticBezierP2(t, p) {\n  return t * t * p;\n}\nfunction QuadraticBezier(t, p0, p1, p2) {\n  return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);\n}\nfunction CubicBezierP0(t, p) {\n  const k = 1 - t;\n  return k * k * k * p;\n}\nfunction CubicBezierP1(t, p) {\n  const k = 1 - t;\n  return 3 * k * k * t * p;\n}\nfunction CubicBezierP2(t, p) {\n  return 3 * (1 - t) * t * t * p;\n}\nfunction CubicBezierP3(t, p) {\n  return t * t * t * p;\n}\nfunction CubicBezier(t, p0, p1, p2, p3) {\n  return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);\n}\nclass CubicBezierCurve extends Curve {\n  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2()) {\n    super();\n    this.type = \"CubicBezierCurve\";\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n    return this;\n  }\n}\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\nclass CubicBezierCurve3 extends Curve {\n  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3()) {\n    super();\n    this.type = \"CubicBezierCurve3\";\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n    point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    this.v3.copy(source.v3);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    data.v3 = this.v3.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    this.v3.fromArray(json.v3);\n    return this;\n  }\n}\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\nclass LineCurve extends Curve {\n  constructor(v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n    this.type = \"LineCurve\";\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n    return point;\n  }\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n  getTangent(t, optionalTarget) {\n    const tangent = optionalTarget || new Vector2();\n    tangent.copy(this.v2).sub(this.v1).normalize();\n    return tangent;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nLineCurve.prototype.isLineCurve = true;\nclass LineCurve3 extends Curve {\n  constructor(v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n    this.type = \"LineCurve3\";\n    this.isLineCurve3 = true;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    if (t === 1) {\n      point.copy(this.v2);\n    } else {\n      point.copy(this.v2).sub(this.v1);\n      point.multiplyScalar(t).add(this.v1);\n    }\n    return point;\n  }\n  getPointAt(u, optionalTarget) {\n    return this.getPoint(u, optionalTarget);\n  }\n  copy(source) {\n    super.copy(source);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nclass QuadraticBezierCurve extends Curve {\n  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {\n    super();\n    this.type = \"QuadraticBezierCurve\";\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2;\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\nclass QuadraticBezierCurve3 extends Curve {\n  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {\n    super();\n    this.type = \"QuadraticBezierCurve3\";\n    this.v0 = v0;\n    this.v1 = v1;\n    this.v2 = v2;\n  }\n  getPoint(t, optionalTarget = new Vector3()) {\n    const point = optionalTarget;\n    const v0 = this.v0, v1 = this.v1, v2 = this.v2;\n    point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.v0.copy(source.v0);\n    this.v1.copy(source.v1);\n    this.v2.copy(source.v2);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.v0 = this.v0.toArray();\n    data.v1 = this.v1.toArray();\n    data.v2 = this.v2.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.v0.fromArray(json.v0);\n    this.v1.fromArray(json.v1);\n    this.v2.fromArray(json.v2);\n    return this;\n  }\n}\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\nclass SplineCurve extends Curve {\n  constructor(points = []) {\n    super();\n    this.type = \"SplineCurve\";\n    this.points = points;\n  }\n  getPoint(t, optionalTarget = new Vector2()) {\n    const point = optionalTarget;\n    const points = this.points;\n    const p = (points.length - 1) * t;\n    const intPoint = Math.floor(p);\n    const weight = p - intPoint;\n    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1];\n    const p1 = points[intPoint];\n    const p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];\n    const p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];\n    point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));\n    return point;\n  }\n  copy(source) {\n    super.copy(source);\n    this.points = [];\n    for (let i = 0, l = source.points.length; i < l; i++) {\n      const point = source.points[i];\n      this.points.push(point.clone());\n    }\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.points = [];\n    for (let i = 0, l = this.points.length; i < l; i++) {\n      const point = this.points[i];\n      data.points.push(point.toArray());\n    }\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.points = [];\n    for (let i = 0, l = json.points.length; i < l; i++) {\n      const point = json.points[i];\n      this.points.push(new Vector2().fromArray(point));\n    }\n    return this;\n  }\n}\nSplineCurve.prototype.isSplineCurve = true;\nvar Curves = /* @__PURE__ */ Object.freeze({\n  __proto__: null,\n  ArcCurve,\n  CatmullRomCurve3,\n  CubicBezierCurve,\n  CubicBezierCurve3,\n  EllipseCurve,\n  LineCurve,\n  LineCurve3,\n  QuadraticBezierCurve,\n  QuadraticBezierCurve3,\n  SplineCurve\n});\nclass CurvePath extends Curve {\n  constructor() {\n    super();\n    this.type = \"CurvePath\";\n    this.curves = [];\n    this.autoClose = false;\n  }\n  add(curve) {\n    this.curves.push(curve);\n  }\n  closePath() {\n    const startPoint = this.curves[0].getPoint(0);\n    const endPoint = this.curves[this.curves.length - 1].getPoint(1);\n    if (!startPoint.equals(endPoint)) {\n      this.curves.push(new LineCurve(endPoint, startPoint));\n    }\n  }\n  getPoint(t) {\n    const d = t * this.getLength();\n    const curveLengths = this.getCurveLengths();\n    let i = 0;\n    while (i < curveLengths.length) {\n      if (curveLengths[i] >= d) {\n        const diff = curveLengths[i] - d;\n        const curve = this.curves[i];\n        const segmentLength = curve.getLength();\n        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n        return curve.getPointAt(u);\n      }\n      i++;\n    }\n    return null;\n  }\n  getLength() {\n    const lens = this.getCurveLengths();\n    return lens[lens.length - 1];\n  }\n  updateArcLengths() {\n    this.needsUpdate = true;\n    this.cacheLengths = null;\n    this.getCurveLengths();\n  }\n  getCurveLengths() {\n    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {\n      return this.cacheLengths;\n    }\n    const lengths = [];\n    let sums = 0;\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      sums += this.curves[i].getLength();\n      lengths.push(sums);\n    }\n    this.cacheLengths = lengths;\n    return lengths;\n  }\n  getSpacedPoints(divisions = 40) {\n    const points = [];\n    for (let i = 0; i <= divisions; i++) {\n      points.push(this.getPoint(i / divisions));\n    }\n    if (this.autoClose) {\n      points.push(points[0]);\n    }\n    return points;\n  }\n  getPoints(divisions = 12) {\n    const points = [];\n    let last;\n    for (let i = 0, curves = this.curves; i < curves.length; i++) {\n      const curve = curves[i];\n      const resolution = curve && curve.isEllipseCurve ? divisions * 2 : curve && (curve.isLineCurve || curve.isLineCurve3) ? 1 : curve && curve.isSplineCurve ? divisions * curve.points.length : divisions;\n      const pts = curve.getPoints(resolution);\n      for (let j = 0; j < pts.length; j++) {\n        const point = pts[j];\n        if (last && last.equals(point))\n          continue;\n        points.push(point);\n        last = point;\n      }\n    }\n    if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {\n      points.push(points[0]);\n    }\n    return points;\n  }\n  copy(source) {\n    super.copy(source);\n    this.curves = [];\n    for (let i = 0, l = source.curves.length; i < l; i++) {\n      const curve = source.curves[i];\n      this.curves.push(curve.clone());\n    }\n    this.autoClose = source.autoClose;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.autoClose = this.autoClose;\n    data.curves = [];\n    for (let i = 0, l = this.curves.length; i < l; i++) {\n      const curve = this.curves[i];\n      data.curves.push(curve.toJSON());\n    }\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.autoClose = json.autoClose;\n    this.curves = [];\n    for (let i = 0, l = json.curves.length; i < l; i++) {\n      const curve = json.curves[i];\n      this.curves.push(new Curves[curve.type]().fromJSON(curve));\n    }\n    return this;\n  }\n}\nclass Path extends CurvePath {\n  constructor(points) {\n    super();\n    this.type = \"Path\";\n    this.currentPoint = new Vector2();\n    if (points) {\n      this.setFromPoints(points);\n    }\n  }\n  setFromPoints(points) {\n    this.moveTo(points[0].x, points[0].y);\n    for (let i = 1, l = points.length; i < l; i++) {\n      this.lineTo(points[i].x, points[i].y);\n    }\n    return this;\n  }\n  moveTo(x, y) {\n    this.currentPoint.set(x, y);\n    return this;\n  }\n  lineTo(x, y) {\n    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));\n    this.curves.push(curve);\n    this.currentPoint.set(x, y);\n    return this;\n  }\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    const curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  }\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    const curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));\n    this.curves.push(curve);\n    this.currentPoint.set(aX, aY);\n    return this;\n  }\n  splineThru(pts) {\n    const npts = [this.currentPoint.clone()].concat(pts);\n    const curve = new SplineCurve(npts);\n    this.curves.push(curve);\n    this.currentPoint.copy(pts[pts.length - 1]);\n    return this;\n  }\n  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  }\n  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {\n    this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);\n    return this;\n  }\n  ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    const x0 = this.currentPoint.x;\n    const y0 = this.currentPoint.y;\n    this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n    return this;\n  }\n  absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {\n    const curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);\n    if (this.curves.length > 0) {\n      const firstPoint = curve.getPoint(0);\n      if (!firstPoint.equals(this.currentPoint)) {\n        this.lineTo(firstPoint.x, firstPoint.y);\n      }\n    }\n    this.curves.push(curve);\n    const lastPoint = curve.getPoint(1);\n    this.currentPoint.copy(lastPoint);\n    return this;\n  }\n  copy(source) {\n    super.copy(source);\n    this.currentPoint.copy(source.currentPoint);\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.currentPoint = this.currentPoint.toArray();\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.currentPoint.fromArray(json.currentPoint);\n    return this;\n  }\n}\nclass Shape extends Path {\n  constructor(points) {\n    super(points);\n    this.uuid = generateUUID();\n    this.type = \"Shape\";\n    this.holes = [];\n  }\n  getPointsHoles(divisions) {\n    const holesPts = [];\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      holesPts[i] = this.holes[i].getPoints(divisions);\n    }\n    return holesPts;\n  }\n  extractPoints(divisions) {\n    return {\n      shape: this.getPoints(divisions),\n      holes: this.getPointsHoles(divisions)\n    };\n  }\n  copy(source) {\n    super.copy(source);\n    this.holes = [];\n    for (let i = 0, l = source.holes.length; i < l; i++) {\n      const hole = source.holes[i];\n      this.holes.push(hole.clone());\n    }\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.uuid = this.uuid;\n    data.holes = [];\n    for (let i = 0, l = this.holes.length; i < l; i++) {\n      const hole = this.holes[i];\n      data.holes.push(hole.toJSON());\n    }\n    return data;\n  }\n  fromJSON(json) {\n    super.fromJSON(json);\n    this.uuid = json.uuid;\n    this.holes = [];\n    for (let i = 0, l = json.holes.length; i < l; i++) {\n      const hole = json.holes[i];\n      this.holes.push(new Path().fromJSON(hole));\n    }\n    return this;\n  }\n}\nclass Light extends Object3D {\n  constructor(color, intensity = 1) {\n    super();\n    this.type = \"Light\";\n    this.color = new Color(color);\n    this.intensity = intensity;\n  }\n  dispose() {\n  }\n  copy(source) {\n    super.copy(source);\n    this.color.copy(source.color);\n    this.intensity = source.intensity;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.color = this.color.getHex();\n    data.object.intensity = this.intensity;\n    if (this.groundColor !== void 0)\n      data.object.groundColor = this.groundColor.getHex();\n    if (this.distance !== void 0)\n      data.object.distance = this.distance;\n    if (this.angle !== void 0)\n      data.object.angle = this.angle;\n    if (this.decay !== void 0)\n      data.object.decay = this.decay;\n    if (this.penumbra !== void 0)\n      data.object.penumbra = this.penumbra;\n    if (this.shadow !== void 0)\n      data.object.shadow = this.shadow.toJSON();\n    return data;\n  }\n}\nLight.prototype.isLight = true;\nclass HemisphereLight extends Light {\n  constructor(skyColor, groundColor, intensity) {\n    super(skyColor, intensity);\n    this.type = \"HemisphereLight\";\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n    this.groundColor = new Color(groundColor);\n  }\n  copy(source) {\n    Light.prototype.copy.call(this, source);\n    this.groundColor.copy(source.groundColor);\n    return this;\n  }\n}\nHemisphereLight.prototype.isHemisphereLight = true;\nconst _projScreenMatrix$1 = /* @__PURE__ */ new Matrix4();\nconst _lightPositionWorld$1 = /* @__PURE__ */ new Vector3();\nconst _lookTarget$1 = /* @__PURE__ */ new Vector3();\nclass LightShadow {\n  constructor(camera) {\n    this.camera = camera;\n    this.bias = 0;\n    this.normalBias = 0;\n    this.radius = 1;\n    this.mapSize = new Vector2(512, 512);\n    this.map = null;\n    this.mapPass = null;\n    this.matrix = new Matrix4();\n    this.autoUpdate = true;\n    this.needsUpdate = false;\n    this._frustum = new Frustum();\n    this._frameExtents = new Vector2(1, 1);\n    this._viewportCount = 1;\n    this._viewports = [\n      new Vector4(0, 0, 1, 1)\n    ];\n  }\n  getViewportCount() {\n    return this._viewportCount;\n  }\n  getFrustum() {\n    return this._frustum;\n  }\n  updateMatrices(light) {\n    const shadowCamera = this.camera;\n    const shadowMatrix = this.matrix;\n    _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);\n    shadowCamera.position.copy(_lightPositionWorld$1);\n    _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);\n    shadowCamera.lookAt(_lookTarget$1);\n    shadowCamera.updateMatrixWorld();\n    _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);\n    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1);\n    shadowMatrix.multiply(shadowCamera.projectionMatrix);\n    shadowMatrix.multiply(shadowCamera.matrixWorldInverse);\n  }\n  getViewport(viewportIndex) {\n    return this._viewports[viewportIndex];\n  }\n  getFrameExtents() {\n    return this._frameExtents;\n  }\n  dispose() {\n    if (this.map) {\n      this.map.dispose();\n    }\n    if (this.mapPass) {\n      this.mapPass.dispose();\n    }\n  }\n  copy(source) {\n    this.camera = source.camera.clone();\n    this.bias = source.bias;\n    this.radius = source.radius;\n    this.mapSize.copy(source.mapSize);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  toJSON() {\n    const object = {};\n    if (this.bias !== 0)\n      object.bias = this.bias;\n    if (this.normalBias !== 0)\n      object.normalBias = this.normalBias;\n    if (this.radius !== 1)\n      object.radius = this.radius;\n    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)\n      object.mapSize = this.mapSize.toArray();\n    object.camera = this.camera.toJSON(false).object;\n    delete object.camera.matrix;\n    return object;\n  }\n}\nclass SpotLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(50, 1, 0.5, 500));\n    this.focus = 1;\n  }\n  updateMatrices(light) {\n    const camera = this.camera;\n    const fov2 = RAD2DEG * 2 * light.angle * this.focus;\n    const aspect2 = this.mapSize.width / this.mapSize.height;\n    const far = light.distance || camera.far;\n    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {\n      camera.fov = fov2;\n      camera.aspect = aspect2;\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n    super.updateMatrices(light);\n  }\n  copy(source) {\n    super.copy(source);\n    this.focus = source.focus;\n    return this;\n  }\n}\nSpotLightShadow.prototype.isSpotLightShadow = true;\nclass SpotLight extends Light {\n  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1) {\n    super(color, intensity);\n    this.type = \"SpotLight\";\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.distance = distance;\n    this.angle = angle;\n    this.penumbra = penumbra;\n    this.decay = decay;\n    this.shadow = new SpotLightShadow();\n  }\n  get power() {\n    return this.intensity * Math.PI;\n  }\n  set power(power) {\n    this.intensity = power / Math.PI;\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source) {\n    super.copy(source);\n    this.distance = source.distance;\n    this.angle = source.angle;\n    this.penumbra = source.penumbra;\n    this.decay = source.decay;\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nSpotLight.prototype.isSpotLight = true;\nconst _projScreenMatrix = /* @__PURE__ */ new Matrix4();\nconst _lightPositionWorld = /* @__PURE__ */ new Vector3();\nconst _lookTarget = /* @__PURE__ */ new Vector3();\nclass PointLightShadow extends LightShadow {\n  constructor() {\n    super(new PerspectiveCamera(90, 1, 0.5, 500));\n    this._frameExtents = new Vector2(4, 2);\n    this._viewportCount = 6;\n    this._viewports = [\n      new Vector4(2, 1, 1, 1),\n      new Vector4(0, 1, 1, 1),\n      new Vector4(3, 1, 1, 1),\n      new Vector4(1, 1, 1, 1),\n      new Vector4(3, 0, 1, 1),\n      new Vector4(1, 0, 1, 1)\n    ];\n    this._cubeDirections = [\n      new Vector3(1, 0, 0),\n      new Vector3(-1, 0, 0),\n      new Vector3(0, 0, 1),\n      new Vector3(0, 0, -1),\n      new Vector3(0, 1, 0),\n      new Vector3(0, -1, 0)\n    ];\n    this._cubeUps = [\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 1, 0),\n      new Vector3(0, 0, 1),\n      new Vector3(0, 0, -1)\n    ];\n  }\n  updateMatrices(light, viewportIndex = 0) {\n    const camera = this.camera;\n    const shadowMatrix = this.matrix;\n    const far = light.distance || camera.far;\n    if (far !== camera.far) {\n      camera.far = far;\n      camera.updateProjectionMatrix();\n    }\n    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);\n    camera.position.copy(_lightPositionWorld);\n    _lookTarget.copy(camera.position);\n    _lookTarget.add(this._cubeDirections[viewportIndex]);\n    camera.up.copy(this._cubeUps[viewportIndex]);\n    camera.lookAt(_lookTarget);\n    camera.updateMatrixWorld();\n    shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);\n    _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);\n    this._frustum.setFromProjectionMatrix(_projScreenMatrix);\n  }\n}\nPointLightShadow.prototype.isPointLightShadow = true;\nclass PointLight extends Light {\n  constructor(color, intensity, distance = 0, decay = 1) {\n    super(color, intensity);\n    this.type = \"PointLight\";\n    this.distance = distance;\n    this.decay = decay;\n    this.shadow = new PointLightShadow();\n  }\n  get power() {\n    return this.intensity * 4 * Math.PI;\n  }\n  set power(power) {\n    this.intensity = power / (4 * Math.PI);\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source) {\n    super.copy(source);\n    this.distance = source.distance;\n    this.decay = source.decay;\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nPointLight.prototype.isPointLight = true;\nclass OrthographicCamera extends Camera {\n  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {\n    super();\n    this.type = \"OrthographicCamera\";\n    this.zoom = 1;\n    this.view = null;\n    this.left = left;\n    this.right = right;\n    this.top = top;\n    this.bottom = bottom;\n    this.near = near;\n    this.far = far;\n    this.updateProjectionMatrix();\n  }\n  copy(source, recursive) {\n    super.copy(source, recursive);\n    this.left = source.left;\n    this.right = source.right;\n    this.top = source.top;\n    this.bottom = source.bottom;\n    this.near = source.near;\n    this.far = source.far;\n    this.zoom = source.zoom;\n    this.view = source.view === null ? null : Object.assign({}, source.view);\n    return this;\n  }\n  setViewOffset(fullWidth, fullHeight, x, y, width, height) {\n    if (this.view === null) {\n      this.view = {\n        enabled: true,\n        fullWidth: 1,\n        fullHeight: 1,\n        offsetX: 0,\n        offsetY: 0,\n        width: 1,\n        height: 1\n      };\n    }\n    this.view.enabled = true;\n    this.view.fullWidth = fullWidth;\n    this.view.fullHeight = fullHeight;\n    this.view.offsetX = x;\n    this.view.offsetY = y;\n    this.view.width = width;\n    this.view.height = height;\n    this.updateProjectionMatrix();\n  }\n  clearViewOffset() {\n    if (this.view !== null) {\n      this.view.enabled = false;\n    }\n    this.updateProjectionMatrix();\n  }\n  updateProjectionMatrix() {\n    const dx = (this.right - this.left) / (2 * this.zoom);\n    const dy = (this.top - this.bottom) / (2 * this.zoom);\n    const cx = (this.right + this.left) / 2;\n    const cy = (this.top + this.bottom) / 2;\n    let left = cx - dx;\n    let right = cx + dx;\n    let top = cy + dy;\n    let bottom = cy - dy;\n    if (this.view !== null && this.view.enabled) {\n      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;\n      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;\n      left += scaleW * this.view.offsetX;\n      right = left + scaleW * this.view.width;\n      top -= scaleH * this.view.offsetY;\n      bottom = top - scaleH * this.view.height;\n    }\n    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far);\n    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.zoom = this.zoom;\n    data.object.left = this.left;\n    data.object.right = this.right;\n    data.object.top = this.top;\n    data.object.bottom = this.bottom;\n    data.object.near = this.near;\n    data.object.far = this.far;\n    if (this.view !== null)\n      data.object.view = Object.assign({}, this.view);\n    return data;\n  }\n}\nOrthographicCamera.prototype.isOrthographicCamera = true;\nclass DirectionalLightShadow extends LightShadow {\n  constructor() {\n    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));\n  }\n}\nDirectionalLightShadow.prototype.isDirectionalLightShadow = true;\nclass DirectionalLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.type = \"DirectionalLight\";\n    this.position.copy(Object3D.DefaultUp);\n    this.updateMatrix();\n    this.target = new Object3D();\n    this.shadow = new DirectionalLightShadow();\n  }\n  dispose() {\n    this.shadow.dispose();\n  }\n  copy(source) {\n    super.copy(source);\n    this.target = source.target.clone();\n    this.shadow = source.shadow.clone();\n    return this;\n  }\n}\nDirectionalLight.prototype.isDirectionalLight = true;\nclass AmbientLight extends Light {\n  constructor(color, intensity) {\n    super(color, intensity);\n    this.type = \"AmbientLight\";\n  }\n}\nAmbientLight.prototype.isAmbientLight = true;\nclass RectAreaLight extends Light {\n  constructor(color, intensity, width = 10, height = 10) {\n    super(color, intensity);\n    this.type = \"RectAreaLight\";\n    this.width = width;\n    this.height = height;\n  }\n  copy(source) {\n    super.copy(source);\n    this.width = source.width;\n    this.height = source.height;\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.width = this.width;\n    data.object.height = this.height;\n    return data;\n  }\n}\nRectAreaLight.prototype.isRectAreaLight = true;\nclass SphericalHarmonics3 {\n  constructor() {\n    this.coefficients = [];\n    for (let i = 0; i < 9; i++) {\n      this.coefficients.push(new Vector3());\n    }\n  }\n  set(coefficients) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].copy(coefficients[i]);\n    }\n    return this;\n  }\n  zero() {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].set(0, 0, 0);\n    }\n    return this;\n  }\n  getAt(normal, target) {\n    const x = normal.x, y = normal.y, z = normal.z;\n    const coeff = this.coefficients;\n    target.copy(coeff[0]).multiplyScalar(0.282095);\n    target.addScaledVector(coeff[1], 0.488603 * y);\n    target.addScaledVector(coeff[2], 0.488603 * z);\n    target.addScaledVector(coeff[3], 0.488603 * x);\n    target.addScaledVector(coeff[4], 1.092548 * (x * y));\n    target.addScaledVector(coeff[5], 1.092548 * (y * z));\n    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1));\n    target.addScaledVector(coeff[7], 1.092548 * (x * z));\n    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));\n    return target;\n  }\n  getIrradianceAt(normal, target) {\n    const x = normal.x, y = normal.y, z = normal.z;\n    const coeff = this.coefficients;\n    target.copy(coeff[0]).multiplyScalar(0.886227);\n    target.addScaledVector(coeff[1], 2 * 0.511664 * y);\n    target.addScaledVector(coeff[2], 2 * 0.511664 * z);\n    target.addScaledVector(coeff[3], 2 * 0.511664 * x);\n    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y);\n    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z);\n    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708);\n    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z);\n    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y));\n    return target;\n  }\n  add(sh) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].add(sh.coefficients[i]);\n    }\n    return this;\n  }\n  addScaledSH(sh, s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].addScaledVector(sh.coefficients[i], s);\n    }\n    return this;\n  }\n  scale(s) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].multiplyScalar(s);\n    }\n    return this;\n  }\n  lerp(sh, alpha) {\n    for (let i = 0; i < 9; i++) {\n      this.coefficients[i].lerp(sh.coefficients[i], alpha);\n    }\n    return this;\n  }\n  equals(sh) {\n    for (let i = 0; i < 9; i++) {\n      if (!this.coefficients[i].equals(sh.coefficients[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  copy(sh) {\n    return this.set(sh.coefficients);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  fromArray(array, offset = 0) {\n    const coefficients = this.coefficients;\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].fromArray(array, offset + i * 3);\n    }\n    return this;\n  }\n  toArray(array = [], offset = 0) {\n    const coefficients = this.coefficients;\n    for (let i = 0; i < 9; i++) {\n      coefficients[i].toArray(array, offset + i * 3);\n    }\n    return array;\n  }\n  static getBasisAt(normal, shBasis) {\n    const x = normal.x, y = normal.y, z = normal.z;\n    shBasis[0] = 0.282095;\n    shBasis[1] = 0.488603 * y;\n    shBasis[2] = 0.488603 * z;\n    shBasis[3] = 0.488603 * x;\n    shBasis[4] = 1.092548 * x * y;\n    shBasis[5] = 1.092548 * y * z;\n    shBasis[6] = 0.315392 * (3 * z * z - 1);\n    shBasis[7] = 1.092548 * x * z;\n    shBasis[8] = 0.546274 * (x * x - y * y);\n  }\n}\nSphericalHarmonics3.prototype.isSphericalHarmonics3 = true;\nclass LightProbe extends Light {\n  constructor(sh = new SphericalHarmonics3(), intensity = 1) {\n    super(void 0, intensity);\n    this.sh = sh;\n  }\n  copy(source) {\n    super.copy(source);\n    this.sh.copy(source.sh);\n    return this;\n  }\n  fromJSON(json) {\n    this.intensity = json.intensity;\n    this.sh.fromArray(json.sh);\n    return this;\n  }\n  toJSON(meta) {\n    const data = super.toJSON(meta);\n    data.object.sh = this.sh.toArray();\n    return data;\n  }\n}\nLightProbe.prototype.isLightProbe = true;\nclass MaterialLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    this.textures = {};\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function(text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(json) {\n    const textures = this.textures;\n    function getTexture(name) {\n      if (textures[name] === void 0) {\n        console.warn(\"THREE.MaterialLoader: Undefined texture\", name);\n      }\n      return textures[name];\n    }\n    const material = new Materials[json.type]();\n    if (json.uuid !== void 0)\n      material.uuid = json.uuid;\n    if (json.name !== void 0)\n      material.name = json.name;\n    if (json.color !== void 0 && material.color !== void 0)\n      material.color.setHex(json.color);\n    if (json.roughness !== void 0)\n      material.roughness = json.roughness;\n    if (json.metalness !== void 0)\n      material.metalness = json.metalness;\n    if (json.sheen !== void 0)\n      material.sheen = new Color().setHex(json.sheen);\n    if (json.emissive !== void 0 && material.emissive !== void 0)\n      material.emissive.setHex(json.emissive);\n    if (json.specular !== void 0 && material.specular !== void 0)\n      material.specular.setHex(json.specular);\n    if (json.shininess !== void 0)\n      material.shininess = json.shininess;\n    if (json.clearcoat !== void 0)\n      material.clearcoat = json.clearcoat;\n    if (json.clearcoatRoughness !== void 0)\n      material.clearcoatRoughness = json.clearcoatRoughness;\n    if (json.fog !== void 0)\n      material.fog = json.fog;\n    if (json.flatShading !== void 0)\n      material.flatShading = json.flatShading;\n    if (json.blending !== void 0)\n      material.blending = json.blending;\n    if (json.combine !== void 0)\n      material.combine = json.combine;\n    if (json.side !== void 0)\n      material.side = json.side;\n    if (json.shadowSide !== void 0)\n      material.shadowSide = json.shadowSide;\n    if (json.opacity !== void 0)\n      material.opacity = json.opacity;\n    if (json.transparent !== void 0)\n      material.transparent = json.transparent;\n    if (json.alphaTest !== void 0)\n      material.alphaTest = json.alphaTest;\n    if (json.depthTest !== void 0)\n      material.depthTest = json.depthTest;\n    if (json.depthWrite !== void 0)\n      material.depthWrite = json.depthWrite;\n    if (json.colorWrite !== void 0)\n      material.colorWrite = json.colorWrite;\n    if (json.stencilWrite !== void 0)\n      material.stencilWrite = json.stencilWrite;\n    if (json.stencilWriteMask !== void 0)\n      material.stencilWriteMask = json.stencilWriteMask;\n    if (json.stencilFunc !== void 0)\n      material.stencilFunc = json.stencilFunc;\n    if (json.stencilRef !== void 0)\n      material.stencilRef = json.stencilRef;\n    if (json.stencilFuncMask !== void 0)\n      material.stencilFuncMask = json.stencilFuncMask;\n    if (json.stencilFail !== void 0)\n      material.stencilFail = json.stencilFail;\n    if (json.stencilZFail !== void 0)\n      material.stencilZFail = json.stencilZFail;\n    if (json.stencilZPass !== void 0)\n      material.stencilZPass = json.stencilZPass;\n    if (json.wireframe !== void 0)\n      material.wireframe = json.wireframe;\n    if (json.wireframeLinewidth !== void 0)\n      material.wireframeLinewidth = json.wireframeLinewidth;\n    if (json.wireframeLinecap !== void 0)\n      material.wireframeLinecap = json.wireframeLinecap;\n    if (json.wireframeLinejoin !== void 0)\n      material.wireframeLinejoin = json.wireframeLinejoin;\n    if (json.rotation !== void 0)\n      material.rotation = json.rotation;\n    if (json.linewidth !== 1)\n      material.linewidth = json.linewidth;\n    if (json.dashSize !== void 0)\n      material.dashSize = json.dashSize;\n    if (json.gapSize !== void 0)\n      material.gapSize = json.gapSize;\n    if (json.scale !== void 0)\n      material.scale = json.scale;\n    if (json.polygonOffset !== void 0)\n      material.polygonOffset = json.polygonOffset;\n    if (json.polygonOffsetFactor !== void 0)\n      material.polygonOffsetFactor = json.polygonOffsetFactor;\n    if (json.polygonOffsetUnits !== void 0)\n      material.polygonOffsetUnits = json.polygonOffsetUnits;\n    if (json.skinning !== void 0)\n      material.skinning = json.skinning;\n    if (json.morphTargets !== void 0)\n      material.morphTargets = json.morphTargets;\n    if (json.morphNormals !== void 0)\n      material.morphNormals = json.morphNormals;\n    if (json.dithering !== void 0)\n      material.dithering = json.dithering;\n    if (json.alphaToCoverage !== void 0)\n      material.alphaToCoverage = json.alphaToCoverage;\n    if (json.premultipliedAlpha !== void 0)\n      material.premultipliedAlpha = json.premultipliedAlpha;\n    if (json.vertexTangents !== void 0)\n      material.vertexTangents = json.vertexTangents;\n    if (json.visible !== void 0)\n      material.visible = json.visible;\n    if (json.toneMapped !== void 0)\n      material.toneMapped = json.toneMapped;\n    if (json.userData !== void 0)\n      material.userData = json.userData;\n    if (json.vertexColors !== void 0) {\n      if (typeof json.vertexColors === \"number\") {\n        material.vertexColors = json.vertexColors > 0 ? true : false;\n      } else {\n        material.vertexColors = json.vertexColors;\n      }\n    }\n    if (json.uniforms !== void 0) {\n      for (const name in json.uniforms) {\n        const uniform = json.uniforms[name];\n        material.uniforms[name] = {};\n        switch (uniform.type) {\n          case \"t\":\n            material.uniforms[name].value = getTexture(uniform.value);\n            break;\n          case \"c\":\n            material.uniforms[name].value = new Color().setHex(uniform.value);\n            break;\n          case \"v2\":\n            material.uniforms[name].value = new Vector2().fromArray(uniform.value);\n            break;\n          case \"v3\":\n            material.uniforms[name].value = new Vector3().fromArray(uniform.value);\n            break;\n          case \"v4\":\n            material.uniforms[name].value = new Vector4().fromArray(uniform.value);\n            break;\n          case \"m3\":\n            material.uniforms[name].value = new Matrix3().fromArray(uniform.value);\n            break;\n          case \"m4\":\n            material.uniforms[name].value = new Matrix4().fromArray(uniform.value);\n            break;\n          default:\n            material.uniforms[name].value = uniform.value;\n        }\n      }\n    }\n    if (json.defines !== void 0)\n      material.defines = json.defines;\n    if (json.vertexShader !== void 0)\n      material.vertexShader = json.vertexShader;\n    if (json.fragmentShader !== void 0)\n      material.fragmentShader = json.fragmentShader;\n    if (json.extensions !== void 0) {\n      for (const key in json.extensions) {\n        material.extensions[key] = json.extensions[key];\n      }\n    }\n    if (json.shading !== void 0)\n      material.flatShading = json.shading === 1;\n    if (json.size !== void 0)\n      material.size = json.size;\n    if (json.sizeAttenuation !== void 0)\n      material.sizeAttenuation = json.sizeAttenuation;\n    if (json.map !== void 0)\n      material.map = getTexture(json.map);\n    if (json.matcap !== void 0)\n      material.matcap = getTexture(json.matcap);\n    if (json.alphaMap !== void 0)\n      material.alphaMap = getTexture(json.alphaMap);\n    if (json.bumpMap !== void 0)\n      material.bumpMap = getTexture(json.bumpMap);\n    if (json.bumpScale !== void 0)\n      material.bumpScale = json.bumpScale;\n    if (json.normalMap !== void 0)\n      material.normalMap = getTexture(json.normalMap);\n    if (json.normalMapType !== void 0)\n      material.normalMapType = json.normalMapType;\n    if (json.normalScale !== void 0) {\n      let normalScale = json.normalScale;\n      if (Array.isArray(normalScale) === false) {\n        normalScale = [normalScale, normalScale];\n      }\n      material.normalScale = new Vector2().fromArray(normalScale);\n    }\n    if (json.displacementMap !== void 0)\n      material.displacementMap = getTexture(json.displacementMap);\n    if (json.displacementScale !== void 0)\n      material.displacementScale = json.displacementScale;\n    if (json.displacementBias !== void 0)\n      material.displacementBias = json.displacementBias;\n    if (json.roughnessMap !== void 0)\n      material.roughnessMap = getTexture(json.roughnessMap);\n    if (json.metalnessMap !== void 0)\n      material.metalnessMap = getTexture(json.metalnessMap);\n    if (json.emissiveMap !== void 0)\n      material.emissiveMap = getTexture(json.emissiveMap);\n    if (json.emissiveIntensity !== void 0)\n      material.emissiveIntensity = json.emissiveIntensity;\n    if (json.specularMap !== void 0)\n      material.specularMap = getTexture(json.specularMap);\n    if (json.envMap !== void 0)\n      material.envMap = getTexture(json.envMap);\n    if (json.envMapIntensity !== void 0)\n      material.envMapIntensity = json.envMapIntensity;\n    if (json.reflectivity !== void 0)\n      material.reflectivity = json.reflectivity;\n    if (json.refractionRatio !== void 0)\n      material.refractionRatio = json.refractionRatio;\n    if (json.lightMap !== void 0)\n      material.lightMap = getTexture(json.lightMap);\n    if (json.lightMapIntensity !== void 0)\n      material.lightMapIntensity = json.lightMapIntensity;\n    if (json.aoMap !== void 0)\n      material.aoMap = getTexture(json.aoMap);\n    if (json.aoMapIntensity !== void 0)\n      material.aoMapIntensity = json.aoMapIntensity;\n    if (json.gradientMap !== void 0)\n      material.gradientMap = getTexture(json.gradientMap);\n    if (json.clearcoatMap !== void 0)\n      material.clearcoatMap = getTexture(json.clearcoatMap);\n    if (json.clearcoatRoughnessMap !== void 0)\n      material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);\n    if (json.clearcoatNormalMap !== void 0)\n      material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);\n    if (json.clearcoatNormalScale !== void 0)\n      material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);\n    if (json.transmission !== void 0)\n      material.transmission = json.transmission;\n    if (json.transmissionMap !== void 0)\n      material.transmissionMap = getTexture(json.transmissionMap);\n    return material;\n  }\n  setTextures(value) {\n    this.textures = value;\n    return this;\n  }\n}\nclass LoaderUtils {\n  static decodeText(array) {\n    if (typeof TextDecoder !== \"undefined\") {\n      return new TextDecoder().decode(array);\n    }\n    let s = \"\";\n    for (let i = 0, il = array.length; i < il; i++) {\n      s += String.fromCharCode(array[i]);\n    }\n    try {\n      return decodeURIComponent(escape(s));\n    } catch (e) {\n      return s;\n    }\n  }\n  static extractUrlBase(url) {\n    const index = url.lastIndexOf(\"/\");\n    if (index === -1)\n      return \"./\";\n    return url.substr(0, index + 1);\n  }\n}\nclass InstancedBufferGeometry extends BufferGeometry {\n  constructor() {\n    super();\n    this.type = \"InstancedBufferGeometry\";\n    this.instanceCount = Infinity;\n  }\n  copy(source) {\n    super.copy(source);\n    this.instanceCount = source.instanceCount;\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  toJSON() {\n    const data = super.toJSON(this);\n    data.instanceCount = this.instanceCount;\n    data.isInstancedBufferGeometry = true;\n    return data;\n  }\n}\nInstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;\nclass InstancedBufferAttribute extends BufferAttribute {\n  constructor(array, itemSize, normalized, meshPerAttribute) {\n    if (typeof normalized === \"number\") {\n      meshPerAttribute = normalized;\n      normalized = false;\n      console.error(\"THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.\");\n    }\n    super(array, itemSize, normalized);\n    this.meshPerAttribute = meshPerAttribute || 1;\n  }\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n  toJSON() {\n    const data = super.toJSON();\n    data.meshPerAttribute = this.meshPerAttribute;\n    data.isInstancedBufferAttribute = true;\n    return data;\n  }\n}\nInstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;\nclass BufferGeometryLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(scope.manager);\n    loader.setPath(scope.path);\n    loader.setRequestHeader(scope.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function(text) {\n      try {\n        onLoad(scope.parse(JSON.parse(text)));\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n  parse(json) {\n    const interleavedBufferMap = {};\n    const arrayBufferMap = {};\n    function getInterleavedBuffer(json2, uuid) {\n      if (interleavedBufferMap[uuid] !== void 0)\n        return interleavedBufferMap[uuid];\n      const interleavedBuffers = json2.interleavedBuffers;\n      const interleavedBuffer = interleavedBuffers[uuid];\n      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer);\n      const array = getTypedArray(interleavedBuffer.type, buffer);\n      const ib = new InterleavedBuffer(array, interleavedBuffer.stride);\n      ib.uuid = interleavedBuffer.uuid;\n      interleavedBufferMap[uuid] = ib;\n      return ib;\n    }\n    function getArrayBuffer(json2, uuid) {\n      if (arrayBufferMap[uuid] !== void 0)\n        return arrayBufferMap[uuid];\n      const arrayBuffers = json2.arrayBuffers;\n      const arrayBuffer = arrayBuffers[uuid];\n      const ab = new Uint32Array(arrayBuffer).buffer;\n      arrayBufferMap[uuid] = ab;\n      return ab;\n    }\n    const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();\n    const index = json.data.index;\n    if (index !== void 0) {\n      const typedArray = getTypedArray(index.type, index.array);\n      geometry.setIndex(new BufferAttribute(typedArray, 1));\n    }\n    const attributes = json.data.attributes;\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      let bufferAttribute;\n      if (attribute.isInterleavedBufferAttribute) {\n        const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n        bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n      } else {\n        const typedArray = getTypedArray(attribute.type, attribute.array);\n        const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;\n        bufferAttribute = new bufferAttributeConstr(typedArray, attribute.itemSize, attribute.normalized);\n      }\n      if (attribute.name !== void 0)\n        bufferAttribute.name = attribute.name;\n      if (attribute.usage !== void 0)\n        bufferAttribute.setUsage(attribute.usage);\n      if (attribute.updateRange !== void 0) {\n        bufferAttribute.updateRange.offset = attribute.updateRange.offset;\n        bufferAttribute.updateRange.count = attribute.updateRange.count;\n      }\n      geometry.setAttribute(key, bufferAttribute);\n    }\n    const morphAttributes = json.data.morphAttributes;\n    if (morphAttributes) {\n      for (const key in morphAttributes) {\n        const attributeArray = morphAttributes[key];\n        const array = [];\n        for (let i = 0, il = attributeArray.length; i < il; i++) {\n          const attribute = attributeArray[i];\n          let bufferAttribute;\n          if (attribute.isInterleavedBufferAttribute) {\n            const interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);\n            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);\n          } else {\n            const typedArray = getTypedArray(attribute.type, attribute.array);\n            bufferAttribute = new BufferAttribute(typedArray, attribute.itemSize, attribute.normalized);\n          }\n          if (attribute.name !== void 0)\n            bufferAttribute.name = attribute.name;\n          array.push(bufferAttribute);\n        }\n        geometry.morphAttributes[key] = array;\n      }\n    }\n    const morphTargetsRelative = json.data.morphTargetsRelative;\n    if (morphTargetsRelative) {\n      geometry.morphTargetsRelative = true;\n    }\n    const groups = json.data.groups || json.data.drawcalls || json.data.offsets;\n    if (groups !== void 0) {\n      for (let i = 0, n = groups.length; i !== n; ++i) {\n        const group = groups[i];\n        geometry.addGroup(group.start, group.count, group.materialIndex);\n      }\n    }\n    const boundingSphere = json.data.boundingSphere;\n    if (boundingSphere !== void 0) {\n      const center = new Vector3();\n      if (boundingSphere.center !== void 0) {\n        center.fromArray(boundingSphere.center);\n      }\n      geometry.boundingSphere = new Sphere(center, boundingSphere.radius);\n    }\n    if (json.name)\n      geometry.name = json.name;\n    if (json.userData)\n      geometry.userData = json.userData;\n    return geometry;\n  }\n}\nclass ObjectLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const path = this.path === \"\" ? LoaderUtils.extractUrlBase(url) : this.path;\n    this.resourcePath = this.resourcePath || path;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function(text) {\n      let json = null;\n      try {\n        json = JSON.parse(text);\n      } catch (error) {\n        if (onError !== void 0)\n          onError(error);\n        console.error(\"THREE:ObjectLoader: Can't parse \" + url + \".\", error.message);\n        return;\n      }\n      const metadata = json.metadata;\n      if (metadata === void 0 || metadata.type === void 0 || metadata.type.toLowerCase() === \"geometry\") {\n        console.error(\"THREE.ObjectLoader: Can't load \" + url);\n        return;\n      }\n      scope.parse(json, onLoad);\n    }, onProgress, onError);\n  }\n  parse(json, onLoad) {\n    const animations = this.parseAnimations(json.animations);\n    const shapes = this.parseShapes(json.shapes);\n    const geometries = this.parseGeometries(json.geometries, shapes);\n    const images = this.parseImages(json.images, function() {\n      if (onLoad !== void 0)\n        onLoad(object);\n    });\n    const textures = this.parseTextures(json.textures, images);\n    const materials = this.parseMaterials(json.materials, textures);\n    const object = this.parseObject(json.object, geometries, materials, animations);\n    const skeletons = this.parseSkeletons(json.skeletons, object);\n    this.bindSkeletons(object, skeletons);\n    if (onLoad !== void 0) {\n      let hasImages = false;\n      for (const uuid in images) {\n        if (images[uuid] instanceof HTMLImageElement) {\n          hasImages = true;\n          break;\n        }\n      }\n      if (hasImages === false)\n        onLoad(object);\n    }\n    return object;\n  }\n  parseShapes(json) {\n    const shapes = {};\n    if (json !== void 0) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const shape = new Shape().fromJSON(json[i]);\n        shapes[shape.uuid] = shape;\n      }\n    }\n    return shapes;\n  }\n  parseSkeletons(json, object) {\n    const skeletons = {};\n    const bones = {};\n    object.traverse(function(child) {\n      if (child.isBone)\n        bones[child.uuid] = child;\n    });\n    if (json !== void 0) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const skeleton = new Skeleton().fromJSON(json[i], bones);\n        skeletons[skeleton.uuid] = skeleton;\n      }\n    }\n    return skeletons;\n  }\n  parseGeometries(json, shapes) {\n    const geometries = {};\n    let geometryShapes;\n    if (json !== void 0) {\n      const bufferGeometryLoader = new BufferGeometryLoader();\n      for (let i = 0, l = json.length; i < l; i++) {\n        let geometry;\n        const data = json[i];\n        switch (data.type) {\n          case \"PlaneGeometry\":\n          case \"PlaneBufferGeometry\":\n            geometry = new Geometries[data.type](data.width, data.height, data.widthSegments, data.heightSegments);\n            break;\n          case \"BoxGeometry\":\n          case \"BoxBufferGeometry\":\n            geometry = new Geometries[data.type](data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);\n            break;\n          case \"CircleGeometry\":\n          case \"CircleBufferGeometry\":\n            geometry = new Geometries[data.type](data.radius, data.segments, data.thetaStart, data.thetaLength);\n            break;\n          case \"CylinderGeometry\":\n          case \"CylinderBufferGeometry\":\n            geometry = new Geometries[data.type](data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n            break;\n          case \"ConeGeometry\":\n          case \"ConeBufferGeometry\":\n            geometry = new Geometries[data.type](data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);\n            break;\n          case \"SphereGeometry\":\n          case \"SphereBufferGeometry\":\n            geometry = new Geometries[data.type](data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);\n            break;\n          case \"DodecahedronGeometry\":\n          case \"DodecahedronBufferGeometry\":\n          case \"IcosahedronGeometry\":\n          case \"IcosahedronBufferGeometry\":\n          case \"OctahedronGeometry\":\n          case \"OctahedronBufferGeometry\":\n          case \"TetrahedronGeometry\":\n          case \"TetrahedronBufferGeometry\":\n            geometry = new Geometries[data.type](data.radius, data.detail);\n            break;\n          case \"RingGeometry\":\n          case \"RingBufferGeometry\":\n            geometry = new Geometries[data.type](data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);\n            break;\n          case \"TorusGeometry\":\n          case \"TorusBufferGeometry\":\n            geometry = new Geometries[data.type](data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);\n            break;\n          case \"TorusKnotGeometry\":\n          case \"TorusKnotBufferGeometry\":\n            geometry = new Geometries[data.type](data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);\n            break;\n          case \"TubeGeometry\":\n          case \"TubeBufferGeometry\":\n            geometry = new Geometries[data.type](new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);\n            break;\n          case \"LatheGeometry\":\n          case \"LatheBufferGeometry\":\n            geometry = new Geometries[data.type](data.points, data.segments, data.phiStart, data.phiLength);\n            break;\n          case \"PolyhedronGeometry\":\n          case \"PolyhedronBufferGeometry\":\n            geometry = new Geometries[data.type](data.vertices, data.indices, data.radius, data.details);\n            break;\n          case \"ShapeGeometry\":\n          case \"ShapeBufferGeometry\":\n            geometryShapes = [];\n            for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n              const shape = shapes[data.shapes[j]];\n              geometryShapes.push(shape);\n            }\n            geometry = new Geometries[data.type](geometryShapes, data.curveSegments);\n            break;\n          case \"ExtrudeGeometry\":\n          case \"ExtrudeBufferGeometry\":\n            geometryShapes = [];\n            for (let j = 0, jl = data.shapes.length; j < jl; j++) {\n              const shape = shapes[data.shapes[j]];\n              geometryShapes.push(shape);\n            }\n            const extrudePath = data.options.extrudePath;\n            if (extrudePath !== void 0) {\n              data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);\n            }\n            geometry = new Geometries[data.type](geometryShapes, data.options);\n            break;\n          case \"BufferGeometry\":\n          case \"InstancedBufferGeometry\":\n            geometry = bufferGeometryLoader.parse(data);\n            break;\n          case \"Geometry\":\n            console.error('THREE.ObjectLoader: Loading \"Geometry\" is not supported anymore.');\n            break;\n          default:\n            console.warn('THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"');\n            continue;\n        }\n        geometry.uuid = data.uuid;\n        if (data.name !== void 0)\n          geometry.name = data.name;\n        if (geometry.isBufferGeometry === true && data.userData !== void 0)\n          geometry.userData = data.userData;\n        geometries[data.uuid] = geometry;\n      }\n    }\n    return geometries;\n  }\n  parseMaterials(json, textures) {\n    const cache = {};\n    const materials = {};\n    if (json !== void 0) {\n      const loader = new MaterialLoader();\n      loader.setTextures(textures);\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        if (data.type === \"MultiMaterial\") {\n          const array = [];\n          for (let j = 0; j < data.materials.length; j++) {\n            const material = data.materials[j];\n            if (cache[material.uuid] === void 0) {\n              cache[material.uuid] = loader.parse(material);\n            }\n            array.push(cache[material.uuid]);\n          }\n          materials[data.uuid] = array;\n        } else {\n          if (cache[data.uuid] === void 0) {\n            cache[data.uuid] = loader.parse(data);\n          }\n          materials[data.uuid] = cache[data.uuid];\n        }\n      }\n    }\n    return materials;\n  }\n  parseAnimations(json) {\n    const animations = {};\n    if (json !== void 0) {\n      for (let i = 0; i < json.length; i++) {\n        const data = json[i];\n        const clip = AnimationClip.parse(data);\n        animations[clip.uuid] = clip;\n      }\n    }\n    return animations;\n  }\n  parseImages(json, onLoad) {\n    const scope = this;\n    const images = {};\n    let loader;\n    function loadImage(url) {\n      scope.manager.itemStart(url);\n      return loader.load(url, function() {\n        scope.manager.itemEnd(url);\n      }, void 0, function() {\n        scope.manager.itemError(url);\n        scope.manager.itemEnd(url);\n      });\n    }\n    function deserializeImage(image) {\n      if (typeof image === \"string\") {\n        const url = image;\n        const path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test(url) ? url : scope.resourcePath + url;\n        return loadImage(path);\n      } else {\n        if (image.data) {\n          return {\n            data: getTypedArray(image.type, image.data),\n            width: image.width,\n            height: image.height\n          };\n        } else {\n          return null;\n        }\n      }\n    }\n    if (json !== void 0 && json.length > 0) {\n      const manager = new LoadingManager(onLoad);\n      loader = new ImageLoader(manager);\n      loader.setCrossOrigin(this.crossOrigin);\n      for (let i = 0, il = json.length; i < il; i++) {\n        const image = json[i];\n        const url = image.url;\n        if (Array.isArray(url)) {\n          images[image.uuid] = [];\n          for (let j = 0, jl = url.length; j < jl; j++) {\n            const currentUrl = url[j];\n            const deserializedImage = deserializeImage(currentUrl);\n            if (deserializedImage !== null) {\n              if (deserializedImage instanceof HTMLImageElement) {\n                images[image.uuid].push(deserializedImage);\n              } else {\n                images[image.uuid].push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));\n              }\n            }\n          }\n        } else {\n          const deserializedImage = deserializeImage(image.url);\n          if (deserializedImage !== null) {\n            images[image.uuid] = deserializedImage;\n          }\n        }\n      }\n    }\n    return images;\n  }\n  parseTextures(json, images) {\n    function parseConstant(value, type) {\n      if (typeof value === \"number\")\n        return value;\n      console.warn(\"THREE.ObjectLoader.parseTexture: Constant should be in numeric form.\", value);\n      return type[value];\n    }\n    const textures = {};\n    if (json !== void 0) {\n      for (let i = 0, l = json.length; i < l; i++) {\n        const data = json[i];\n        if (data.image === void 0) {\n          console.warn('THREE.ObjectLoader: No \"image\" specified for', data.uuid);\n        }\n        if (images[data.image] === void 0) {\n          console.warn(\"THREE.ObjectLoader: Undefined image\", data.image);\n        }\n        let texture;\n        const image = images[data.image];\n        if (Array.isArray(image)) {\n          texture = new CubeTexture(image);\n          if (image.length === 6)\n            texture.needsUpdate = true;\n        } else {\n          if (image && image.data) {\n            texture = new DataTexture(image.data, image.width, image.height);\n          } else {\n            texture = new Texture(image);\n          }\n          if (image)\n            texture.needsUpdate = true;\n        }\n        texture.uuid = data.uuid;\n        if (data.name !== void 0)\n          texture.name = data.name;\n        if (data.mapping !== void 0)\n          texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);\n        if (data.offset !== void 0)\n          texture.offset.fromArray(data.offset);\n        if (data.repeat !== void 0)\n          texture.repeat.fromArray(data.repeat);\n        if (data.center !== void 0)\n          texture.center.fromArray(data.center);\n        if (data.rotation !== void 0)\n          texture.rotation = data.rotation;\n        if (data.wrap !== void 0) {\n          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);\n          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);\n        }\n        if (data.format !== void 0)\n          texture.format = data.format;\n        if (data.type !== void 0)\n          texture.type = data.type;\n        if (data.encoding !== void 0)\n          texture.encoding = data.encoding;\n        if (data.minFilter !== void 0)\n          texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);\n        if (data.magFilter !== void 0)\n          texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);\n        if (data.anisotropy !== void 0)\n          texture.anisotropy = data.anisotropy;\n        if (data.flipY !== void 0)\n          texture.flipY = data.flipY;\n        if (data.premultiplyAlpha !== void 0)\n          texture.premultiplyAlpha = data.premultiplyAlpha;\n        if (data.unpackAlignment !== void 0)\n          texture.unpackAlignment = data.unpackAlignment;\n        textures[data.uuid] = texture;\n      }\n    }\n    return textures;\n  }\n  parseObject(data, geometries, materials, animations) {\n    let object;\n    function getGeometry(name) {\n      if (geometries[name] === void 0) {\n        console.warn(\"THREE.ObjectLoader: Undefined geometry\", name);\n      }\n      return geometries[name];\n    }\n    function getMaterial(name) {\n      if (name === void 0)\n        return void 0;\n      if (Array.isArray(name)) {\n        const array = [];\n        for (let i = 0, l = name.length; i < l; i++) {\n          const uuid = name[i];\n          if (materials[uuid] === void 0) {\n            console.warn(\"THREE.ObjectLoader: Undefined material\", uuid);\n          }\n          array.push(materials[uuid]);\n        }\n        return array;\n      }\n      if (materials[name] === void 0) {\n        console.warn(\"THREE.ObjectLoader: Undefined material\", name);\n      }\n      return materials[name];\n    }\n    let geometry, material;\n    switch (data.type) {\n      case \"Scene\":\n        object = new Scene();\n        if (data.background !== void 0) {\n          if (Number.isInteger(data.background)) {\n            object.background = new Color(data.background);\n          }\n        }\n        if (data.fog !== void 0) {\n          if (data.fog.type === \"Fog\") {\n            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);\n          } else if (data.fog.type === \"FogExp2\") {\n            object.fog = new FogExp2(data.fog.color, data.fog.density);\n          }\n        }\n        break;\n      case \"PerspectiveCamera\":\n        object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);\n        if (data.focus !== void 0)\n          object.focus = data.focus;\n        if (data.zoom !== void 0)\n          object.zoom = data.zoom;\n        if (data.filmGauge !== void 0)\n          object.filmGauge = data.filmGauge;\n        if (data.filmOffset !== void 0)\n          object.filmOffset = data.filmOffset;\n        if (data.view !== void 0)\n          object.view = Object.assign({}, data.view);\n        break;\n      case \"OrthographicCamera\":\n        object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);\n        if (data.zoom !== void 0)\n          object.zoom = data.zoom;\n        if (data.view !== void 0)\n          object.view = Object.assign({}, data.view);\n        break;\n      case \"AmbientLight\":\n        object = new AmbientLight(data.color, data.intensity);\n        break;\n      case \"DirectionalLight\":\n        object = new DirectionalLight(data.color, data.intensity);\n        break;\n      case \"PointLight\":\n        object = new PointLight(data.color, data.intensity, data.distance, data.decay);\n        break;\n      case \"RectAreaLight\":\n        object = new RectAreaLight(data.color, data.intensity, data.width, data.height);\n        break;\n      case \"SpotLight\":\n        object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);\n        break;\n      case \"HemisphereLight\":\n        object = new HemisphereLight(data.color, data.groundColor, data.intensity);\n        break;\n      case \"LightProbe\":\n        object = new LightProbe().fromJSON(data);\n        break;\n      case \"SkinnedMesh\":\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new SkinnedMesh(geometry, material);\n        if (data.bindMode !== void 0)\n          object.bindMode = data.bindMode;\n        if (data.bindMatrix !== void 0)\n          object.bindMatrix.fromArray(data.bindMatrix);\n        if (data.skeleton !== void 0)\n          object.skeleton = data.skeleton;\n        break;\n      case \"Mesh\":\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        object = new Mesh(geometry, material);\n        break;\n      case \"InstancedMesh\":\n        geometry = getGeometry(data.geometry);\n        material = getMaterial(data.material);\n        const count = data.count;\n        const instanceMatrix = data.instanceMatrix;\n        const instanceColor = data.instanceColor;\n        object = new InstancedMesh(geometry, material, count);\n        object.instanceMatrix = new BufferAttribute(new Float32Array(instanceMatrix.array), 16);\n        if (instanceColor !== void 0)\n          object.instanceColor = new BufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);\n        break;\n      case \"LOD\":\n        object = new LOD();\n        break;\n      case \"Line\":\n        object = new Line(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case \"LineLoop\":\n        object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case \"LineSegments\":\n        object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case \"PointCloud\":\n      case \"Points\":\n        object = new Points(getGeometry(data.geometry), getMaterial(data.material));\n        break;\n      case \"Sprite\":\n        object = new Sprite(getMaterial(data.material));\n        break;\n      case \"Group\":\n        object = new Group();\n        break;\n      case \"Bone\":\n        object = new Bone();\n        break;\n      default:\n        object = new Object3D();\n    }\n    object.uuid = data.uuid;\n    if (data.name !== void 0)\n      object.name = data.name;\n    if (data.matrix !== void 0) {\n      object.matrix.fromArray(data.matrix);\n      if (data.matrixAutoUpdate !== void 0)\n        object.matrixAutoUpdate = data.matrixAutoUpdate;\n      if (object.matrixAutoUpdate)\n        object.matrix.decompose(object.position, object.quaternion, object.scale);\n    } else {\n      if (data.position !== void 0)\n        object.position.fromArray(data.position);\n      if (data.rotation !== void 0)\n        object.rotation.fromArray(data.rotation);\n      if (data.quaternion !== void 0)\n        object.quaternion.fromArray(data.quaternion);\n      if (data.scale !== void 0)\n        object.scale.fromArray(data.scale);\n    }\n    if (data.castShadow !== void 0)\n      object.castShadow = data.castShadow;\n    if (data.receiveShadow !== void 0)\n      object.receiveShadow = data.receiveShadow;\n    if (data.shadow) {\n      if (data.shadow.bias !== void 0)\n        object.shadow.bias = data.shadow.bias;\n      if (data.shadow.normalBias !== void 0)\n        object.shadow.normalBias = data.shadow.normalBias;\n      if (data.shadow.radius !== void 0)\n        object.shadow.radius = data.shadow.radius;\n      if (data.shadow.mapSize !== void 0)\n        object.shadow.mapSize.fromArray(data.shadow.mapSize);\n      if (data.shadow.camera !== void 0)\n        object.shadow.camera = this.parseObject(data.shadow.camera);\n    }\n    if (data.visible !== void 0)\n      object.visible = data.visible;\n    if (data.frustumCulled !== void 0)\n      object.frustumCulled = data.frustumCulled;\n    if (data.renderOrder !== void 0)\n      object.renderOrder = data.renderOrder;\n    if (data.userData !== void 0)\n      object.userData = data.userData;\n    if (data.layers !== void 0)\n      object.layers.mask = data.layers;\n    if (data.children !== void 0) {\n      const children = data.children;\n      for (let i = 0; i < children.length; i++) {\n        object.add(this.parseObject(children[i], geometries, materials, animations));\n      }\n    }\n    if (data.animations !== void 0) {\n      const objectAnimations = data.animations;\n      for (let i = 0; i < objectAnimations.length; i++) {\n        const uuid = objectAnimations[i];\n        object.animations.push(animations[uuid]);\n      }\n    }\n    if (data.type === \"LOD\") {\n      if (data.autoUpdate !== void 0)\n        object.autoUpdate = data.autoUpdate;\n      const levels = data.levels;\n      for (let l = 0; l < levels.length; l++) {\n        const level = levels[l];\n        const child = object.getObjectByProperty(\"uuid\", level.object);\n        if (child !== void 0) {\n          object.addLevel(child, level.distance);\n        }\n      }\n    }\n    return object;\n  }\n  bindSkeletons(object, skeletons) {\n    if (Object.keys(skeletons).length === 0)\n      return;\n    object.traverse(function(child) {\n      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {\n        const skeleton = skeletons[child.skeleton];\n        if (skeleton === void 0) {\n          console.warn(\"THREE.ObjectLoader: No skeleton found with UUID:\", child.skeleton);\n        } else {\n          child.bind(skeleton, child.bindMatrix);\n        }\n      }\n    });\n  }\n  setTexturePath(value) {\n    console.warn(\"THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().\");\n    return this.setResourcePath(value);\n  }\n}\nconst TEXTURE_MAPPING = {\n  UVMapping,\n  CubeReflectionMapping,\n  CubeRefractionMapping,\n  EquirectangularReflectionMapping,\n  EquirectangularRefractionMapping,\n  CubeUVReflectionMapping,\n  CubeUVRefractionMapping\n};\nconst TEXTURE_WRAPPING = {\n  RepeatWrapping,\n  ClampToEdgeWrapping,\n  MirroredRepeatWrapping\n};\nconst TEXTURE_FILTER = {\n  NearestFilter,\n  NearestMipmapNearestFilter,\n  NearestMipmapLinearFilter,\n  LinearFilter,\n  LinearMipmapNearestFilter,\n  LinearMipmapLinearFilter\n};\nclass ImageBitmapLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n    if (typeof createImageBitmap === \"undefined\") {\n      console.warn(\"THREE.ImageBitmapLoader: createImageBitmap() not supported.\");\n    }\n    if (typeof fetch === \"undefined\") {\n      console.warn(\"THREE.ImageBitmapLoader: fetch() not supported.\");\n    }\n    this.options = {premultiplyAlpha: \"none\"};\n  }\n  setOptions(options) {\n    this.options = options;\n    return this;\n  }\n  load(url, onLoad, onProgress, onError) {\n    if (url === void 0)\n      url = \"\";\n    if (this.path !== void 0)\n      url = this.path + url;\n    url = this.manager.resolveURL(url);\n    const scope = this;\n    const cached = Cache.get(url);\n    if (cached !== void 0) {\n      scope.manager.itemStart(url);\n      setTimeout(function() {\n        if (onLoad)\n          onLoad(cached);\n        scope.manager.itemEnd(url);\n      }, 0);\n      return cached;\n    }\n    const fetchOptions = {};\n    fetchOptions.credentials = this.crossOrigin === \"anonymous\" ? \"same-origin\" : \"include\";\n    fetchOptions.headers = this.requestHeader;\n    fetch(url, fetchOptions).then(function(res) {\n      return res.blob();\n    }).then(function(blob) {\n      return createImageBitmap(blob, Object.assign(scope.options, {colorSpaceConversion: \"none\"}));\n    }).then(function(imageBitmap) {\n      Cache.add(url, imageBitmap);\n      if (onLoad)\n        onLoad(imageBitmap);\n      scope.manager.itemEnd(url);\n    }).catch(function(e) {\n      if (onError)\n        onError(e);\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    });\n    scope.manager.itemStart(url);\n  }\n}\nImageBitmapLoader.prototype.isImageBitmapLoader = true;\nclass ShapePath {\n  constructor() {\n    this.type = \"ShapePath\";\n    this.color = new Color();\n    this.subPaths = [];\n    this.currentPath = null;\n  }\n  moveTo(x, y) {\n    this.currentPath = new Path();\n    this.subPaths.push(this.currentPath);\n    this.currentPath.moveTo(x, y);\n    return this;\n  }\n  lineTo(x, y) {\n    this.currentPath.lineTo(x, y);\n    return this;\n  }\n  quadraticCurveTo(aCPx, aCPy, aX, aY) {\n    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);\n    return this;\n  }\n  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {\n    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);\n    return this;\n  }\n  splineThru(pts) {\n    this.currentPath.splineThru(pts);\n    return this;\n  }\n  toShapes(isCCW, noHoles) {\n    function toShapesNoHoles(inSubpaths) {\n      const shapes2 = [];\n      for (let i = 0, l = inSubpaths.length; i < l; i++) {\n        const tmpPath2 = inSubpaths[i];\n        const tmpShape2 = new Shape();\n        tmpShape2.curves = tmpPath2.curves;\n        shapes2.push(tmpShape2);\n      }\n      return shapes2;\n    }\n    function isPointInsidePolygon(inPt, inPolygon) {\n      const polyLen = inPolygon.length;\n      let inside = false;\n      for (let p = polyLen - 1, q = 0; q < polyLen; p = q++) {\n        let edgeLowPt = inPolygon[p];\n        let edgeHighPt = inPolygon[q];\n        let edgeDx = edgeHighPt.x - edgeLowPt.x;\n        let edgeDy = edgeHighPt.y - edgeLowPt.y;\n        if (Math.abs(edgeDy) > Number.EPSILON) {\n          if (edgeDy < 0) {\n            edgeLowPt = inPolygon[q];\n            edgeDx = -edgeDx;\n            edgeHighPt = inPolygon[p];\n            edgeDy = -edgeDy;\n          }\n          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y)\n            continue;\n          if (inPt.y === edgeLowPt.y) {\n            if (inPt.x === edgeLowPt.x)\n              return true;\n          } else {\n            const perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);\n            if (perpEdge === 0)\n              return true;\n            if (perpEdge < 0)\n              continue;\n            inside = !inside;\n          }\n        } else {\n          if (inPt.y !== edgeLowPt.y)\n            continue;\n          if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)\n            return true;\n        }\n      }\n      return inside;\n    }\n    const isClockWise = ShapeUtils.isClockWise;\n    const subPaths = this.subPaths;\n    if (subPaths.length === 0)\n      return [];\n    if (noHoles === true)\n      return toShapesNoHoles(subPaths);\n    let solid, tmpPath, tmpShape;\n    const shapes = [];\n    if (subPaths.length === 1) {\n      tmpPath = subPaths[0];\n      tmpShape = new Shape();\n      tmpShape.curves = tmpPath.curves;\n      shapes.push(tmpShape);\n      return shapes;\n    }\n    let holesFirst = !isClockWise(subPaths[0].getPoints());\n    holesFirst = isCCW ? !holesFirst : holesFirst;\n    const betterShapeHoles = [];\n    const newShapes = [];\n    let newShapeHoles = [];\n    let mainIdx = 0;\n    let tmpPoints;\n    newShapes[mainIdx] = void 0;\n    newShapeHoles[mainIdx] = [];\n    for (let i = 0, l = subPaths.length; i < l; i++) {\n      tmpPath = subPaths[i];\n      tmpPoints = tmpPath.getPoints();\n      solid = isClockWise(tmpPoints);\n      solid = isCCW ? !solid : solid;\n      if (solid) {\n        if (!holesFirst && newShapes[mainIdx])\n          mainIdx++;\n        newShapes[mainIdx] = {s: new Shape(), p: tmpPoints};\n        newShapes[mainIdx].s.curves = tmpPath.curves;\n        if (holesFirst)\n          mainIdx++;\n        newShapeHoles[mainIdx] = [];\n      } else {\n        newShapeHoles[mainIdx].push({h: tmpPath, p: tmpPoints[0]});\n      }\n    }\n    if (!newShapes[0])\n      return toShapesNoHoles(subPaths);\n    if (newShapes.length > 1) {\n      let ambiguous = false;\n      const toChange = [];\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        betterShapeHoles[sIdx] = [];\n      }\n      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {\n        const sho = newShapeHoles[sIdx];\n        for (let hIdx = 0; hIdx < sho.length; hIdx++) {\n          const ho = sho[hIdx];\n          let hole_unassigned = true;\n          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {\n            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {\n              if (sIdx !== s2Idx)\n                toChange.push({froms: sIdx, tos: s2Idx, hole: hIdx});\n              if (hole_unassigned) {\n                hole_unassigned = false;\n                betterShapeHoles[s2Idx].push(ho);\n              } else {\n                ambiguous = true;\n              }\n            }\n          }\n          if (hole_unassigned) {\n            betterShapeHoles[sIdx].push(ho);\n          }\n        }\n      }\n      if (toChange.length > 0) {\n        if (!ambiguous)\n          newShapeHoles = betterShapeHoles;\n      }\n    }\n    let tmpHoles;\n    for (let i = 0, il = newShapes.length; i < il; i++) {\n      tmpShape = newShapes[i].s;\n      shapes.push(tmpShape);\n      tmpHoles = newShapeHoles[i];\n      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {\n        tmpShape.holes.push(tmpHoles[j].h);\n      }\n    }\n    return shapes;\n  }\n}\nclass Font {\n  constructor(data) {\n    this.type = \"Font\";\n    this.data = data;\n  }\n  generateShapes(text, size = 100) {\n    const shapes = [];\n    const paths = createPaths(text, size, this.data);\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes());\n    }\n    return shapes;\n  }\n}\nfunction createPaths(text, size, data) {\n  const chars = Array.from(text);\n  const scale = size / data.resolution;\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale;\n  const paths = [];\n  let offsetX = 0, offsetY = 0;\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i];\n    if (char === \"\\n\") {\n      offsetX = 0;\n      offsetY -= line_height;\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data);\n      offsetX += ret.offsetX;\n      paths.push(ret.path);\n    }\n  }\n  return paths;\n}\nfunction createPath(char, scale, offsetX, offsetY, data) {\n  const glyph = data.glyphs[char] || data.glyphs[\"?\"];\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + \".\");\n    return;\n  }\n  const path = new ShapePath();\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(\" \"));\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++];\n      switch (action) {\n        case \"m\":\n          x = outline[i++] * scale + offsetX;\n          y = outline[i++] * scale + offsetY;\n          path.moveTo(x, y);\n          break;\n        case \"l\":\n          x = outline[i++] * scale + offsetX;\n          y = outline[i++] * scale + offsetY;\n          path.lineTo(x, y);\n          break;\n        case \"q\":\n          cpx = outline[i++] * scale + offsetX;\n          cpy = outline[i++] * scale + offsetY;\n          cpx1 = outline[i++] * scale + offsetX;\n          cpy1 = outline[i++] * scale + offsetY;\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy);\n          break;\n        case \"b\":\n          cpx = outline[i++] * scale + offsetX;\n          cpy = outline[i++] * scale + offsetY;\n          cpx1 = outline[i++] * scale + offsetX;\n          cpy1 = outline[i++] * scale + offsetY;\n          cpx2 = outline[i++] * scale + offsetX;\n          cpy2 = outline[i++] * scale + offsetY;\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy);\n          break;\n      }\n    }\n  }\n  return {offsetX: glyph.ha * scale, path};\n}\nFont.prototype.isFont = true;\nclass FontLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(scope.withCredentials);\n    loader.load(url, function(text) {\n      let json;\n      try {\n        json = JSON.parse(text);\n      } catch (e) {\n        console.warn(\"THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.\");\n        json = JSON.parse(text.substring(65, text.length - 2));\n      }\n      const font = scope.parse(json);\n      if (onLoad)\n        onLoad(font);\n    }, onProgress, onError);\n  }\n  parse(json) {\n    return new Font(json);\n  }\n}\nlet _context;\nconst AudioContext = {\n  getContext: function() {\n    if (_context === void 0) {\n      _context = new (window.AudioContext || window.webkitAudioContext)();\n    }\n    return _context;\n  },\n  setContext: function(value) {\n    _context = value;\n  }\n};\nclass AudioLoader extends Loader {\n  constructor(manager) {\n    super(manager);\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    const loader = new FileLoader(this.manager);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setPath(this.path);\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function(buffer) {\n      try {\n        const bufferCopy = buffer.slice(0);\n        const context = AudioContext.getContext();\n        context.decodeAudioData(bufferCopy, function(audioBuffer) {\n          onLoad(audioBuffer);\n        });\n      } catch (e) {\n        if (onError) {\n          onError(e);\n        } else {\n          console.error(e);\n        }\n        scope.manager.itemError(url);\n      }\n    }, onProgress, onError);\n  }\n}\nclass HemisphereLightProbe extends LightProbe {\n  constructor(skyColor, groundColor, intensity = 1) {\n    super(void 0, intensity);\n    const color1 = new Color().set(skyColor);\n    const color2 = new Color().set(groundColor);\n    const sky = new Vector3(color1.r, color1.g, color1.b);\n    const ground = new Vector3(color2.r, color2.g, color2.b);\n    const c0 = Math.sqrt(Math.PI);\n    const c1 = c0 * Math.sqrt(0.75);\n    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0);\n    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1);\n  }\n}\nHemisphereLightProbe.prototype.isHemisphereLightProbe = true;\nclass AmbientLightProbe extends LightProbe {\n  constructor(color, intensity = 1) {\n    super(void 0, intensity);\n    const color1 = new Color().set(color);\n    this.sh.coefficients[0].set(color1.r, color1.g, color1.b).multiplyScalar(2 * Math.sqrt(Math.PI));\n  }\n}\nAmbientLightProbe.prototype.isAmbientLightProbe = true;\nconst _eyeRight = /* @__PURE__ */ new Matrix4();\nconst _eyeLeft = /* @__PURE__ */ new Matrix4();\nclass StereoCamera {\n  constructor() {\n    this.type = \"StereoCamera\";\n    this.aspect = 1;\n    this.eyeSep = 0.064;\n    this.cameraL = new PerspectiveCamera();\n    this.cameraL.layers.enable(1);\n    this.cameraL.matrixAutoUpdate = false;\n    this.cameraR = new PerspectiveCamera();\n    this.cameraR.layers.enable(2);\n    this.cameraR.matrixAutoUpdate = false;\n    this._cache = {\n      focus: null,\n      fov: null,\n      aspect: null,\n      near: null,\n      far: null,\n      zoom: null,\n      eyeSep: null\n    };\n  }\n  update(camera) {\n    const cache = this._cache;\n    const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;\n    if (needsUpdate) {\n      cache.focus = camera.focus;\n      cache.fov = camera.fov;\n      cache.aspect = camera.aspect * this.aspect;\n      cache.near = camera.near;\n      cache.far = camera.far;\n      cache.zoom = camera.zoom;\n      cache.eyeSep = this.eyeSep;\n      const projectionMatrix = camera.projectionMatrix.clone();\n      const eyeSepHalf = cache.eyeSep / 2;\n      const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;\n      const ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;\n      let xmin, xmax;\n      _eyeLeft.elements[12] = -eyeSepHalf;\n      _eyeRight.elements[12] = eyeSepHalf;\n      xmin = -ymax * cache.aspect + eyeSepOnProjection;\n      xmax = ymax * cache.aspect + eyeSepOnProjection;\n      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n      this.cameraL.projectionMatrix.copy(projectionMatrix);\n      xmin = -ymax * cache.aspect - eyeSepOnProjection;\n      xmax = ymax * cache.aspect - eyeSepOnProjection;\n      projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);\n      projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);\n      this.cameraR.projectionMatrix.copy(projectionMatrix);\n    }\n    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);\n    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);\n  }\n}\nclass Clock {\n  constructor(autoStart = true) {\n    this.autoStart = autoStart;\n    this.startTime = 0;\n    this.oldTime = 0;\n    this.elapsedTime = 0;\n    this.running = false;\n  }\n  start() {\n    this.startTime = now();\n    this.oldTime = this.startTime;\n    this.elapsedTime = 0;\n    this.running = true;\n  }\n  stop() {\n    this.getElapsedTime();\n    this.running = false;\n    this.autoStart = false;\n  }\n  getElapsedTime() {\n    this.getDelta();\n    return this.elapsedTime;\n  }\n  getDelta() {\n    let diff = 0;\n    if (this.autoStart && !this.running) {\n      this.start();\n      return 0;\n    }\n    if (this.running) {\n      const newTime = now();\n      diff = (newTime - this.oldTime) / 1e3;\n      this.oldTime = newTime;\n      this.elapsedTime += diff;\n    }\n    return diff;\n  }\n}\nfunction now() {\n  return (typeof performance === \"undefined\" ? Date : performance).now();\n}\nconst _position$1 = /* @__PURE__ */ new Vector3();\nconst _quaternion$1 = /* @__PURE__ */ new Quaternion();\nconst _scale$1 = /* @__PURE__ */ new Vector3();\nconst _orientation$1 = /* @__PURE__ */ new Vector3();\nclass AudioListener extends Object3D {\n  constructor() {\n    super();\n    this.type = \"AudioListener\";\n    this.context = AudioContext.getContext();\n    this.gain = this.context.createGain();\n    this.gain.connect(this.context.destination);\n    this.filter = null;\n    this.timeDelta = 0;\n    this._clock = new Clock();\n  }\n  getInput() {\n    return this.gain;\n  }\n  removeFilter() {\n    if (this.filter !== null) {\n      this.gain.disconnect(this.filter);\n      this.filter.disconnect(this.context.destination);\n      this.gain.connect(this.context.destination);\n      this.filter = null;\n    }\n    return this;\n  }\n  getFilter() {\n    return this.filter;\n  }\n  setFilter(value) {\n    if (this.filter !== null) {\n      this.gain.disconnect(this.filter);\n      this.filter.disconnect(this.context.destination);\n    } else {\n      this.gain.disconnect(this.context.destination);\n    }\n    this.filter = value;\n    this.gain.connect(this.filter);\n    this.filter.connect(this.context.destination);\n    return this;\n  }\n  getMasterVolume() {\n    return this.gain.gain.value;\n  }\n  setMasterVolume(value) {\n    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n    return this;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    const listener = this.context.listener;\n    const up = this.up;\n    this.timeDelta = this._clock.getDelta();\n    this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);\n    _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);\n    if (listener.positionX) {\n      const endTime = this.context.currentTime + this.timeDelta;\n      listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);\n      listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);\n      listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);\n      listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);\n      listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);\n      listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);\n      listener.upX.linearRampToValueAtTime(up.x, endTime);\n      listener.upY.linearRampToValueAtTime(up.y, endTime);\n      listener.upZ.linearRampToValueAtTime(up.z, endTime);\n    } else {\n      listener.setPosition(_position$1.x, _position$1.y, _position$1.z);\n      listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);\n    }\n  }\n}\nclass Audio extends Object3D {\n  constructor(listener) {\n    super();\n    this.type = \"Audio\";\n    this.listener = listener;\n    this.context = listener.context;\n    this.gain = this.context.createGain();\n    this.gain.connect(listener.getInput());\n    this.autoplay = false;\n    this.buffer = null;\n    this.detune = 0;\n    this.loop = false;\n    this.loopStart = 0;\n    this.loopEnd = 0;\n    this.offset = 0;\n    this.duration = void 0;\n    this.playbackRate = 1;\n    this.isPlaying = false;\n    this.hasPlaybackControl = true;\n    this.source = null;\n    this.sourceType = \"empty\";\n    this._startedAt = 0;\n    this._progress = 0;\n    this._connected = false;\n    this.filters = [];\n  }\n  getOutput() {\n    return this.gain;\n  }\n  setNodeSource(audioNode) {\n    this.hasPlaybackControl = false;\n    this.sourceType = \"audioNode\";\n    this.source = audioNode;\n    this.connect();\n    return this;\n  }\n  setMediaElementSource(mediaElement) {\n    this.hasPlaybackControl = false;\n    this.sourceType = \"mediaNode\";\n    this.source = this.context.createMediaElementSource(mediaElement);\n    this.connect();\n    return this;\n  }\n  setMediaStreamSource(mediaStream) {\n    this.hasPlaybackControl = false;\n    this.sourceType = \"mediaStreamNode\";\n    this.source = this.context.createMediaStreamSource(mediaStream);\n    this.connect();\n    return this;\n  }\n  setBuffer(audioBuffer) {\n    this.buffer = audioBuffer;\n    this.sourceType = \"buffer\";\n    if (this.autoplay)\n      this.play();\n    return this;\n  }\n  play(delay = 0) {\n    if (this.isPlaying === true) {\n      console.warn(\"THREE.Audio: Audio is already playing.\");\n      return;\n    }\n    if (this.hasPlaybackControl === false) {\n      console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      return;\n    }\n    this._startedAt = this.context.currentTime + delay;\n    const source = this.context.createBufferSource();\n    source.buffer = this.buffer;\n    source.loop = this.loop;\n    source.loopStart = this.loopStart;\n    source.loopEnd = this.loopEnd;\n    source.onended = this.onEnded.bind(this);\n    source.start(this._startedAt, this._progress + this.offset, this.duration);\n    this.isPlaying = true;\n    this.source = source;\n    this.setDetune(this.detune);\n    this.setPlaybackRate(this.playbackRate);\n    return this.connect();\n  }\n  pause() {\n    if (this.hasPlaybackControl === false) {\n      console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      return;\n    }\n    if (this.isPlaying === true) {\n      this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;\n      if (this.loop === true) {\n        this._progress = this._progress % (this.duration || this.buffer.duration);\n      }\n      this.source.stop();\n      this.source.onended = null;\n      this.isPlaying = false;\n    }\n    return this;\n  }\n  stop() {\n    if (this.hasPlaybackControl === false) {\n      console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      return;\n    }\n    this._progress = 0;\n    this.source.stop();\n    this.source.onended = null;\n    this.isPlaying = false;\n    return this;\n  }\n  connect() {\n    if (this.filters.length > 0) {\n      this.source.connect(this.filters[0]);\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].connect(this.filters[i]);\n      }\n      this.filters[this.filters.length - 1].connect(this.getOutput());\n    } else {\n      this.source.connect(this.getOutput());\n    }\n    this._connected = true;\n    return this;\n  }\n  disconnect() {\n    if (this.filters.length > 0) {\n      this.source.disconnect(this.filters[0]);\n      for (let i = 1, l = this.filters.length; i < l; i++) {\n        this.filters[i - 1].disconnect(this.filters[i]);\n      }\n      this.filters[this.filters.length - 1].disconnect(this.getOutput());\n    } else {\n      this.source.disconnect(this.getOutput());\n    }\n    this._connected = false;\n    return this;\n  }\n  getFilters() {\n    return this.filters;\n  }\n  setFilters(value) {\n    if (!value)\n      value = [];\n    if (this._connected === true) {\n      this.disconnect();\n      this.filters = value.slice();\n      this.connect();\n    } else {\n      this.filters = value.slice();\n    }\n    return this;\n  }\n  setDetune(value) {\n    this.detune = value;\n    if (this.source.detune === void 0)\n      return;\n    if (this.isPlaying === true) {\n      this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);\n    }\n    return this;\n  }\n  getDetune() {\n    return this.detune;\n  }\n  getFilter() {\n    return this.getFilters()[0];\n  }\n  setFilter(filter) {\n    return this.setFilters(filter ? [filter] : []);\n  }\n  setPlaybackRate(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      return;\n    }\n    this.playbackRate = value;\n    if (this.isPlaying === true) {\n      this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);\n    }\n    return this;\n  }\n  getPlaybackRate() {\n    return this.playbackRate;\n  }\n  onEnded() {\n    this.isPlaying = false;\n  }\n  getLoop() {\n    if (this.hasPlaybackControl === false) {\n      console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      return false;\n    }\n    return this.loop;\n  }\n  setLoop(value) {\n    if (this.hasPlaybackControl === false) {\n      console.warn(\"THREE.Audio: this Audio has no playback control.\");\n      return;\n    }\n    this.loop = value;\n    if (this.isPlaying === true) {\n      this.source.loop = this.loop;\n    }\n    return this;\n  }\n  setLoopStart(value) {\n    this.loopStart = value;\n    return this;\n  }\n  setLoopEnd(value) {\n    this.loopEnd = value;\n    return this;\n  }\n  getVolume() {\n    return this.gain.gain.value;\n  }\n  setVolume(value) {\n    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);\n    return this;\n  }\n}\nconst _position = /* @__PURE__ */ new Vector3();\nconst _quaternion = /* @__PURE__ */ new Quaternion();\nconst _scale = /* @__PURE__ */ new Vector3();\nconst _orientation = /* @__PURE__ */ new Vector3();\nclass PositionalAudio extends Audio {\n  constructor(listener) {\n    super(listener);\n    this.panner = this.context.createPanner();\n    this.panner.panningModel = \"HRTF\";\n    this.panner.connect(this.gain);\n  }\n  getOutput() {\n    return this.panner;\n  }\n  getRefDistance() {\n    return this.panner.refDistance;\n  }\n  setRefDistance(value) {\n    this.panner.refDistance = value;\n    return this;\n  }\n  getRolloffFactor() {\n    return this.panner.rolloffFactor;\n  }\n  setRolloffFactor(value) {\n    this.panner.rolloffFactor = value;\n    return this;\n  }\n  getDistanceModel() {\n    return this.panner.distanceModel;\n  }\n  setDistanceModel(value) {\n    this.panner.distanceModel = value;\n    return this;\n  }\n  getMaxDistance() {\n    return this.panner.maxDistance;\n  }\n  setMaxDistance(value) {\n    this.panner.maxDistance = value;\n    return this;\n  }\n  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n    this.panner.coneInnerAngle = coneInnerAngle;\n    this.panner.coneOuterAngle = coneOuterAngle;\n    this.panner.coneOuterGain = coneOuterGain;\n    return this;\n  }\n  updateMatrixWorld(force) {\n    super.updateMatrixWorld(force);\n    if (this.hasPlaybackControl === true && this.isPlaying === false)\n      return;\n    this.matrixWorld.decompose(_position, _quaternion, _scale);\n    _orientation.set(0, 0, 1).applyQuaternion(_quaternion);\n    const panner = this.panner;\n    if (panner.positionX) {\n      const endTime = this.context.currentTime + this.listener.timeDelta;\n      panner.positionX.linearRampToValueAtTime(_position.x, endTime);\n      panner.positionY.linearRampToValueAtTime(_position.y, endTime);\n      panner.positionZ.linearRampToValueAtTime(_position.z, endTime);\n      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);\n      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);\n      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);\n    } else {\n      panner.setPosition(_position.x, _position.y, _position.z);\n      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);\n    }\n  }\n}\nclass AudioAnalyser {\n  constructor(audio, fftSize = 2048) {\n    this.analyser = audio.context.createAnalyser();\n    this.analyser.fftSize = fftSize;\n    this.data = new Uint8Array(this.analyser.frequencyBinCount);\n    audio.getOutput().connect(this.analyser);\n  }\n  getFrequencyData() {\n    this.analyser.getByteFrequencyData(this.data);\n    return this.data;\n  }\n  getAverageFrequency() {\n    let value = 0;\n    const data = this.getFrequencyData();\n    for (let i = 0; i < data.length; i++) {\n      value += data[i];\n    }\n    return value / data.length;\n  }\n}\nclass PropertyMixer {\n  constructor(binding, typeName, valueSize) {\n    this.binding = binding;\n    this.valueSize = valueSize;\n    let mixFunction, mixFunctionAdditive, setIdentity;\n    switch (typeName) {\n      case \"quaternion\":\n        mixFunction = this._slerp;\n        mixFunctionAdditive = this._slerpAdditive;\n        setIdentity = this._setAdditiveIdentityQuaternion;\n        this.buffer = new Float64Array(valueSize * 6);\n        this._workIndex = 5;\n        break;\n      case \"string\":\n      case \"bool\":\n        mixFunction = this._select;\n        mixFunctionAdditive = this._select;\n        setIdentity = this._setAdditiveIdentityOther;\n        this.buffer = new Array(valueSize * 5);\n        break;\n      default:\n        mixFunction = this._lerp;\n        mixFunctionAdditive = this._lerpAdditive;\n        setIdentity = this._setAdditiveIdentityNumeric;\n        this.buffer = new Float64Array(valueSize * 5);\n    }\n    this._mixBufferRegion = mixFunction;\n    this._mixBufferRegionAdditive = mixFunctionAdditive;\n    this._setIdentity = setIdentity;\n    this._origIndex = 3;\n    this._addIndex = 4;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    this.useCount = 0;\n    this.referenceCount = 0;\n  }\n  accumulate(accuIndex, weight) {\n    const buffer = this.buffer, stride = this.valueSize, offset = accuIndex * stride + stride;\n    let currentWeight = this.cumulativeWeight;\n    if (currentWeight === 0) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[offset + i] = buffer[i];\n      }\n      currentWeight = weight;\n    } else {\n      currentWeight += weight;\n      const mix = weight / currentWeight;\n      this._mixBufferRegion(buffer, offset, 0, mix, stride);\n    }\n    this.cumulativeWeight = currentWeight;\n  }\n  accumulateAdditive(weight) {\n    const buffer = this.buffer, stride = this.valueSize, offset = stride * this._addIndex;\n    if (this.cumulativeWeightAdditive === 0) {\n      this._setIdentity();\n    }\n    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);\n    this.cumulativeWeightAdditive += weight;\n  }\n  apply(accuIndex) {\n    const stride = this.valueSize, buffer = this.buffer, offset = accuIndex * stride + stride, weight = this.cumulativeWeight, weightAdditive = this.cumulativeWeightAdditive, binding = this.binding;\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n    if (weight < 1) {\n      const originalValueOffset = stride * this._origIndex;\n      this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);\n    }\n    if (weightAdditive > 0) {\n      this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);\n    }\n    for (let i = stride, e = stride + stride; i !== e; ++i) {\n      if (buffer[i] !== buffer[i + stride]) {\n        binding.setValue(buffer, offset);\n        break;\n      }\n    }\n  }\n  saveOriginalState() {\n    const binding = this.binding;\n    const buffer = this.buffer, stride = this.valueSize, originalValueOffset = stride * this._origIndex;\n    binding.getValue(buffer, originalValueOffset);\n    for (let i = stride, e = originalValueOffset; i !== e; ++i) {\n      buffer[i] = buffer[originalValueOffset + i % stride];\n    }\n    this._setIdentity();\n    this.cumulativeWeight = 0;\n    this.cumulativeWeightAdditive = 0;\n  }\n  restoreOriginalState() {\n    const originalValueOffset = this.valueSize * 3;\n    this.binding.setValue(this.buffer, originalValueOffset);\n  }\n  _setAdditiveIdentityNumeric() {\n    const startIndex = this._addIndex * this.valueSize;\n    const endIndex = startIndex + this.valueSize;\n    for (let i = startIndex; i < endIndex; i++) {\n      this.buffer[i] = 0;\n    }\n  }\n  _setAdditiveIdentityQuaternion() {\n    this._setAdditiveIdentityNumeric();\n    this.buffer[this._addIndex * this.valueSize + 3] = 1;\n  }\n  _setAdditiveIdentityOther() {\n    const startIndex = this._origIndex * this.valueSize;\n    const targetIndex = this._addIndex * this.valueSize;\n    for (let i = 0; i < this.valueSize; i++) {\n      this.buffer[targetIndex + i] = this.buffer[startIndex + i];\n    }\n  }\n  _select(buffer, dstOffset, srcOffset, t, stride) {\n    if (t >= 0.5) {\n      for (let i = 0; i !== stride; ++i) {\n        buffer[dstOffset + i] = buffer[srcOffset + i];\n      }\n    }\n  }\n  _slerp(buffer, dstOffset, srcOffset, t) {\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);\n  }\n  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    const workOffset = this._workIndex * stride;\n    Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);\n    Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);\n  }\n  _lerp(buffer, dstOffset, srcOffset, t, stride) {\n    const s = 1 - t;\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;\n    }\n  }\n  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {\n    for (let i = 0; i !== stride; ++i) {\n      const j = dstOffset + i;\n      buffer[j] = buffer[j] + buffer[srcOffset + i] * t;\n    }\n  }\n}\nconst _RESERVED_CHARS_RE = \"\\\\[\\\\]\\\\.:\\\\/\";\nconst _reservedRe = new RegExp(\"[\" + _RESERVED_CHARS_RE + \"]\", \"g\");\nconst _wordChar = \"[^\" + _RESERVED_CHARS_RE + \"]\";\nconst _wordCharOrDot = \"[^\" + _RESERVED_CHARS_RE.replace(\"\\\\.\", \"\") + \"]\";\nconst _directoryRe = /((?:WC+[\\/:])*)/.source.replace(\"WC\", _wordChar);\nconst _nodeRe = /(WCOD+)?/.source.replace(\"WCOD\", _wordCharOrDot);\nconst _objectRe = /(?:\\.(WC+)(?:\\[(.+)\\])?)?/.source.replace(\"WC\", _wordChar);\nconst _propertyRe = /\\.(WC+)(?:\\[(.+)\\])?/.source.replace(\"WC\", _wordChar);\nconst _trackRe = new RegExp(\"^\" + _directoryRe + _nodeRe + _objectRe + _propertyRe + \"$\");\nconst _supportedObjectNames = [\"material\", \"materials\", \"bones\"];\nclass Composite {\n  constructor(targetGroup, path, optionalParsedPath) {\n    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);\n    this._targetGroup = targetGroup;\n    this._bindings = targetGroup.subscribe_(path, parsedPath);\n  }\n  getValue(array, offset) {\n    this.bind();\n    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];\n    if (binding !== void 0)\n      binding.getValue(array, offset);\n  }\n  setValue(array, offset) {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].setValue(array, offset);\n    }\n  }\n  bind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].bind();\n    }\n  }\n  unbind() {\n    const bindings = this._bindings;\n    for (let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {\n      bindings[i].unbind();\n    }\n  }\n}\nclass PropertyBinding {\n  constructor(rootNode, path, parsedPath) {\n    this.path = path;\n    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);\n    this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode;\n    this.rootNode = rootNode;\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n  static create(root, path, parsedPath) {\n    if (!(root && root.isAnimationObjectGroup)) {\n      return new PropertyBinding(root, path, parsedPath);\n    } else {\n      return new PropertyBinding.Composite(root, path, parsedPath);\n    }\n  }\n  static sanitizeNodeName(name) {\n    return name.replace(/\\s/g, \"_\").replace(_reservedRe, \"\");\n  }\n  static parseTrackName(trackName) {\n    const matches = _trackRe.exec(trackName);\n    if (!matches) {\n      throw new Error(\"PropertyBinding: Cannot parse trackName: \" + trackName);\n    }\n    const results = {\n      nodeName: matches[2],\n      objectName: matches[3],\n      objectIndex: matches[4],\n      propertyName: matches[5],\n      propertyIndex: matches[6]\n    };\n    const lastDot = results.nodeName && results.nodeName.lastIndexOf(\".\");\n    if (lastDot !== void 0 && lastDot !== -1) {\n      const objectName = results.nodeName.substring(lastDot + 1);\n      if (_supportedObjectNames.indexOf(objectName) !== -1) {\n        results.nodeName = results.nodeName.substring(0, lastDot);\n        results.objectName = objectName;\n      }\n    }\n    if (results.propertyName === null || results.propertyName.length === 0) {\n      throw new Error(\"PropertyBinding: can not parse propertyName from trackName: \" + trackName);\n    }\n    return results;\n  }\n  static findNode(root, nodeName) {\n    if (!nodeName || nodeName === \"\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {\n      return root;\n    }\n    if (root.skeleton) {\n      const bone = root.skeleton.getBoneByName(nodeName);\n      if (bone !== void 0) {\n        return bone;\n      }\n    }\n    if (root.children) {\n      const searchNodeSubtree = function(children) {\n        for (let i = 0; i < children.length; i++) {\n          const childNode = children[i];\n          if (childNode.name === nodeName || childNode.uuid === nodeName) {\n            return childNode;\n          }\n          const result = searchNodeSubtree(childNode.children);\n          if (result)\n            return result;\n        }\n        return null;\n      };\n      const subTreeNode = searchNodeSubtree(root.children);\n      if (subTreeNode) {\n        return subTreeNode;\n      }\n    }\n    return null;\n  }\n  _getValue_unavailable() {\n  }\n  _setValue_unavailable() {\n  }\n  _getValue_direct(buffer, offset) {\n    buffer[offset] = this.node[this.propertyName];\n  }\n  _getValue_array(buffer, offset) {\n    const source = this.resolvedProperty;\n    for (let i = 0, n = source.length; i !== n; ++i) {\n      buffer[offset++] = source[i];\n    }\n  }\n  _getValue_arrayElement(buffer, offset) {\n    buffer[offset] = this.resolvedProperty[this.propertyIndex];\n  }\n  _getValue_toArray(buffer, offset) {\n    this.resolvedProperty.toArray(buffer, offset);\n  }\n  _setValue_direct(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n  }\n  _setValue_direct_setNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.targetObject[this.propertyName] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  _setValue_array(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n  }\n  _setValue_array_setNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {\n    const dest = this.resolvedProperty;\n    for (let i = 0, n = dest.length; i !== n; ++i) {\n      dest[i] = buffer[offset++];\n    }\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  _setValue_arrayElement(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n  }\n  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty[this.propertyIndex] = buffer[offset];\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  _setValue_fromArray(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n  }\n  _setValue_fromArray_setNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.needsUpdate = true;\n  }\n  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {\n    this.resolvedProperty.fromArray(buffer, offset);\n    this.targetObject.matrixWorldNeedsUpdate = true;\n  }\n  _getValue_unbound(targetArray, offset) {\n    this.bind();\n    this.getValue(targetArray, offset);\n  }\n  _setValue_unbound(sourceArray, offset) {\n    this.bind();\n    this.setValue(sourceArray, offset);\n  }\n  bind() {\n    let targetObject = this.node;\n    const parsedPath = this.parsedPath;\n    const objectName = parsedPath.objectName;\n    const propertyName = parsedPath.propertyName;\n    let propertyIndex = parsedPath.propertyIndex;\n    if (!targetObject) {\n      targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) || this.rootNode;\n      this.node = targetObject;\n    }\n    this.getValue = this._getValue_unavailable;\n    this.setValue = this._setValue_unavailable;\n    if (!targetObject) {\n      console.error(\"THREE.PropertyBinding: Trying to update node for track: \" + this.path + \" but it wasn't found.\");\n      return;\n    }\n    if (objectName) {\n      let objectIndex = parsedPath.objectIndex;\n      switch (objectName) {\n        case \"materials\":\n          if (!targetObject.material) {\n            console.error(\"THREE.PropertyBinding: Can not bind to material as node does not have a material.\", this);\n            return;\n          }\n          if (!targetObject.material.materials) {\n            console.error(\"THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.\", this);\n            return;\n          }\n          targetObject = targetObject.material.materials;\n          break;\n        case \"bones\":\n          if (!targetObject.skeleton) {\n            console.error(\"THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.\", this);\n            return;\n          }\n          targetObject = targetObject.skeleton.bones;\n          for (let i = 0; i < targetObject.length; i++) {\n            if (targetObject[i].name === objectIndex) {\n              objectIndex = i;\n              break;\n            }\n          }\n          break;\n        default:\n          if (targetObject[objectName] === void 0) {\n            console.error(\"THREE.PropertyBinding: Can not bind to objectName of node undefined.\", this);\n            return;\n          }\n          targetObject = targetObject[objectName];\n      }\n      if (objectIndex !== void 0) {\n        if (targetObject[objectIndex] === void 0) {\n          console.error(\"THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.\", this, targetObject);\n          return;\n        }\n        targetObject = targetObject[objectIndex];\n      }\n    }\n    const nodeProperty = targetObject[propertyName];\n    if (nodeProperty === void 0) {\n      const nodeName = parsedPath.nodeName;\n      console.error(\"THREE.PropertyBinding: Trying to update property for track: \" + nodeName + \".\" + propertyName + \" but it wasn't found.\", targetObject);\n      return;\n    }\n    let versioning = this.Versioning.None;\n    this.targetObject = targetObject;\n    if (targetObject.needsUpdate !== void 0) {\n      versioning = this.Versioning.NeedsUpdate;\n    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {\n      versioning = this.Versioning.MatrixWorldNeedsUpdate;\n    }\n    let bindingType = this.BindingType.Direct;\n    if (propertyIndex !== void 0) {\n      if (propertyName === \"morphTargetInfluences\") {\n        if (!targetObject.geometry) {\n          console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.\", this);\n          return;\n        }\n        if (targetObject.geometry.isBufferGeometry) {\n          if (!targetObject.geometry.morphAttributes) {\n            console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.\", this);\n            return;\n          }\n          if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {\n            propertyIndex = targetObject.morphTargetDictionary[propertyIndex];\n          }\n        } else {\n          console.error(\"THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.\", this);\n          return;\n        }\n      }\n      bindingType = this.BindingType.ArrayElement;\n      this.resolvedProperty = nodeProperty;\n      this.propertyIndex = propertyIndex;\n    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {\n      bindingType = this.BindingType.HasFromToArray;\n      this.resolvedProperty = nodeProperty;\n    } else if (Array.isArray(nodeProperty)) {\n      bindingType = this.BindingType.EntireArray;\n      this.resolvedProperty = nodeProperty;\n    } else {\n      this.propertyName = propertyName;\n    }\n    this.getValue = this.GetterByBindingType[bindingType];\n    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];\n  }\n  unbind() {\n    this.node = null;\n    this.getValue = this._getValue_unbound;\n    this.setValue = this._setValue_unbound;\n  }\n}\nPropertyBinding.Composite = Composite;\nPropertyBinding.prototype.BindingType = {\n  Direct: 0,\n  EntireArray: 1,\n  ArrayElement: 2,\n  HasFromToArray: 3\n};\nPropertyBinding.prototype.Versioning = {\n  None: 0,\n  NeedsUpdate: 1,\n  MatrixWorldNeedsUpdate: 2\n};\nPropertyBinding.prototype.GetterByBindingType = [\n  PropertyBinding.prototype._getValue_direct,\n  PropertyBinding.prototype._getValue_array,\n  PropertyBinding.prototype._getValue_arrayElement,\n  PropertyBinding.prototype._getValue_toArray\n];\nPropertyBinding.prototype.SetterByBindingTypeAndVersioning = [\n  [\n    PropertyBinding.prototype._setValue_direct,\n    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate\n  ],\n  [\n    PropertyBinding.prototype._setValue_array,\n    PropertyBinding.prototype._setValue_array_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate\n  ],\n  [\n    PropertyBinding.prototype._setValue_arrayElement,\n    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate\n  ],\n  [\n    PropertyBinding.prototype._setValue_fromArray,\n    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,\n    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate\n  ]\n];\nclass AnimationObjectGroup {\n  constructor() {\n    this.uuid = generateUUID();\n    this._objects = Array.prototype.slice.call(arguments);\n    this.nCachedObjects_ = 0;\n    const indices = {};\n    this._indicesByUUID = indices;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      indices[arguments[i].uuid] = i;\n    }\n    this._paths = [];\n    this._parsedPaths = [];\n    this._bindings = [];\n    this._bindingsIndicesByPath = {};\n    const scope = this;\n    this.stats = {\n      objects: {\n        get total() {\n          return scope._objects.length;\n        },\n        get inUse() {\n          return this.total - scope.nCachedObjects_;\n        }\n      },\n      get bindingsPerObject() {\n        return scope._bindings.length;\n      }\n    };\n  }\n  add() {\n    const objects = this._objects, indicesByUUID = this._indicesByUUID, paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, nBindings = bindings.length;\n    let knownObject = void 0, nObjects = objects.length, nCachedObjects = this.nCachedObjects_;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i], uuid = object.uuid;\n      let index = indicesByUUID[uuid];\n      if (index === void 0) {\n        index = nObjects++;\n        indicesByUUID[uuid] = index;\n        objects.push(object);\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));\n        }\n      } else if (index < nCachedObjects) {\n        knownObject = objects[index];\n        const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex];\n        indicesByUUID[lastCachedObject.uuid] = index;\n        objects[index] = lastCachedObject;\n        indicesByUUID[uuid] = firstActiveIndex;\n        objects[firstActiveIndex] = object;\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex];\n          let binding = bindingsForPath[index];\n          bindingsForPath[index] = lastCached;\n          if (binding === void 0) {\n            binding = new PropertyBinding(object, paths[j], parsedPaths[j]);\n          }\n          bindingsForPath[firstActiveIndex] = binding;\n        }\n      } else if (objects[index] !== knownObject) {\n        console.error(\"THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.\");\n      }\n    }\n    this.nCachedObjects_ = nCachedObjects;\n  }\n  remove() {\n    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];\n      if (index !== void 0 && index >= nCachedObjects) {\n        const lastCachedIndex = nCachedObjects++, firstActiveObject = objects[lastCachedIndex];\n        indicesByUUID[firstActiveObject.uuid] = index;\n        objects[index] = firstActiveObject;\n        indicesByUUID[uuid] = lastCachedIndex;\n        objects[lastCachedIndex] = object;\n        for (let j = 0, m = nBindings; j !== m; ++j) {\n          const bindingsForPath = bindings[j], firstActive = bindingsForPath[lastCachedIndex], binding = bindingsForPath[index];\n          bindingsForPath[index] = firstActive;\n          bindingsForPath[lastCachedIndex] = binding;\n        }\n      }\n    }\n    this.nCachedObjects_ = nCachedObjects;\n  }\n  uncache() {\n    const objects = this._objects, indicesByUUID = this._indicesByUUID, bindings = this._bindings, nBindings = bindings.length;\n    let nCachedObjects = this.nCachedObjects_, nObjects = objects.length;\n    for (let i = 0, n = arguments.length; i !== n; ++i) {\n      const object = arguments[i], uuid = object.uuid, index = indicesByUUID[uuid];\n      if (index !== void 0) {\n        delete indicesByUUID[uuid];\n        if (index < nCachedObjects) {\n          const firstActiveIndex = --nCachedObjects, lastCachedObject = objects[firstActiveIndex], lastIndex = --nObjects, lastObject = objects[lastIndex];\n          indicesByUUID[lastCachedObject.uuid] = index;\n          objects[index] = lastCachedObject;\n          indicesByUUID[lastObject.uuid] = firstActiveIndex;\n          objects[firstActiveIndex] = lastObject;\n          objects.pop();\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j], lastCached = bindingsForPath[firstActiveIndex], last = bindingsForPath[lastIndex];\n            bindingsForPath[index] = lastCached;\n            bindingsForPath[firstActiveIndex] = last;\n            bindingsForPath.pop();\n          }\n        } else {\n          const lastIndex = --nObjects, lastObject = objects[lastIndex];\n          if (lastIndex > 0) {\n            indicesByUUID[lastObject.uuid] = index;\n          }\n          objects[index] = lastObject;\n          objects.pop();\n          for (let j = 0, m = nBindings; j !== m; ++j) {\n            const bindingsForPath = bindings[j];\n            bindingsForPath[index] = bindingsForPath[lastIndex];\n            bindingsForPath.pop();\n          }\n        }\n      }\n    }\n    this.nCachedObjects_ = nCachedObjects;\n  }\n  subscribe_(path, parsedPath) {\n    const indicesByPath = this._bindingsIndicesByPath;\n    let index = indicesByPath[path];\n    const bindings = this._bindings;\n    if (index !== void 0)\n      return bindings[index];\n    const paths = this._paths, parsedPaths = this._parsedPaths, objects = this._objects, nObjects = objects.length, nCachedObjects = this.nCachedObjects_, bindingsForPath = new Array(nObjects);\n    index = bindings.length;\n    indicesByPath[path] = index;\n    paths.push(path);\n    parsedPaths.push(parsedPath);\n    bindings.push(bindingsForPath);\n    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {\n      const object = objects[i];\n      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);\n    }\n    return bindingsForPath;\n  }\n  unsubscribe_(path) {\n    const indicesByPath = this._bindingsIndicesByPath, index = indicesByPath[path];\n    if (index !== void 0) {\n      const paths = this._paths, parsedPaths = this._parsedPaths, bindings = this._bindings, lastBindingsIndex = bindings.length - 1, lastBindings = bindings[lastBindingsIndex], lastBindingsPath = path[lastBindingsIndex];\n      indicesByPath[lastBindingsPath] = index;\n      bindings[index] = lastBindings;\n      bindings.pop();\n      parsedPaths[index] = parsedPaths[lastBindingsIndex];\n      parsedPaths.pop();\n      paths[index] = paths[lastBindingsIndex];\n      paths.pop();\n    }\n  }\n}\nAnimationObjectGroup.prototype.isAnimationObjectGroup = true;\nclass AnimationAction {\n  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {\n    this._mixer = mixer;\n    this._clip = clip;\n    this._localRoot = localRoot;\n    this.blendMode = blendMode;\n    const tracks = clip.tracks, nTracks = tracks.length, interpolants = new Array(nTracks);\n    const interpolantSettings = {\n      endingStart: ZeroCurvatureEnding,\n      endingEnd: ZeroCurvatureEnding\n    };\n    for (let i = 0; i !== nTracks; ++i) {\n      const interpolant = tracks[i].createInterpolant(null);\n      interpolants[i] = interpolant;\n      interpolant.settings = interpolantSettings;\n    }\n    this._interpolantSettings = interpolantSettings;\n    this._interpolants = interpolants;\n    this._propertyBindings = new Array(nTracks);\n    this._cacheIndex = null;\n    this._byClipCacheIndex = null;\n    this._timeScaleInterpolant = null;\n    this._weightInterpolant = null;\n    this.loop = LoopRepeat;\n    this._loopCount = -1;\n    this._startTime = null;\n    this.time = 0;\n    this.timeScale = 1;\n    this._effectiveTimeScale = 1;\n    this.weight = 1;\n    this._effectiveWeight = 1;\n    this.repetitions = Infinity;\n    this.paused = false;\n    this.enabled = true;\n    this.clampWhenFinished = false;\n    this.zeroSlopeAtStart = true;\n    this.zeroSlopeAtEnd = true;\n  }\n  play() {\n    this._mixer._activateAction(this);\n    return this;\n  }\n  stop() {\n    this._mixer._deactivateAction(this);\n    return this.reset();\n  }\n  reset() {\n    this.paused = false;\n    this.enabled = true;\n    this.time = 0;\n    this._loopCount = -1;\n    this._startTime = null;\n    return this.stopFading().stopWarping();\n  }\n  isRunning() {\n    return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);\n  }\n  isScheduled() {\n    return this._mixer._isActiveAction(this);\n  }\n  startAt(time) {\n    this._startTime = time;\n    return this;\n  }\n  setLoop(mode, repetitions) {\n    this.loop = mode;\n    this.repetitions = repetitions;\n    return this;\n  }\n  setEffectiveWeight(weight) {\n    this.weight = weight;\n    this._effectiveWeight = this.enabled ? weight : 0;\n    return this.stopFading();\n  }\n  getEffectiveWeight() {\n    return this._effectiveWeight;\n  }\n  fadeIn(duration) {\n    return this._scheduleFading(duration, 0, 1);\n  }\n  fadeOut(duration) {\n    return this._scheduleFading(duration, 1, 0);\n  }\n  crossFadeFrom(fadeOutAction, duration, warp) {\n    fadeOutAction.fadeOut(duration);\n    this.fadeIn(duration);\n    if (warp) {\n      const fadeInDuration = this._clip.duration, fadeOutDuration = fadeOutAction._clip.duration, startEndRatio = fadeOutDuration / fadeInDuration, endStartRatio = fadeInDuration / fadeOutDuration;\n      fadeOutAction.warp(1, startEndRatio, duration);\n      this.warp(endStartRatio, 1, duration);\n    }\n    return this;\n  }\n  crossFadeTo(fadeInAction, duration, warp) {\n    return fadeInAction.crossFadeFrom(this, duration, warp);\n  }\n  stopFading() {\n    const weightInterpolant = this._weightInterpolant;\n    if (weightInterpolant !== null) {\n      this._weightInterpolant = null;\n      this._mixer._takeBackControlInterpolant(weightInterpolant);\n    }\n    return this;\n  }\n  setEffectiveTimeScale(timeScale) {\n    this.timeScale = timeScale;\n    this._effectiveTimeScale = this.paused ? 0 : timeScale;\n    return this.stopWarping();\n  }\n  getEffectiveTimeScale() {\n    return this._effectiveTimeScale;\n  }\n  setDuration(duration) {\n    this.timeScale = this._clip.duration / duration;\n    return this.stopWarping();\n  }\n  syncWith(action) {\n    this.time = action.time;\n    this.timeScale = action.timeScale;\n    return this.stopWarping();\n  }\n  halt(duration) {\n    return this.warp(this._effectiveTimeScale, 0, duration);\n  }\n  warp(startTimeScale, endTimeScale, duration) {\n    const mixer = this._mixer, now2 = mixer.time, timeScale = this.timeScale;\n    let interpolant = this._timeScaleInterpolant;\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._timeScaleInterpolant = interpolant;\n    }\n    const times = interpolant.parameterPositions, values = interpolant.sampleValues;\n    times[0] = now2;\n    times[1] = now2 + duration;\n    values[0] = startTimeScale / timeScale;\n    values[1] = endTimeScale / timeScale;\n    return this;\n  }\n  stopWarping() {\n    const timeScaleInterpolant = this._timeScaleInterpolant;\n    if (timeScaleInterpolant !== null) {\n      this._timeScaleInterpolant = null;\n      this._mixer._takeBackControlInterpolant(timeScaleInterpolant);\n    }\n    return this;\n  }\n  getMixer() {\n    return this._mixer;\n  }\n  getClip() {\n    return this._clip;\n  }\n  getRoot() {\n    return this._localRoot || this._mixer._root;\n  }\n  _update(time, deltaTime, timeDirection, accuIndex) {\n    if (!this.enabled) {\n      this._updateWeight(time);\n      return;\n    }\n    const startTime = this._startTime;\n    if (startTime !== null) {\n      const timeRunning = (time - startTime) * timeDirection;\n      if (timeRunning < 0 || timeDirection === 0) {\n        return;\n      }\n      this._startTime = null;\n      deltaTime = timeDirection * timeRunning;\n    }\n    deltaTime *= this._updateTimeScale(time);\n    const clipTime = this._updateTime(deltaTime);\n    const weight = this._updateWeight(time);\n    if (weight > 0) {\n      const interpolants = this._interpolants;\n      const propertyMixers = this._propertyBindings;\n      switch (this.blendMode) {\n        case AdditiveAnimationBlendMode:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulateAdditive(weight);\n          }\n          break;\n        case NormalAnimationBlendMode:\n        default:\n          for (let j = 0, m = interpolants.length; j !== m; ++j) {\n            interpolants[j].evaluate(clipTime);\n            propertyMixers[j].accumulate(accuIndex, weight);\n          }\n      }\n    }\n  }\n  _updateWeight(time) {\n    let weight = 0;\n    if (this.enabled) {\n      weight = this.weight;\n      const interpolant = this._weightInterpolant;\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        weight *= interpolantValue;\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopFading();\n          if (interpolantValue === 0) {\n            this.enabled = false;\n          }\n        }\n      }\n    }\n    this._effectiveWeight = weight;\n    return weight;\n  }\n  _updateTimeScale(time) {\n    let timeScale = 0;\n    if (!this.paused) {\n      timeScale = this.timeScale;\n      const interpolant = this._timeScaleInterpolant;\n      if (interpolant !== null) {\n        const interpolantValue = interpolant.evaluate(time)[0];\n        timeScale *= interpolantValue;\n        if (time > interpolant.parameterPositions[1]) {\n          this.stopWarping();\n          if (timeScale === 0) {\n            this.paused = true;\n          } else {\n            this.timeScale = timeScale;\n          }\n        }\n      }\n    }\n    this._effectiveTimeScale = timeScale;\n    return timeScale;\n  }\n  _updateTime(deltaTime) {\n    const duration = this._clip.duration;\n    const loop = this.loop;\n    let time = this.time + deltaTime;\n    let loopCount = this._loopCount;\n    const pingPong = loop === LoopPingPong;\n    if (deltaTime === 0) {\n      if (loopCount === -1)\n        return time;\n      return pingPong && (loopCount & 1) === 1 ? duration - time : time;\n    }\n    if (loop === LoopOnce) {\n      if (loopCount === -1) {\n        this._loopCount = 0;\n        this._setEndings(true, true, false);\n      }\n      handle_stop: {\n        if (time >= duration) {\n          time = duration;\n        } else if (time < 0) {\n          time = 0;\n        } else {\n          this.time = time;\n          break handle_stop;\n        }\n        if (this.clampWhenFinished)\n          this.paused = true;\n        else\n          this.enabled = false;\n        this.time = time;\n        this._mixer.dispatchEvent({\n          type: \"finished\",\n          action: this,\n          direction: deltaTime < 0 ? -1 : 1\n        });\n      }\n    } else {\n      if (loopCount === -1) {\n        if (deltaTime >= 0) {\n          loopCount = 0;\n          this._setEndings(true, this.repetitions === 0, pingPong);\n        } else {\n          this._setEndings(this.repetitions === 0, true, pingPong);\n        }\n      }\n      if (time >= duration || time < 0) {\n        const loopDelta = Math.floor(time / duration);\n        time -= duration * loopDelta;\n        loopCount += Math.abs(loopDelta);\n        const pending = this.repetitions - loopCount;\n        if (pending <= 0) {\n          if (this.clampWhenFinished)\n            this.paused = true;\n          else\n            this.enabled = false;\n          time = deltaTime > 0 ? duration : 0;\n          this.time = time;\n          this._mixer.dispatchEvent({\n            type: \"finished\",\n            action: this,\n            direction: deltaTime > 0 ? 1 : -1\n          });\n        } else {\n          if (pending === 1) {\n            const atStart = deltaTime < 0;\n            this._setEndings(atStart, !atStart, pingPong);\n          } else {\n            this._setEndings(false, false, pingPong);\n          }\n          this._loopCount = loopCount;\n          this.time = time;\n          this._mixer.dispatchEvent({\n            type: \"loop\",\n            action: this,\n            loopDelta\n          });\n        }\n      } else {\n        this.time = time;\n      }\n      if (pingPong && (loopCount & 1) === 1) {\n        return duration - time;\n      }\n    }\n    return time;\n  }\n  _setEndings(atStart, atEnd, pingPong) {\n    const settings = this._interpolantSettings;\n    if (pingPong) {\n      settings.endingStart = ZeroSlopeEnding;\n      settings.endingEnd = ZeroSlopeEnding;\n    } else {\n      if (atStart) {\n        settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingStart = WrapAroundEnding;\n      }\n      if (atEnd) {\n        settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;\n      } else {\n        settings.endingEnd = WrapAroundEnding;\n      }\n    }\n  }\n  _scheduleFading(duration, weightNow, weightThen) {\n    const mixer = this._mixer, now2 = mixer.time;\n    let interpolant = this._weightInterpolant;\n    if (interpolant === null) {\n      interpolant = mixer._lendControlInterpolant();\n      this._weightInterpolant = interpolant;\n    }\n    const times = interpolant.parameterPositions, values = interpolant.sampleValues;\n    times[0] = now2;\n    values[0] = weightNow;\n    times[1] = now2 + duration;\n    values[1] = weightThen;\n    return this;\n  }\n}\nclass AnimationMixer extends EventDispatcher {\n  constructor(root) {\n    super();\n    this._root = root;\n    this._initMemoryManager();\n    this._accuIndex = 0;\n    this.time = 0;\n    this.timeScale = 1;\n  }\n  _bindAction(action, prototypeAction) {\n    const root = action._localRoot || this._root, tracks = action._clip.tracks, nTracks = tracks.length, bindings = action._propertyBindings, interpolants = action._interpolants, rootUuid = root.uuid, bindingsByRoot = this._bindingsByRootAndName;\n    let bindingsByName = bindingsByRoot[rootUuid];\n    if (bindingsByName === void 0) {\n      bindingsByName = {};\n      bindingsByRoot[rootUuid] = bindingsByName;\n    }\n    for (let i = 0; i !== nTracks; ++i) {\n      const track = tracks[i], trackName = track.name;\n      let binding = bindingsByName[trackName];\n      if (binding !== void 0) {\n        bindings[i] = binding;\n      } else {\n        binding = bindings[i];\n        if (binding !== void 0) {\n          if (binding._cacheIndex === null) {\n            ++binding.referenceCount;\n            this._addInactiveBinding(binding, rootUuid, trackName);\n          }\n          continue;\n        }\n        const path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;\n        binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());\n        ++binding.referenceCount;\n        this._addInactiveBinding(binding, rootUuid, trackName);\n        bindings[i] = binding;\n      }\n      interpolants[i].resultBuffer = binding.buffer;\n    }\n  }\n  _activateAction(action) {\n    if (!this._isActiveAction(action)) {\n      if (action._cacheIndex === null) {\n        const rootUuid = (action._localRoot || this._root).uuid, clipUuid = action._clip.uuid, actionsForClip = this._actionsByClip[clipUuid];\n        this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);\n        this._addInactiveAction(action, clipUuid, rootUuid);\n      }\n      const bindings = action._propertyBindings;\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (binding.useCount++ === 0) {\n          this._lendBinding(binding);\n          binding.saveOriginalState();\n        }\n      }\n      this._lendAction(action);\n    }\n  }\n  _deactivateAction(action) {\n    if (this._isActiveAction(action)) {\n      const bindings = action._propertyBindings;\n      for (let i = 0, n = bindings.length; i !== n; ++i) {\n        const binding = bindings[i];\n        if (--binding.useCount === 0) {\n          binding.restoreOriginalState();\n          this._takeBackBinding(binding);\n        }\n      }\n      this._takeBackAction(action);\n    }\n  }\n  _initMemoryManager() {\n    this._actions = [];\n    this._nActiveActions = 0;\n    this._actionsByClip = {};\n    this._bindings = [];\n    this._nActiveBindings = 0;\n    this._bindingsByRootAndName = {};\n    this._controlInterpolants = [];\n    this._nActiveControlInterpolants = 0;\n    const scope = this;\n    this.stats = {\n      actions: {\n        get total() {\n          return scope._actions.length;\n        },\n        get inUse() {\n          return scope._nActiveActions;\n        }\n      },\n      bindings: {\n        get total() {\n          return scope._bindings.length;\n        },\n        get inUse() {\n          return scope._nActiveBindings;\n        }\n      },\n      controlInterpolants: {\n        get total() {\n          return scope._controlInterpolants.length;\n        },\n        get inUse() {\n          return scope._nActiveControlInterpolants;\n        }\n      }\n    };\n  }\n  _isActiveAction(action) {\n    const index = action._cacheIndex;\n    return index !== null && index < this._nActiveActions;\n  }\n  _addInactiveAction(action, clipUuid, rootUuid) {\n    const actions = this._actions, actionsByClip = this._actionsByClip;\n    let actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip === void 0) {\n      actionsForClip = {\n        knownActions: [action],\n        actionByRoot: {}\n      };\n      action._byClipCacheIndex = 0;\n      actionsByClip[clipUuid] = actionsForClip;\n    } else {\n      const knownActions = actionsForClip.knownActions;\n      action._byClipCacheIndex = knownActions.length;\n      knownActions.push(action);\n    }\n    action._cacheIndex = actions.length;\n    actions.push(action);\n    actionsForClip.actionByRoot[rootUuid] = action;\n  }\n  _removeInactiveAction(action) {\n    const actions = this._actions, lastInactiveAction = actions[actions.length - 1], cacheIndex = action._cacheIndex;\n    lastInactiveAction._cacheIndex = cacheIndex;\n    actions[cacheIndex] = lastInactiveAction;\n    actions.pop();\n    action._cacheIndex = null;\n    const clipUuid = action._clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid], knownActionsForClip = actionsForClip.knownActions, lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1], byClipCacheIndex = action._byClipCacheIndex;\n    lastKnownAction._byClipCacheIndex = byClipCacheIndex;\n    knownActionsForClip[byClipCacheIndex] = lastKnownAction;\n    knownActionsForClip.pop();\n    action._byClipCacheIndex = null;\n    const actionByRoot = actionsForClip.actionByRoot, rootUuid = (action._localRoot || this._root).uuid;\n    delete actionByRoot[rootUuid];\n    if (knownActionsForClip.length === 0) {\n      delete actionsByClip[clipUuid];\n    }\n    this._removeInactiveBindingsForAction(action);\n  }\n  _removeInactiveBindingsForAction(action) {\n    const bindings = action._propertyBindings;\n    for (let i = 0, n = bindings.length; i !== n; ++i) {\n      const binding = bindings[i];\n      if (--binding.referenceCount === 0) {\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n  _lendAction(action) {\n    const actions = this._actions, prevIndex = action._cacheIndex, lastActiveIndex = this._nActiveActions++, firstInactiveAction = actions[lastActiveIndex];\n    action._cacheIndex = lastActiveIndex;\n    actions[lastActiveIndex] = action;\n    firstInactiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = firstInactiveAction;\n  }\n  _takeBackAction(action) {\n    const actions = this._actions, prevIndex = action._cacheIndex, firstInactiveIndex = --this._nActiveActions, lastActiveAction = actions[firstInactiveIndex];\n    action._cacheIndex = firstInactiveIndex;\n    actions[firstInactiveIndex] = action;\n    lastActiveAction._cacheIndex = prevIndex;\n    actions[prevIndex] = lastActiveAction;\n  }\n  _addInactiveBinding(binding, rootUuid, trackName) {\n    const bindingsByRoot = this._bindingsByRootAndName, bindings = this._bindings;\n    let bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName === void 0) {\n      bindingByName = {};\n      bindingsByRoot[rootUuid] = bindingByName;\n    }\n    bindingByName[trackName] = binding;\n    binding._cacheIndex = bindings.length;\n    bindings.push(binding);\n  }\n  _removeInactiveBinding(binding) {\n    const bindings = this._bindings, propBinding = binding.binding, rootUuid = propBinding.rootNode.uuid, trackName = propBinding.path, bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid], lastInactiveBinding = bindings[bindings.length - 1], cacheIndex = binding._cacheIndex;\n    lastInactiveBinding._cacheIndex = cacheIndex;\n    bindings[cacheIndex] = lastInactiveBinding;\n    bindings.pop();\n    delete bindingByName[trackName];\n    if (Object.keys(bindingByName).length === 0) {\n      delete bindingsByRoot[rootUuid];\n    }\n  }\n  _lendBinding(binding) {\n    const bindings = this._bindings, prevIndex = binding._cacheIndex, lastActiveIndex = this._nActiveBindings++, firstInactiveBinding = bindings[lastActiveIndex];\n    binding._cacheIndex = lastActiveIndex;\n    bindings[lastActiveIndex] = binding;\n    firstInactiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = firstInactiveBinding;\n  }\n  _takeBackBinding(binding) {\n    const bindings = this._bindings, prevIndex = binding._cacheIndex, firstInactiveIndex = --this._nActiveBindings, lastActiveBinding = bindings[firstInactiveIndex];\n    binding._cacheIndex = firstInactiveIndex;\n    bindings[firstInactiveIndex] = binding;\n    lastActiveBinding._cacheIndex = prevIndex;\n    bindings[prevIndex] = lastActiveBinding;\n  }\n  _lendControlInterpolant() {\n    const interpolants = this._controlInterpolants, lastActiveIndex = this._nActiveControlInterpolants++;\n    let interpolant = interpolants[lastActiveIndex];\n    if (interpolant === void 0) {\n      interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer);\n      interpolant.__cacheIndex = lastActiveIndex;\n      interpolants[lastActiveIndex] = interpolant;\n    }\n    return interpolant;\n  }\n  _takeBackControlInterpolant(interpolant) {\n    const interpolants = this._controlInterpolants, prevIndex = interpolant.__cacheIndex, firstInactiveIndex = --this._nActiveControlInterpolants, lastActiveInterpolant = interpolants[firstInactiveIndex];\n    interpolant.__cacheIndex = firstInactiveIndex;\n    interpolants[firstInactiveIndex] = interpolant;\n    lastActiveInterpolant.__cacheIndex = prevIndex;\n    interpolants[prevIndex] = lastActiveInterpolant;\n  }\n  clipAction(clip, optionalRoot, blendMode) {\n    const root = optionalRoot || this._root, rootUuid = root.uuid;\n    let clipObject = typeof clip === \"string\" ? AnimationClip.findByName(root, clip) : clip;\n    const clipUuid = clipObject !== null ? clipObject.uuid : clip;\n    const actionsForClip = this._actionsByClip[clipUuid];\n    let prototypeAction = null;\n    if (blendMode === void 0) {\n      if (clipObject !== null) {\n        blendMode = clipObject.blendMode;\n      } else {\n        blendMode = NormalAnimationBlendMode;\n      }\n    }\n    if (actionsForClip !== void 0) {\n      const existingAction = actionsForClip.actionByRoot[rootUuid];\n      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {\n        return existingAction;\n      }\n      prototypeAction = actionsForClip.knownActions[0];\n      if (clipObject === null)\n        clipObject = prototypeAction._clip;\n    }\n    if (clipObject === null)\n      return null;\n    const newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);\n    this._bindAction(newAction, prototypeAction);\n    this._addInactiveAction(newAction, clipUuid, rootUuid);\n    return newAction;\n  }\n  existingAction(clip, optionalRoot) {\n    const root = optionalRoot || this._root, rootUuid = root.uuid, clipObject = typeof clip === \"string\" ? AnimationClip.findByName(root, clip) : clip, clipUuid = clipObject ? clipObject.uuid : clip, actionsForClip = this._actionsByClip[clipUuid];\n    if (actionsForClip !== void 0) {\n      return actionsForClip.actionByRoot[rootUuid] || null;\n    }\n    return null;\n  }\n  stopAllAction() {\n    const actions = this._actions, nActions = this._nActiveActions;\n    for (let i = nActions - 1; i >= 0; --i) {\n      actions[i].stop();\n    }\n    return this;\n  }\n  update(deltaTime) {\n    deltaTime *= this.timeScale;\n    const actions = this._actions, nActions = this._nActiveActions, time = this.time += deltaTime, timeDirection = Math.sign(deltaTime), accuIndex = this._accuIndex ^= 1;\n    for (let i = 0; i !== nActions; ++i) {\n      const action = actions[i];\n      action._update(time, deltaTime, timeDirection, accuIndex);\n    }\n    const bindings = this._bindings, nBindings = this._nActiveBindings;\n    for (let i = 0; i !== nBindings; ++i) {\n      bindings[i].apply(accuIndex);\n    }\n    return this;\n  }\n  setTime(timeInSeconds) {\n    this.time = 0;\n    for (let i = 0; i < this._actions.length; i++) {\n      this._actions[i].time = 0;\n    }\n    return this.update(timeInSeconds);\n  }\n  getRoot() {\n    return this._root;\n  }\n  uncacheClip(clip) {\n    const actions = this._actions, clipUuid = clip.uuid, actionsByClip = this._actionsByClip, actionsForClip = actionsByClip[clipUuid];\n    if (actionsForClip !== void 0) {\n      const actionsToRemove = actionsForClip.knownActions;\n      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {\n        const action = actionsToRemove[i];\n        this._deactivateAction(action);\n        const cacheIndex = action._cacheIndex, lastInactiveAction = actions[actions.length - 1];\n        action._cacheIndex = null;\n        action._byClipCacheIndex = null;\n        lastInactiveAction._cacheIndex = cacheIndex;\n        actions[cacheIndex] = lastInactiveAction;\n        actions.pop();\n        this._removeInactiveBindingsForAction(action);\n      }\n      delete actionsByClip[clipUuid];\n    }\n  }\n  uncacheRoot(root) {\n    const rootUuid = root.uuid, actionsByClip = this._actionsByClip;\n    for (const clipUuid in actionsByClip) {\n      const actionByRoot = actionsByClip[clipUuid].actionByRoot, action = actionByRoot[rootUuid];\n      if (action !== void 0) {\n        this._deactivateAction(action);\n        this._removeInactiveAction(action);\n      }\n    }\n    const bindingsByRoot = this._bindingsByRootAndName, bindingByName = bindingsByRoot[rootUuid];\n    if (bindingByName !== void 0) {\n      for (const trackName in bindingByName) {\n        const binding = bindingByName[trackName];\n        binding.restoreOriginalState();\n        this._removeInactiveBinding(binding);\n      }\n    }\n  }\n  uncacheAction(clip, optionalRoot) {\n    const action = this.existingAction(clip, optionalRoot);\n    if (action !== null) {\n      this._deactivateAction(action);\n      this._removeInactiveAction(action);\n    }\n  }\n}\nAnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array(1);\nclass Uniform {\n  constructor(value) {\n    if (typeof value === \"string\") {\n      console.warn(\"THREE.Uniform: Type parameter is no longer needed.\");\n      value = arguments[1];\n    }\n    this.value = value;\n  }\n  clone() {\n    return new Uniform(this.value.clone === void 0 ? this.value : this.value.clone());\n  }\n}\nclass InstancedInterleavedBuffer extends InterleavedBuffer {\n  constructor(array, stride, meshPerAttribute = 1) {\n    super(array, stride);\n    this.meshPerAttribute = meshPerAttribute || 1;\n  }\n  copy(source) {\n    super.copy(source);\n    this.meshPerAttribute = source.meshPerAttribute;\n    return this;\n  }\n  clone(data) {\n    const ib = super.clone(data);\n    ib.meshPerAttribute = this.meshPerAttribute;\n    return ib;\n  }\n  toJSON(data) {\n    const json = super.toJSON(data);\n    json.isInstancedInterleavedBuffer = true;\n    json.meshPerAttribute = this.meshPerAttribute;\n    return json;\n  }\n}\nInstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;\nclass GLBufferAttribute {\n  constructor(buffer, type, itemSize, elementSize, count) {\n    this.buffer = buffer;\n    this.type = type;\n    this.itemSize = itemSize;\n    this.elementSize = elementSize;\n    this.count = count;\n    this.version = 0;\n  }\n  set needsUpdate(value) {\n    if (value === true)\n      this.version++;\n  }\n  setBuffer(buffer) {\n    this.buffer = buffer;\n    return this;\n  }\n  setType(type, elementSize) {\n    this.type = type;\n    this.elementSize = elementSize;\n    return this;\n  }\n  setItemSize(itemSize) {\n    this.itemSize = itemSize;\n    return this;\n  }\n  setCount(count) {\n    this.count = count;\n    return this;\n  }\n}\nGLBufferAttribute.prototype.isGLBufferAttribute = true;\nclass Raycaster {\n  constructor(origin, direction, near = 0, far = Infinity) {\n    this.ray = new Ray(origin, direction);\n    this.near = near;\n    this.far = far;\n    this.camera = null;\n    this.layers = new Layers();\n    this.params = {\n      Mesh: {},\n      Line: {threshold: 1},\n      LOD: {},\n      Points: {threshold: 1},\n      Sprite: {}\n    };\n  }\n  set(origin, direction) {\n    this.ray.set(origin, direction);\n  }\n  setFromCamera(coords, camera) {\n    if (camera && camera.isPerspectiveCamera) {\n      this.ray.origin.setFromMatrixPosition(camera.matrixWorld);\n      this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();\n      this.camera = camera;\n    } else if (camera && camera.isOrthographicCamera) {\n      this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);\n      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);\n      this.camera = camera;\n    } else {\n      console.error(\"THREE.Raycaster: Unsupported camera type: \" + camera.type);\n    }\n  }\n  intersectObject(object, recursive = false, intersects2 = []) {\n    intersectObject(object, this, intersects2, recursive);\n    intersects2.sort(ascSort);\n    return intersects2;\n  }\n  intersectObjects(objects, recursive = false, intersects2 = []) {\n    for (let i = 0, l = objects.length; i < l; i++) {\n      intersectObject(objects[i], this, intersects2, recursive);\n    }\n    intersects2.sort(ascSort);\n    return intersects2;\n  }\n}\nfunction ascSort(a, b) {\n  return a.distance - b.distance;\n}\nfunction intersectObject(object, raycaster, intersects2, recursive) {\n  if (object.layers.test(raycaster.layers)) {\n    object.raycast(raycaster, intersects2);\n  }\n  if (recursive === true) {\n    const children = object.children;\n    for (let i = 0, l = children.length; i < l; i++) {\n      intersectObject(children[i], raycaster, intersects2, true);\n    }\n  }\n}\nclass Spherical {\n  constructor(radius = 1, phi = 0, theta = 0) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n  set(radius, phi, theta) {\n    this.radius = radius;\n    this.phi = phi;\n    this.theta = theta;\n    return this;\n  }\n  copy(other) {\n    this.radius = other.radius;\n    this.phi = other.phi;\n    this.theta = other.theta;\n    return this;\n  }\n  makeSafe() {\n    const EPS = 1e-6;\n    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi));\n    return this;\n  }\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + y * y + z * z);\n    if (this.radius === 0) {\n      this.theta = 0;\n      this.phi = 0;\n    } else {\n      this.theta = Math.atan2(x, z);\n      this.phi = Math.acos(clamp(y / this.radius, -1, 1));\n    }\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass Cylindrical {\n  constructor(radius = 1, theta = 0, y = 0) {\n    this.radius = radius;\n    this.theta = theta;\n    this.y = y;\n    return this;\n  }\n  set(radius, theta, y) {\n    this.radius = radius;\n    this.theta = theta;\n    this.y = y;\n    return this;\n  }\n  copy(other) {\n    this.radius = other.radius;\n    this.theta = other.theta;\n    this.y = other.y;\n    return this;\n  }\n  setFromVector3(v) {\n    return this.setFromCartesianCoords(v.x, v.y, v.z);\n  }\n  setFromCartesianCoords(x, y, z) {\n    this.radius = Math.sqrt(x * x + z * z);\n    this.theta = Math.atan2(x, z);\n    this.y = y;\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nconst _vector$4 = /* @__PURE__ */ new Vector2();\nclass Box2 {\n  constructor(min = new Vector2(Infinity, Infinity), max = new Vector2(-Infinity, -Infinity)) {\n    this.min = min;\n    this.max = max;\n  }\n  set(min, max) {\n    this.min.copy(min);\n    this.max.copy(max);\n    return this;\n  }\n  setFromPoints(points) {\n    this.makeEmpty();\n    for (let i = 0, il = points.length; i < il; i++) {\n      this.expandByPoint(points[i]);\n    }\n    return this;\n  }\n  setFromCenterAndSize(center, size) {\n    const halfSize = _vector$4.copy(size).multiplyScalar(0.5);\n    this.min.copy(center).sub(halfSize);\n    this.max.copy(center).add(halfSize);\n    return this;\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n  copy(box) {\n    this.min.copy(box.min);\n    this.max.copy(box.max);\n    return this;\n  }\n  makeEmpty() {\n    this.min.x = this.min.y = Infinity;\n    this.max.x = this.max.y = -Infinity;\n    return this;\n  }\n  isEmpty() {\n    return this.max.x < this.min.x || this.max.y < this.min.y;\n  }\n  getCenter(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box2: .getCenter() target is now required\");\n      target = new Vector2();\n    }\n    return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n  }\n  getSize(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box2: .getSize() target is now required\");\n      target = new Vector2();\n    }\n    return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);\n  }\n  expandByPoint(point) {\n    this.min.min(point);\n    this.max.max(point);\n    return this;\n  }\n  expandByVector(vector) {\n    this.min.sub(vector);\n    this.max.add(vector);\n    return this;\n  }\n  expandByScalar(scalar) {\n    this.min.addScalar(-scalar);\n    this.max.addScalar(scalar);\n    return this;\n  }\n  containsPoint(point) {\n    return point.x < this.min.x || point.x > this.max.x || point.y < this.min.y || point.y > this.max.y ? false : true;\n  }\n  containsBox(box) {\n    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;\n  }\n  getParameter(point, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box2: .getParameter() target is now required\");\n      target = new Vector2();\n    }\n    return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));\n  }\n  intersectsBox(box) {\n    return box.max.x < this.min.x || box.min.x > this.max.x || box.max.y < this.min.y || box.min.y > this.max.y ? false : true;\n  }\n  clampPoint(point, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Box2: .clampPoint() target is now required\");\n      target = new Vector2();\n    }\n    return target.copy(point).clamp(this.min, this.max);\n  }\n  distanceToPoint(point) {\n    const clampedPoint = _vector$4.copy(point).clamp(this.min, this.max);\n    return clampedPoint.sub(point).length();\n  }\n  intersect(box) {\n    this.min.max(box.min);\n    this.max.min(box.max);\n    return this;\n  }\n  union(box) {\n    this.min.min(box.min);\n    this.max.max(box.max);\n    return this;\n  }\n  translate(offset) {\n    this.min.add(offset);\n    this.max.add(offset);\n    return this;\n  }\n  equals(box) {\n    return box.min.equals(this.min) && box.max.equals(this.max);\n  }\n}\nBox2.prototype.isBox2 = true;\nconst _startP = /* @__PURE__ */ new Vector3();\nconst _startEnd = /* @__PURE__ */ new Vector3();\nclass Line3 {\n  constructor(start = new Vector3(), end = new Vector3()) {\n    this.start = start;\n    this.end = end;\n  }\n  set(start, end) {\n    this.start.copy(start);\n    this.end.copy(end);\n    return this;\n  }\n  copy(line) {\n    this.start.copy(line.start);\n    this.end.copy(line.end);\n    return this;\n  }\n  getCenter(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Line3: .getCenter() target is now required\");\n      target = new Vector3();\n    }\n    return target.addVectors(this.start, this.end).multiplyScalar(0.5);\n  }\n  delta(target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Line3: .delta() target is now required\");\n      target = new Vector3();\n    }\n    return target.subVectors(this.end, this.start);\n  }\n  distanceSq() {\n    return this.start.distanceToSquared(this.end);\n  }\n  distance() {\n    return this.start.distanceTo(this.end);\n  }\n  at(t, target) {\n    if (target === void 0) {\n      console.warn(\"THREE.Line3: .at() target is now required\");\n      target = new Vector3();\n    }\n    return this.delta(target).multiplyScalar(t).add(this.start);\n  }\n  closestPointToPointParameter(point, clampToLine) {\n    _startP.subVectors(point, this.start);\n    _startEnd.subVectors(this.end, this.start);\n    const startEnd2 = _startEnd.dot(_startEnd);\n    const startEnd_startP = _startEnd.dot(_startP);\n    let t = startEnd_startP / startEnd2;\n    if (clampToLine) {\n      t = clamp(t, 0, 1);\n    }\n    return t;\n  }\n  closestPointToPoint(point, clampToLine, target) {\n    const t = this.closestPointToPointParameter(point, clampToLine);\n    if (target === void 0) {\n      console.warn(\"THREE.Line3: .closestPointToPoint() target is now required\");\n      target = new Vector3();\n    }\n    return this.delta(target).multiplyScalar(t).add(this.start);\n  }\n  applyMatrix4(matrix) {\n    this.start.applyMatrix4(matrix);\n    this.end.applyMatrix4(matrix);\n    return this;\n  }\n  equals(line) {\n    return line.start.equals(this.start) && line.end.equals(this.end);\n  }\n  clone() {\n    return new this.constructor().copy(this);\n  }\n}\nclass ImmediateRenderObject extends Object3D {\n  constructor(material) {\n    super();\n    this.material = material;\n    this.render = function() {\n    };\n    this.hasPositions = false;\n    this.hasNormals = false;\n    this.hasColors = false;\n    this.hasUvs = false;\n    this.positionArray = null;\n    this.normalArray = null;\n    this.colorArray = null;\n    this.uvArray = null;\n    this.count = 0;\n  }\n}\nImmediateRenderObject.prototype.isImmediateRenderObject = true;\nconst _vector$3 = /* @__PURE__ */ new Vector3();\nclass SpotLightHelper extends Object3D {\n  constructor(light, color) {\n    super();\n    this.light = light;\n    this.light.updateMatrixWorld();\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.color = color;\n    const geometry = new BufferGeometry();\n    const positions = [\n      0,\n      0,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      -1,\n      0,\n      1,\n      0,\n      0,\n      0,\n      0,\n      1,\n      1,\n      0,\n      0,\n      0,\n      0,\n      -1,\n      1\n    ];\n    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {\n      const p1 = i / l * Math.PI * 2;\n      const p2 = j / l * Math.PI * 2;\n      positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);\n    }\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    const material = new LineBasicMaterial({fog: false, toneMapped: false});\n    this.cone = new LineSegments(geometry, material);\n    this.add(this.cone);\n    this.update();\n  }\n  dispose() {\n    this.cone.geometry.dispose();\n    this.cone.material.dispose();\n  }\n  update() {\n    this.light.updateMatrixWorld();\n    const coneLength = this.light.distance ? this.light.distance : 1e3;\n    const coneWidth = coneLength * Math.tan(this.light.angle);\n    this.cone.scale.set(coneWidth, coneWidth, coneLength);\n    _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);\n    this.cone.lookAt(_vector$3);\n    if (this.color !== void 0) {\n      this.cone.material.color.set(this.color);\n    } else {\n      this.cone.material.color.copy(this.light.color);\n    }\n  }\n}\nconst _vector$2 = /* @__PURE__ */ new Vector3();\nconst _boneMatrix = /* @__PURE__ */ new Matrix4();\nconst _matrixWorldInv = /* @__PURE__ */ new Matrix4();\nclass SkeletonHelper extends LineSegments {\n  constructor(object) {\n    const bones = getBoneList(object);\n    const geometry = new BufferGeometry();\n    const vertices = [];\n    const colors = [];\n    const color1 = new Color(0, 0, 1);\n    const color2 = new Color(0, 1, 0);\n    for (let i = 0; i < bones.length; i++) {\n      const bone = bones[i];\n      if (bone.parent && bone.parent.isBone) {\n        vertices.push(0, 0, 0);\n        vertices.push(0, 0, 0);\n        colors.push(color1.r, color1.g, color1.b);\n        colors.push(color2.r, color2.g, color2.b);\n      }\n    }\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true});\n    super(geometry, material);\n    this.type = \"SkeletonHelper\";\n    this.isSkeletonHelper = true;\n    this.root = object;\n    this.bones = bones;\n    this.matrix = object.matrixWorld;\n    this.matrixAutoUpdate = false;\n  }\n  updateMatrixWorld(force) {\n    const bones = this.bones;\n    const geometry = this.geometry;\n    const position = geometry.getAttribute(\"position\");\n    _matrixWorldInv.copy(this.root.matrixWorld).invert();\n    for (let i = 0, j = 0; i < bones.length; i++) {\n      const bone = bones[i];\n      if (bone.parent && bone.parent.isBone) {\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n        position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);\n        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);\n        _vector$2.setFromMatrixPosition(_boneMatrix);\n        position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);\n        j += 2;\n      }\n    }\n    geometry.getAttribute(\"position\").needsUpdate = true;\n    super.updateMatrixWorld(force);\n  }\n}\nfunction getBoneList(object) {\n  const boneList = [];\n  if (object && object.isBone) {\n    boneList.push(object);\n  }\n  for (let i = 0; i < object.children.length; i++) {\n    boneList.push.apply(boneList, getBoneList(object.children[i]));\n  }\n  return boneList;\n}\nclass PointLightHelper extends Mesh {\n  constructor(light, sphereSize, color) {\n    const geometry = new SphereGeometry(sphereSize, 4, 2);\n    const material = new MeshBasicMaterial({wireframe: true, fog: false, toneMapped: false});\n    super(geometry, material);\n    this.light = light;\n    this.light.updateMatrixWorld();\n    this.color = color;\n    this.type = \"PointLightHelper\";\n    this.matrix = this.light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.update();\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n  update() {\n    if (this.color !== void 0) {\n      this.material.color.set(this.color);\n    } else {\n      this.material.color.copy(this.light.color);\n    }\n  }\n}\nconst _vector$1 = /* @__PURE__ */ new Vector3();\nconst _color1 = /* @__PURE__ */ new Color();\nconst _color2 = /* @__PURE__ */ new Color();\nclass HemisphereLightHelper extends Object3D {\n  constructor(light, size, color) {\n    super();\n    this.light = light;\n    this.light.updateMatrixWorld();\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.color = color;\n    const geometry = new OctahedronGeometry(size);\n    geometry.rotateY(Math.PI * 0.5);\n    this.material = new MeshBasicMaterial({wireframe: true, fog: false, toneMapped: false});\n    if (this.color === void 0)\n      this.material.vertexColors = true;\n    const position = geometry.getAttribute(\"position\");\n    const colors = new Float32Array(position.count * 3);\n    geometry.setAttribute(\"color\", new BufferAttribute(colors, 3));\n    this.add(new Mesh(geometry, this.material));\n    this.update();\n  }\n  dispose() {\n    this.children[0].geometry.dispose();\n    this.children[0].material.dispose();\n  }\n  update() {\n    const mesh = this.children[0];\n    if (this.color !== void 0) {\n      this.material.color.set(this.color);\n    } else {\n      const colors = mesh.geometry.getAttribute(\"color\");\n      _color1.copy(this.light.color);\n      _color2.copy(this.light.groundColor);\n      for (let i = 0, l = colors.count; i < l; i++) {\n        const color = i < l / 2 ? _color1 : _color2;\n        colors.setXYZ(i, color.r, color.g, color.b);\n      }\n      colors.needsUpdate = true;\n    }\n    mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());\n  }\n}\nclass GridHelper extends LineSegments {\n  constructor(size = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    const center = divisions / 2;\n    const step = size / divisions;\n    const halfSize = size / 2;\n    const vertices = [], colors = [];\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n      vertices.push(-halfSize, 0, k, halfSize, 0, k);\n      vertices.push(k, 0, -halfSize, k, 0, halfSize);\n      const color = i === center ? color1 : color2;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n      color.toArray(colors, j);\n      j += 3;\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});\n    super(geometry, material);\n    this.type = \"GridHelper\";\n  }\n}\nclass PolarGridHelper extends LineSegments {\n  constructor(radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 4473924, color2 = 8947848) {\n    color1 = new Color(color1);\n    color2 = new Color(color2);\n    const vertices = [];\n    const colors = [];\n    for (let i = 0; i <= radials; i++) {\n      const v = i / radials * (Math.PI * 2);\n      const x = Math.sin(v) * radius;\n      const z = Math.cos(v) * radius;\n      vertices.push(0, 0, 0);\n      vertices.push(x, 0, z);\n      const color = i & 1 ? color1 : color2;\n      colors.push(color.r, color.g, color.b);\n      colors.push(color.r, color.g, color.b);\n    }\n    for (let i = 0; i <= circles; i++) {\n      const color = i & 1 ? color1 : color2;\n      const r = radius - radius / circles * i;\n      for (let j = 0; j < divisions; j++) {\n        let v = j / divisions * (Math.PI * 2);\n        let x = Math.sin(v) * r;\n        let z = Math.cos(v) * r;\n        vertices.push(x, 0, z);\n        colors.push(color.r, color.g, color.b);\n        v = (j + 1) / divisions * (Math.PI * 2);\n        x = Math.sin(v) * r;\n        z = Math.cos(v) * r;\n        vertices.push(x, 0, z);\n        colors.push(color.r, color.g, color.b);\n      }\n    }\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});\n    super(geometry, material);\n    this.type = \"PolarGridHelper\";\n  }\n}\nconst _v1 = /* @__PURE__ */ new Vector3();\nconst _v2 = /* @__PURE__ */ new Vector3();\nconst _v3 = /* @__PURE__ */ new Vector3();\nclass DirectionalLightHelper extends Object3D {\n  constructor(light, size, color) {\n    super();\n    this.light = light;\n    this.light.updateMatrixWorld();\n    this.matrix = light.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.color = color;\n    if (size === void 0)\n      size = 1;\n    let geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute([\n      -size,\n      size,\n      0,\n      size,\n      size,\n      0,\n      size,\n      -size,\n      0,\n      -size,\n      -size,\n      0,\n      -size,\n      size,\n      0\n    ], 3));\n    const material = new LineBasicMaterial({fog: false, toneMapped: false});\n    this.lightPlane = new Line(geometry, material);\n    this.add(this.lightPlane);\n    geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));\n    this.targetLine = new Line(geometry, material);\n    this.add(this.targetLine);\n    this.update();\n  }\n  dispose() {\n    this.lightPlane.geometry.dispose();\n    this.lightPlane.material.dispose();\n    this.targetLine.geometry.dispose();\n    this.targetLine.material.dispose();\n  }\n  update() {\n    _v1.setFromMatrixPosition(this.light.matrixWorld);\n    _v2.setFromMatrixPosition(this.light.target.matrixWorld);\n    _v3.subVectors(_v2, _v1);\n    this.lightPlane.lookAt(_v2);\n    if (this.color !== void 0) {\n      this.lightPlane.material.color.set(this.color);\n      this.targetLine.material.color.set(this.color);\n    } else {\n      this.lightPlane.material.color.copy(this.light.color);\n      this.targetLine.material.color.copy(this.light.color);\n    }\n    this.targetLine.lookAt(_v2);\n    this.targetLine.scale.z = _v3.length();\n  }\n}\nconst _vector = /* @__PURE__ */ new Vector3();\nconst _camera = /* @__PURE__ */ new Camera();\nclass CameraHelper extends LineSegments {\n  constructor(camera) {\n    const geometry = new BufferGeometry();\n    const material = new LineBasicMaterial({color: 16777215, vertexColors: true, toneMapped: false});\n    const vertices = [];\n    const colors = [];\n    const pointMap = {};\n    const colorFrustum = new Color(16755200);\n    const colorCone = new Color(16711680);\n    const colorUp = new Color(43775);\n    const colorTarget = new Color(16777215);\n    const colorCross = new Color(3355443);\n    addLine(\"n1\", \"n2\", colorFrustum);\n    addLine(\"n2\", \"n4\", colorFrustum);\n    addLine(\"n4\", \"n3\", colorFrustum);\n    addLine(\"n3\", \"n1\", colorFrustum);\n    addLine(\"f1\", \"f2\", colorFrustum);\n    addLine(\"f2\", \"f4\", colorFrustum);\n    addLine(\"f4\", \"f3\", colorFrustum);\n    addLine(\"f3\", \"f1\", colorFrustum);\n    addLine(\"n1\", \"f1\", colorFrustum);\n    addLine(\"n2\", \"f2\", colorFrustum);\n    addLine(\"n3\", \"f3\", colorFrustum);\n    addLine(\"n4\", \"f4\", colorFrustum);\n    addLine(\"p\", \"n1\", colorCone);\n    addLine(\"p\", \"n2\", colorCone);\n    addLine(\"p\", \"n3\", colorCone);\n    addLine(\"p\", \"n4\", colorCone);\n    addLine(\"u1\", \"u2\", colorUp);\n    addLine(\"u2\", \"u3\", colorUp);\n    addLine(\"u3\", \"u1\", colorUp);\n    addLine(\"c\", \"t\", colorTarget);\n    addLine(\"p\", \"c\", colorCross);\n    addLine(\"cn1\", \"cn2\", colorCross);\n    addLine(\"cn3\", \"cn4\", colorCross);\n    addLine(\"cf1\", \"cf2\", colorCross);\n    addLine(\"cf3\", \"cf4\", colorCross);\n    function addLine(a, b, color) {\n      addPoint(a, color);\n      addPoint(b, color);\n    }\n    function addPoint(id, color) {\n      vertices.push(0, 0, 0);\n      colors.push(color.r, color.g, color.b);\n      if (pointMap[id] === void 0) {\n        pointMap[id] = [];\n      }\n      pointMap[id].push(vertices.length / 3 - 1);\n    }\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n    super(geometry, material);\n    this.type = \"CameraHelper\";\n    this.camera = camera;\n    if (this.camera.updateProjectionMatrix)\n      this.camera.updateProjectionMatrix();\n    this.matrix = camera.matrixWorld;\n    this.matrixAutoUpdate = false;\n    this.pointMap = pointMap;\n    this.update();\n  }\n  update() {\n    const geometry = this.geometry;\n    const pointMap = this.pointMap;\n    const w = 1, h = 1;\n    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);\n    setPoint(\"c\", pointMap, geometry, _camera, 0, 0, -1);\n    setPoint(\"t\", pointMap, geometry, _camera, 0, 0, 1);\n    setPoint(\"n1\", pointMap, geometry, _camera, -w, -h, -1);\n    setPoint(\"n2\", pointMap, geometry, _camera, w, -h, -1);\n    setPoint(\"n3\", pointMap, geometry, _camera, -w, h, -1);\n    setPoint(\"n4\", pointMap, geometry, _camera, w, h, -1);\n    setPoint(\"f1\", pointMap, geometry, _camera, -w, -h, 1);\n    setPoint(\"f2\", pointMap, geometry, _camera, w, -h, 1);\n    setPoint(\"f3\", pointMap, geometry, _camera, -w, h, 1);\n    setPoint(\"f4\", pointMap, geometry, _camera, w, h, 1);\n    setPoint(\"u1\", pointMap, geometry, _camera, w * 0.7, h * 1.1, -1);\n    setPoint(\"u2\", pointMap, geometry, _camera, -w * 0.7, h * 1.1, -1);\n    setPoint(\"u3\", pointMap, geometry, _camera, 0, h * 2, -1);\n    setPoint(\"cf1\", pointMap, geometry, _camera, -w, 0, 1);\n    setPoint(\"cf2\", pointMap, geometry, _camera, w, 0, 1);\n    setPoint(\"cf3\", pointMap, geometry, _camera, 0, -h, 1);\n    setPoint(\"cf4\", pointMap, geometry, _camera, 0, h, 1);\n    setPoint(\"cn1\", pointMap, geometry, _camera, -w, 0, -1);\n    setPoint(\"cn2\", pointMap, geometry, _camera, w, 0, -1);\n    setPoint(\"cn3\", pointMap, geometry, _camera, 0, -h, -1);\n    setPoint(\"cn4\", pointMap, geometry, _camera, 0, h, -1);\n    geometry.getAttribute(\"position\").needsUpdate = true;\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nfunction setPoint(point, pointMap, geometry, camera, x, y, z) {\n  _vector.set(x, y, z).unproject(camera);\n  const points = pointMap[point];\n  if (points !== void 0) {\n    const position = geometry.getAttribute(\"position\");\n    for (let i = 0, l = points.length; i < l; i++) {\n      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);\n    }\n  }\n}\nconst _box = /* @__PURE__ */ new Box3();\nclass BoxHelper extends LineSegments {\n  constructor(object, color = 16776960) {\n    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n    const positions = new Float32Array(8 * 3);\n    const geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.setAttribute(\"position\", new BufferAttribute(positions, 3));\n    super(geometry, new LineBasicMaterial({color, toneMapped: false}));\n    this.object = object;\n    this.type = \"BoxHelper\";\n    this.matrixAutoUpdate = false;\n    this.update();\n  }\n  update(object) {\n    if (object !== void 0) {\n      console.warn(\"THREE.BoxHelper: .update() has no longer arguments.\");\n    }\n    if (this.object !== void 0) {\n      _box.setFromObject(this.object);\n    }\n    if (_box.isEmpty())\n      return;\n    const min = _box.min;\n    const max = _box.max;\n    const position = this.geometry.attributes.position;\n    const array = position.array;\n    array[0] = max.x;\n    array[1] = max.y;\n    array[2] = max.z;\n    array[3] = min.x;\n    array[4] = max.y;\n    array[5] = max.z;\n    array[6] = min.x;\n    array[7] = min.y;\n    array[8] = max.z;\n    array[9] = max.x;\n    array[10] = min.y;\n    array[11] = max.z;\n    array[12] = max.x;\n    array[13] = max.y;\n    array[14] = min.z;\n    array[15] = min.x;\n    array[16] = max.y;\n    array[17] = min.z;\n    array[18] = min.x;\n    array[19] = min.y;\n    array[20] = min.z;\n    array[21] = max.x;\n    array[22] = min.y;\n    array[23] = min.z;\n    position.needsUpdate = true;\n    this.geometry.computeBoundingSphere();\n  }\n  setFromObject(object) {\n    this.object = object;\n    this.update();\n    return this;\n  }\n  copy(source) {\n    LineSegments.prototype.copy.call(this, source);\n    this.object = source.object;\n    return this;\n  }\n}\nclass Box3Helper extends LineSegments {\n  constructor(box, color = 16776960) {\n    const indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);\n    const positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];\n    const geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(indices, 1));\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    super(geometry, new LineBasicMaterial({color, toneMapped: false}));\n    this.box = box;\n    this.type = \"Box3Helper\";\n    this.geometry.computeBoundingSphere();\n  }\n  updateMatrixWorld(force) {\n    const box = this.box;\n    if (box.isEmpty())\n      return;\n    box.getCenter(this.position);\n    box.getSize(this.scale);\n    this.scale.multiplyScalar(0.5);\n    super.updateMatrixWorld(force);\n  }\n}\nclass PlaneHelper extends Line {\n  constructor(plane, size = 1, hex = 16776960) {\n    const color = hex;\n    const positions = [1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0];\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(positions, 3));\n    geometry.computeBoundingSphere();\n    super(geometry, new LineBasicMaterial({color, toneMapped: false}));\n    this.type = \"PlaneHelper\";\n    this.plane = plane;\n    this.size = size;\n    const positions2 = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1];\n    const geometry2 = new BufferGeometry();\n    geometry2.setAttribute(\"position\", new Float32BufferAttribute(positions2, 3));\n    geometry2.computeBoundingSphere();\n    this.add(new Mesh(geometry2, new MeshBasicMaterial({color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false})));\n  }\n  updateMatrixWorld(force) {\n    let scale = -this.plane.constant;\n    if (Math.abs(scale) < 1e-8)\n      scale = 1e-8;\n    this.scale.set(0.5 * this.size, 0.5 * this.size, scale);\n    this.children[0].material.side = scale < 0 ? BackSide : FrontSide;\n    this.lookAt(this.plane.normal);\n    super.updateMatrixWorld(force);\n  }\n}\nconst _axis = /* @__PURE__ */ new Vector3();\nlet _lineGeometry, _coneGeometry;\nclass ArrowHelper extends Object3D {\n  constructor(dir = new Vector3(0, 0, 1), origin = new Vector3(0, 0, 0), length = 1, color = 16776960, headLength = length * 0.2, headWidth = headLength * 0.2) {\n    super();\n    this.type = \"ArrowHelper\";\n    if (_lineGeometry === void 0) {\n      _lineGeometry = new BufferGeometry();\n      _lineGeometry.setAttribute(\"position\", new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));\n      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);\n      _coneGeometry.translate(0, -0.5, 0);\n    }\n    this.position.copy(origin);\n    this.line = new Line(_lineGeometry, new LineBasicMaterial({color, toneMapped: false}));\n    this.line.matrixAutoUpdate = false;\n    this.add(this.line);\n    this.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({color, toneMapped: false}));\n    this.cone.matrixAutoUpdate = false;\n    this.add(this.cone);\n    this.setDirection(dir);\n    this.setLength(length, headLength, headWidth);\n  }\n  setDirection(dir) {\n    if (dir.y > 0.99999) {\n      this.quaternion.set(0, 0, 0, 1);\n    } else if (dir.y < -0.99999) {\n      this.quaternion.set(1, 0, 0, 0);\n    } else {\n      _axis.set(dir.z, 0, -dir.x).normalize();\n      const radians = Math.acos(dir.y);\n      this.quaternion.setFromAxisAngle(_axis, radians);\n    }\n  }\n  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {\n    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1);\n    this.line.updateMatrix();\n    this.cone.scale.set(headWidth, headLength, headWidth);\n    this.cone.position.y = length;\n    this.cone.updateMatrix();\n  }\n  setColor(color) {\n    this.line.material.color.set(color);\n    this.cone.material.color.set(color);\n  }\n  copy(source) {\n    super.copy(source, false);\n    this.line.copy(source.line);\n    this.cone.copy(source.cone);\n    return this;\n  }\n}\nclass AxesHelper extends LineSegments {\n  constructor(size = 1) {\n    const vertices = [\n      0,\n      0,\n      0,\n      size,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      size,\n      0,\n      0,\n      0,\n      0,\n      0,\n      0,\n      size\n    ];\n    const colors = [\n      1,\n      0,\n      0,\n      1,\n      0.6,\n      0,\n      0,\n      1,\n      0,\n      0.6,\n      1,\n      0,\n      0,\n      0,\n      1,\n      0,\n      0.6,\n      1\n    ];\n    const geometry = new BufferGeometry();\n    geometry.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n    geometry.setAttribute(\"color\", new Float32BufferAttribute(colors, 3));\n    const material = new LineBasicMaterial({vertexColors: true, toneMapped: false});\n    super(geometry, material);\n    this.type = \"AxesHelper\";\n  }\n  dispose() {\n    this.geometry.dispose();\n    this.material.dispose();\n  }\n}\nconst _floatView = new Float32Array(1);\nconst _int32View = new Int32Array(_floatView.buffer);\nclass DataUtils {\n  static toHalfFloat(val) {\n    _floatView[0] = val;\n    const x = _int32View[0];\n    let bits = x >> 16 & 32768;\n    let m = x >> 12 & 2047;\n    const e = x >> 23 & 255;\n    if (e < 103)\n      return bits;\n    if (e > 142) {\n      bits |= 31744;\n      bits |= (e == 255 ? 0 : 1) && x & 8388607;\n      return bits;\n    }\n    if (e < 113) {\n      m |= 2048;\n      bits |= (m >> 114 - e) + (m >> 113 - e & 1);\n      return bits;\n    }\n    bits |= e - 112 << 10 | m >> 1;\n    bits += m & 1;\n    return bits;\n  }\n}\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow(2, LOD_MAX);\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\nconst MAX_SAMPLES = 20;\nconst ENCODINGS = {\n  [LinearEncoding]: 0,\n  [sRGBEncoding]: 1,\n  [RGBEEncoding]: 2,\n  [RGBM7Encoding]: 3,\n  [RGBM16Encoding]: 4,\n  [RGBDEncoding]: 5,\n  [GammaEncoding]: 6\n};\nconst backgroundMaterial = new MeshBasicMaterial({\n  side: BackSide,\n  depthWrite: false,\n  depthTest: false\n});\nconst backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial);\nconst _flatCamera = /* @__PURE__ */ new OrthographicCamera();\nconst {_lodPlanes, _sizeLods, _sigmas} = /* @__PURE__ */ _createPlanes();\nconst _clearColor = /* @__PURE__ */ new Color();\nlet _oldTarget = null;\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI;\nconst _axisDirections = [\n  /* @__PURE__ */ new Vector3(1, 1, 1),\n  /* @__PURE__ */ new Vector3(-1, 1, 1),\n  /* @__PURE__ */ new Vector3(1, 1, -1),\n  /* @__PURE__ */ new Vector3(-1, 1, -1),\n  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),\n  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),\n  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),\n  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),\n  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),\n  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0)\n];\nfunction convertLinearToRGBE(color) {\n  const maxComponent = Math.max(color.r, color.g, color.b);\n  const fExp = Math.min(Math.max(Math.ceil(Math.log2(maxComponent)), -128), 127);\n  color.multiplyScalar(Math.pow(2, -fExp));\n  const alpha = (fExp + 128) / 255;\n  return alpha;\n}\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._blurMaterial = _getBlurShader(MAX_SAMPLES);\n    this._equirectShader = null;\n    this._cubemapShader = null;\n    this._compileMaterial(this._blurMaterial);\n  }\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n    const cubeUVRenderTarget = this._allocateTargets();\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  fromEquirectangular(equirectangular) {\n    return this._fromTexture(equirectangular);\n  }\n  fromCubemap(cubemap) {\n    return this._fromTexture(cubemap);\n  }\n  compileCubemapShader() {\n    if (this._cubemapShader === null) {\n      this._cubemapShader = _getCubemapShader();\n      this._compileMaterial(this._cubemapShader);\n    }\n  }\n  compileEquirectangularShader() {\n    if (this._equirectShader === null) {\n      this._equirectShader = _getEquirectShader();\n      this._compileMaterial(this._equirectShader);\n    }\n  }\n  dispose() {\n    this._blurMaterial.dispose();\n    if (this._cubemapShader !== null)\n      this._cubemapShader.dispose();\n    if (this._equirectShader !== null)\n      this._equirectShader.dispose();\n    for (let i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  }\n  _cleanup(outputTarget) {\n    this._pingPongRenderTarget.dispose();\n    this._renderer.setRenderTarget(_oldTarget);\n    outputTarget.scissorTest = false;\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n  _fromTexture(texture) {\n    _oldTarget = this._renderer.getRenderTarget();\n    const cubeUVRenderTarget = this._allocateTargets(texture);\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n    this._applyPMREM(cubeUVRenderTarget);\n    this._cleanup(cubeUVRenderTarget);\n    return cubeUVRenderTarget;\n  }\n  _allocateTargets(texture) {\n    const params = {\n      magFilter: NearestFilter,\n      minFilter: NearestFilter,\n      generateMipmaps: false,\n      type: UnsignedByteType,\n      format: RGBEFormat,\n      encoding: _isLDR(texture) ? texture.encoding : RGBEEncoding,\n      depthBuffer: false\n    };\n    const cubeUVRenderTarget = _createRenderTarget(params);\n    cubeUVRenderTarget.depthBuffer = texture ? false : true;\n    this._pingPongRenderTarget = _createRenderTarget(params);\n    return cubeUVRenderTarget;\n  }\n  _compileMaterial(material) {\n    const tmpMesh = new Mesh(_lodPlanes[0], material);\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov2 = 90;\n    const aspect2 = 1;\n    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const outputEncoding = renderer.outputEncoding;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = NoToneMapping;\n    renderer.outputEncoding = LinearEncoding;\n    renderer.autoClear = false;\n    let useSolidColor = false;\n    const background = scene.background;\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background).convertSRGBToLinear();\n        scene.background = null;\n        const alpha = convertLinearToRGBE(backgroundMaterial.color);\n        backgroundMaterial.opacity = alpha;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor).convertSRGBToLinear();\n      const alpha = convertLinearToRGBE(backgroundMaterial.color);\n      backgroundMaterial.opacity = alpha;\n      useSolidColor = true;\n    }\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n      if (col == 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col == 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n      renderer.setRenderTarget(cubeUVRenderTarget);\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n      renderer.render(scene, cubeCamera);\n    }\n    renderer.toneMapping = toneMapping;\n    renderer.outputEncoding = outputEncoding;\n    renderer.autoClear = originalAutoClear;\n  }\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    if (texture.isCubeTexture) {\n      if (this._cubemapShader == null) {\n        this._cubemapShader = _getCubemapShader();\n      }\n    } else {\n      if (this._equirectShader == null) {\n        this._equirectShader = _getEquirectShader();\n      }\n    }\n    const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;\n    const mesh = new Mesh(_lodPlanes[0], material);\n    const uniforms = material.uniforms;\n    uniforms[\"envMap\"].value = texture;\n    if (!texture.isCubeTexture) {\n      uniforms[\"texelSize\"].value.set(1 / texture.image.width, 1 / texture.image.height);\n    }\n    uniforms[\"inputEncoding\"].value = ENCODINGS[texture.encoding];\n    uniforms[\"outputEncoding\"].value = ENCODINGS[cubeUVRenderTarget.texture.encoding];\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n    for (let i = 1; i < TOTAL_LODS; i++) {\n      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n    renderer.autoClear = autoClear;\n  }\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, \"latitudinal\", poleAxis);\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, \"longitudinal\", poleAxis);\n  }\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n    if (direction !== \"latitudinal\" && direction !== \"longitudinal\") {\n      console.error(\"blur direction must be either latitudinal or longitudinal!\");\n    }\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new Mesh(_lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = _sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n    const weights = [];\n    let sum = 0;\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x2 = i / sigmaPixels;\n      const weight = Math.exp(-x2 * x2 / 2);\n      weights.push(weight);\n      if (i == 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n    blurUniforms[\"envMap\"].value = targetIn.texture;\n    blurUniforms[\"samples\"].value = samples;\n    blurUniforms[\"weights\"].value = weights;\n    blurUniforms[\"latitudinal\"].value = direction === \"latitudinal\";\n    if (poleAxis) {\n      blurUniforms[\"poleAxis\"].value = poleAxis;\n    }\n    blurUniforms[\"dTheta\"].value = radiansPerPixel;\n    blurUniforms[\"mipInt\"].value = LOD_MAX - lodIn;\n    blurUniforms[\"inputEncoding\"].value = ENCODINGS[targetIn.texture.encoding];\n    blurUniforms[\"outputEncoding\"].value = ENCODINGS[targetIn.texture.encoding];\n    const outputSize = _sizeLods[lodOut];\n    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n}\nfunction _isLDR(texture) {\n  if (texture === void 0 || texture.type !== UnsignedByteType)\n    return false;\n  return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;\n}\nfunction _createPlanes() {\n  const _lodPlanes2 = [];\n  const _sizeLods2 = [];\n  const _sigmas2 = [];\n  let lod = LOD_MAX;\n  for (let i = 0; i < TOTAL_LODS; i++) {\n    const sizeLod = Math.pow(2, lod);\n    _sizeLods2.push(sizeLod);\n    let sigma = 1 / sizeLod;\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i == 0) {\n      sigma = 0;\n    }\n    _sigmas2.push(sigma);\n    const texelSize = 1 / (sizeLod - 1);\n    const min = -texelSize / 2;\n    const max = 1 + texelSize / 2;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [\n        x,\n        y,\n        0,\n        x + 2 / 3,\n        y,\n        0,\n        x + 2 / 3,\n        y + 1,\n        0,\n        x,\n        y,\n        0,\n        x + 2 / 3,\n        y + 1,\n        0,\n        x,\n        y + 1,\n        0\n      ];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n    const planes = new BufferGeometry();\n    planes.setAttribute(\"position\", new BufferAttribute(position, positionSize));\n    planes.setAttribute(\"uv\", new BufferAttribute(uv, uvSize));\n    planes.setAttribute(\"faceIndex\", new BufferAttribute(faceIndex, faceIndexSize));\n    _lodPlanes2.push(planes);\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n  return {_lodPlanes: _lodPlanes2, _sizeLods: _sizeLods2, _sigmas: _sigmas2};\n}\nfunction _createRenderTarget(params) {\n  const cubeUVRenderTarget = new WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = \"PMREM.cubeUv\";\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\nfunction _getBlurShader(maxSamples) {\n  const weights = new Float32Array(maxSamples);\n  const poleAxis = new Vector3(0, 1, 0);\n  const shaderMaterial = new RawShaderMaterial({\n    name: \"SphericalGaussianBlur\",\n    defines: {\"n\": maxSamples},\n    uniforms: {\n      \"envMap\": {value: null},\n      \"samples\": {value: 1},\n      \"weights\": {value: weights},\n      \"latitudinal\": {value: false},\n      \"dTheta\": {value: 0},\n      \"mipInt\": {value: 0},\n      \"poleAxis\": {value: poleAxis},\n      \"inputEncoding\": {value: ENCODINGS[LinearEncoding]},\n      \"outputEncoding\": {value: ENCODINGS[LinearEncoding]}\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\nfunction _getEquirectShader() {\n  const texelSize = new Vector2(1, 1);\n  const shaderMaterial = new RawShaderMaterial({\n    name: \"EquirectangularToCubeUV\",\n    uniforms: {\n      \"envMap\": {value: null},\n      \"texelSize\": {value: texelSize},\n      \"inputEncoding\": {value: ENCODINGS[LinearEncoding]},\n      \"outputEncoding\": {value: ENCODINGS[LinearEncoding]}\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t${_getEncodings()}\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\nfunction _getCubemapShader() {\n  const shaderMaterial = new RawShaderMaterial({\n    name: \"CubemapToCubeUV\",\n    uniforms: {\n      \"envMap\": {value: null},\n      \"inputEncoding\": {value: ENCODINGS[LinearEncoding]},\n      \"outputEncoding\": {value: ENCODINGS[LinearEncoding]}\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader: `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\t${_getEncodings()}\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;\n\t\t\t\tgl_FragColor = linearToOutputTexel( gl_FragColor );\n\n\t\t\t}\n\t\t`,\n    blending: NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\nfunction _getCommonVertexShader() {\n  return `\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`;\n}\nfunction _getEncodings() {\n  return `\n\n\t\tuniform int inputEncoding;\n\t\tuniform int outputEncoding;\n\n\t\t#include <encodings_pars_fragment>\n\n\t\tvec4 inputTexelToLinear( vec4 value ) {\n\n\t\t\tif ( inputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( inputEncoding == 1 ) {\n\n\t\t\t\treturn sRGBToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 2 ) {\n\n\t\t\t\treturn RGBEToLinear( value );\n\n\t\t\t} else if ( inputEncoding == 3 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 7.0 );\n\n\t\t\t} else if ( inputEncoding == 4 ) {\n\n\t\t\t\treturn RGBMToLinear( value, 16.0 );\n\n\t\t\t} else if ( inputEncoding == 5 ) {\n\n\t\t\t\treturn RGBDToLinear( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn GammaToLinear( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 linearToOutputTexel( vec4 value ) {\n\n\t\t\tif ( outputEncoding == 0 ) {\n\n\t\t\t\treturn value;\n\n\t\t\t} else if ( outputEncoding == 1 ) {\n\n\t\t\t\treturn LinearTosRGB( value );\n\n\t\t\t} else if ( outputEncoding == 2 ) {\n\n\t\t\t\treturn LinearToRGBE( value );\n\n\t\t\t} else if ( outputEncoding == 3 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 7.0 );\n\n\t\t\t} else if ( outputEncoding == 4 ) {\n\n\t\t\t\treturn LinearToRGBM( value, 16.0 );\n\n\t\t\t} else if ( outputEncoding == 5 ) {\n\n\t\t\t\treturn LinearToRGBD( value, 256.0 );\n\n\t\t\t} else {\n\n\t\t\t\treturn LinearToGamma( value, 2.2 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tvec4 envMapTexelToLinear( vec4 color ) {\n\n\t\t\treturn inputTexelToLinear( color );\n\n\t\t}\n\t`;\n}\nconst LineStrip = 0;\nconst LinePieces = 1;\nconst NoColors = 0;\nconst FaceColors = 1;\nconst VertexColors = 2;\nfunction MeshFaceMaterial(materials) {\n  console.warn(\"THREE.MeshFaceMaterial has been removed. Use an Array instead.\");\n  return materials;\n}\nfunction MultiMaterial(materials = []) {\n  console.warn(\"THREE.MultiMaterial has been removed. Use an Array instead.\");\n  materials.isMultiMaterial = true;\n  materials.materials = materials;\n  materials.clone = function() {\n    return materials.slice();\n  };\n  return materials;\n}\nfunction PointCloud(geometry, material) {\n  console.warn(\"THREE.PointCloud has been renamed to THREE.Points.\");\n  return new Points(geometry, material);\n}\nfunction Particle(material) {\n  console.warn(\"THREE.Particle has been renamed to THREE.Sprite.\");\n  return new Sprite(material);\n}\nfunction ParticleSystem(geometry, material) {\n  console.warn(\"THREE.ParticleSystem has been renamed to THREE.Points.\");\n  return new Points(geometry, material);\n}\nfunction PointCloudMaterial(parameters) {\n  console.warn(\"THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.\");\n  return new PointsMaterial(parameters);\n}\nfunction ParticleBasicMaterial(parameters) {\n  console.warn(\"THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.\");\n  return new PointsMaterial(parameters);\n}\nfunction ParticleSystemMaterial(parameters) {\n  console.warn(\"THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.\");\n  return new PointsMaterial(parameters);\n}\nfunction Vertex(x, y, z) {\n  console.warn(\"THREE.Vertex has been removed. Use THREE.Vector3 instead.\");\n  return new Vector3(x, y, z);\n}\nfunction DynamicBufferAttribute(array, itemSize) {\n  console.warn(\"THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.\");\n  return new BufferAttribute(array, itemSize).setUsage(DynamicDrawUsage);\n}\nfunction Int8Attribute(array, itemSize) {\n  console.warn(\"THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.\");\n  return new Int8BufferAttribute(array, itemSize);\n}\nfunction Uint8Attribute(array, itemSize) {\n  console.warn(\"THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.\");\n  return new Uint8BufferAttribute(array, itemSize);\n}\nfunction Uint8ClampedAttribute(array, itemSize) {\n  console.warn(\"THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.\");\n  return new Uint8ClampedBufferAttribute(array, itemSize);\n}\nfunction Int16Attribute(array, itemSize) {\n  console.warn(\"THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.\");\n  return new Int16BufferAttribute(array, itemSize);\n}\nfunction Uint16Attribute(array, itemSize) {\n  console.warn(\"THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.\");\n  return new Uint16BufferAttribute(array, itemSize);\n}\nfunction Int32Attribute(array, itemSize) {\n  console.warn(\"THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.\");\n  return new Int32BufferAttribute(array, itemSize);\n}\nfunction Uint32Attribute(array, itemSize) {\n  console.warn(\"THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.\");\n  return new Uint32BufferAttribute(array, itemSize);\n}\nfunction Float32Attribute(array, itemSize) {\n  console.warn(\"THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.\");\n  return new Float32BufferAttribute(array, itemSize);\n}\nfunction Float64Attribute(array, itemSize) {\n  console.warn(\"THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.\");\n  return new Float64BufferAttribute(array, itemSize);\n}\nCurve.create = function(construct, getPoint) {\n  console.log(\"THREE.Curve.create() has been deprecated\");\n  construct.prototype = Object.create(Curve.prototype);\n  construct.prototype.constructor = construct;\n  construct.prototype.getPoint = getPoint;\n  return construct;\n};\nPath.prototype.fromPoints = function(points) {\n  console.warn(\"THREE.Path: .fromPoints() has been renamed to .setFromPoints().\");\n  return this.setFromPoints(points);\n};\nfunction AxisHelper(size) {\n  console.warn(\"THREE.AxisHelper has been renamed to THREE.AxesHelper.\");\n  return new AxesHelper(size);\n}\nfunction BoundingBoxHelper(object, color) {\n  console.warn(\"THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.\");\n  return new BoxHelper(object, color);\n}\nfunction EdgesHelper(object, hex) {\n  console.warn(\"THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.\");\n  return new LineSegments(new EdgesGeometry(object.geometry), new LineBasicMaterial({color: hex !== void 0 ? hex : 16777215}));\n}\nGridHelper.prototype.setColors = function() {\n  console.error(\"THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.\");\n};\nSkeletonHelper.prototype.update = function() {\n  console.error(\"THREE.SkeletonHelper: update() no longer needs to be called.\");\n};\nfunction WireframeHelper(object, hex) {\n  console.warn(\"THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.\");\n  return new LineSegments(new WireframeGeometry(object.geometry), new LineBasicMaterial({color: hex !== void 0 ? hex : 16777215}));\n}\nLoader.prototype.extractUrlBase = function(url) {\n  console.warn(\"THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.\");\n  return LoaderUtils.extractUrlBase(url);\n};\nLoader.Handlers = {\n  add: function() {\n    console.error(\"THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.\");\n  },\n  get: function() {\n    console.error(\"THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.\");\n  }\n};\nfunction XHRLoader(manager) {\n  console.warn(\"THREE.XHRLoader has been renamed to THREE.FileLoader.\");\n  return new FileLoader(manager);\n}\nfunction BinaryTextureLoader(manager) {\n  console.warn(\"THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.\");\n  return new DataTextureLoader(manager);\n}\nBox2.prototype.center = function(optionalTarget) {\n  console.warn(\"THREE.Box2: .center() has been renamed to .getCenter().\");\n  return this.getCenter(optionalTarget);\n};\nBox2.prototype.empty = function() {\n  console.warn(\"THREE.Box2: .empty() has been renamed to .isEmpty().\");\n  return this.isEmpty();\n};\nBox2.prototype.isIntersectionBox = function(box) {\n  console.warn(\"THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().\");\n  return this.intersectsBox(box);\n};\nBox2.prototype.size = function(optionalTarget) {\n  console.warn(\"THREE.Box2: .size() has been renamed to .getSize().\");\n  return this.getSize(optionalTarget);\n};\nBox3.prototype.center = function(optionalTarget) {\n  console.warn(\"THREE.Box3: .center() has been renamed to .getCenter().\");\n  return this.getCenter(optionalTarget);\n};\nBox3.prototype.empty = function() {\n  console.warn(\"THREE.Box3: .empty() has been renamed to .isEmpty().\");\n  return this.isEmpty();\n};\nBox3.prototype.isIntersectionBox = function(box) {\n  console.warn(\"THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().\");\n  return this.intersectsBox(box);\n};\nBox3.prototype.isIntersectionSphere = function(sphere) {\n  console.warn(\"THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().\");\n  return this.intersectsSphere(sphere);\n};\nBox3.prototype.size = function(optionalTarget) {\n  console.warn(\"THREE.Box3: .size() has been renamed to .getSize().\");\n  return this.getSize(optionalTarget);\n};\nSphere.prototype.empty = function() {\n  console.warn(\"THREE.Sphere: .empty() has been renamed to .isEmpty().\");\n  return this.isEmpty();\n};\nFrustum.prototype.setFromMatrix = function(m) {\n  console.warn(\"THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().\");\n  return this.setFromProjectionMatrix(m);\n};\nLine3.prototype.center = function(optionalTarget) {\n  console.warn(\"THREE.Line3: .center() has been renamed to .getCenter().\");\n  return this.getCenter(optionalTarget);\n};\nMatrix3.prototype.flattenToArrayOffset = function(array, offset) {\n  console.warn(\"THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");\n  return this.toArray(array, offset);\n};\nMatrix3.prototype.multiplyVector3 = function(vector) {\n  console.warn(\"THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.\");\n  return vector.applyMatrix3(this);\n};\nMatrix3.prototype.multiplyVector3Array = function() {\n  console.error(\"THREE.Matrix3: .multiplyVector3Array() has been removed.\");\n};\nMatrix3.prototype.applyToBufferAttribute = function(attribute) {\n  console.warn(\"THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.\");\n  return attribute.applyMatrix3(this);\n};\nMatrix3.prototype.applyToVector3Array = function() {\n  console.error(\"THREE.Matrix3: .applyToVector3Array() has been removed.\");\n};\nMatrix3.prototype.getInverse = function(matrix) {\n  console.warn(\"THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.\");\n  return this.copy(matrix).invert();\n};\nMatrix4.prototype.extractPosition = function(m) {\n  console.warn(\"THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().\");\n  return this.copyPosition(m);\n};\nMatrix4.prototype.flattenToArrayOffset = function(array, offset) {\n  console.warn(\"THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.\");\n  return this.toArray(array, offset);\n};\nMatrix4.prototype.getPosition = function() {\n  console.warn(\"THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.\");\n  return new Vector3().setFromMatrixColumn(this, 3);\n};\nMatrix4.prototype.setRotationFromQuaternion = function(q) {\n  console.warn(\"THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().\");\n  return this.makeRotationFromQuaternion(q);\n};\nMatrix4.prototype.multiplyToArray = function() {\n  console.warn(\"THREE.Matrix4: .multiplyToArray() has been removed.\");\n};\nMatrix4.prototype.multiplyVector3 = function(vector) {\n  console.warn(\"THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\n  return vector.applyMatrix4(this);\n};\nMatrix4.prototype.multiplyVector4 = function(vector) {\n  console.warn(\"THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\n  return vector.applyMatrix4(this);\n};\nMatrix4.prototype.multiplyVector3Array = function() {\n  console.error(\"THREE.Matrix4: .multiplyVector3Array() has been removed.\");\n};\nMatrix4.prototype.rotateAxis = function(v) {\n  console.warn(\"THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.\");\n  v.transformDirection(this);\n};\nMatrix4.prototype.crossVector = function(vector) {\n  console.warn(\"THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.\");\n  return vector.applyMatrix4(this);\n};\nMatrix4.prototype.translate = function() {\n  console.error(\"THREE.Matrix4: .translate() has been removed.\");\n};\nMatrix4.prototype.rotateX = function() {\n  console.error(\"THREE.Matrix4: .rotateX() has been removed.\");\n};\nMatrix4.prototype.rotateY = function() {\n  console.error(\"THREE.Matrix4: .rotateY() has been removed.\");\n};\nMatrix4.prototype.rotateZ = function() {\n  console.error(\"THREE.Matrix4: .rotateZ() has been removed.\");\n};\nMatrix4.prototype.rotateByAxis = function() {\n  console.error(\"THREE.Matrix4: .rotateByAxis() has been removed.\");\n};\nMatrix4.prototype.applyToBufferAttribute = function(attribute) {\n  console.warn(\"THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.\");\n  return attribute.applyMatrix4(this);\n};\nMatrix4.prototype.applyToVector3Array = function() {\n  console.error(\"THREE.Matrix4: .applyToVector3Array() has been removed.\");\n};\nMatrix4.prototype.makeFrustum = function(left, right, bottom, top, near, far) {\n  console.warn(\"THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.\");\n  return this.makePerspective(left, right, top, bottom, near, far);\n};\nMatrix4.prototype.getInverse = function(matrix) {\n  console.warn(\"THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.\");\n  return this.copy(matrix).invert();\n};\nPlane.prototype.isIntersectionLine = function(line) {\n  console.warn(\"THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().\");\n  return this.intersectsLine(line);\n};\nQuaternion.prototype.multiplyVector3 = function(vector) {\n  console.warn(\"THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.\");\n  return vector.applyQuaternion(this);\n};\nQuaternion.prototype.inverse = function() {\n  console.warn(\"THREE.Quaternion: .inverse() has been renamed to invert().\");\n  return this.invert();\n};\nRay.prototype.isIntersectionBox = function(box) {\n  console.warn(\"THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().\");\n  return this.intersectsBox(box);\n};\nRay.prototype.isIntersectionPlane = function(plane) {\n  console.warn(\"THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().\");\n  return this.intersectsPlane(plane);\n};\nRay.prototype.isIntersectionSphere = function(sphere) {\n  console.warn(\"THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().\");\n  return this.intersectsSphere(sphere);\n};\nTriangle.prototype.area = function() {\n  console.warn(\"THREE.Triangle: .area() has been renamed to .getArea().\");\n  return this.getArea();\n};\nTriangle.prototype.barycoordFromPoint = function(point, target) {\n  console.warn(\"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().\");\n  return this.getBarycoord(point, target);\n};\nTriangle.prototype.midpoint = function(target) {\n  console.warn(\"THREE.Triangle: .midpoint() has been renamed to .getMidpoint().\");\n  return this.getMidpoint(target);\n};\nTriangle.prototypenormal = function(target) {\n  console.warn(\"THREE.Triangle: .normal() has been renamed to .getNormal().\");\n  return this.getNormal(target);\n};\nTriangle.prototype.plane = function(target) {\n  console.warn(\"THREE.Triangle: .plane() has been renamed to .getPlane().\");\n  return this.getPlane(target);\n};\nTriangle.barycoordFromPoint = function(point, a, b, c, target) {\n  console.warn(\"THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().\");\n  return Triangle.getBarycoord(point, a, b, c, target);\n};\nTriangle.normal = function(a, b, c, target) {\n  console.warn(\"THREE.Triangle: .normal() has been renamed to .getNormal().\");\n  return Triangle.getNormal(a, b, c, target);\n};\nShape.prototype.extractAllPoints = function(divisions) {\n  console.warn(\"THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.\");\n  return this.extractPoints(divisions);\n};\nShape.prototype.extrude = function(options) {\n  console.warn(\"THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.\");\n  return new ExtrudeGeometry(this, options);\n};\nShape.prototype.makeGeometry = function(options) {\n  console.warn(\"THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.\");\n  return new ShapeGeometry(this, options);\n};\nVector2.prototype.fromAttribute = function(attribute, index, offset) {\n  console.warn(\"THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().\");\n  return this.fromBufferAttribute(attribute, index, offset);\n};\nVector2.prototype.distanceToManhattan = function(v) {\n  console.warn(\"THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().\");\n  return this.manhattanDistanceTo(v);\n};\nVector2.prototype.lengthManhattan = function() {\n  console.warn(\"THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().\");\n  return this.manhattanLength();\n};\nVector3.prototype.setEulerFromRotationMatrix = function() {\n  console.error(\"THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.\");\n};\nVector3.prototype.setEulerFromQuaternion = function() {\n  console.error(\"THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.\");\n};\nVector3.prototype.getPositionFromMatrix = function(m) {\n  console.warn(\"THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().\");\n  return this.setFromMatrixPosition(m);\n};\nVector3.prototype.getScaleFromMatrix = function(m) {\n  console.warn(\"THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().\");\n  return this.setFromMatrixScale(m);\n};\nVector3.prototype.getColumnFromMatrix = function(index, matrix) {\n  console.warn(\"THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().\");\n  return this.setFromMatrixColumn(matrix, index);\n};\nVector3.prototype.applyProjection = function(m) {\n  console.warn(\"THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.\");\n  return this.applyMatrix4(m);\n};\nVector3.prototype.fromAttribute = function(attribute, index, offset) {\n  console.warn(\"THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().\");\n  return this.fromBufferAttribute(attribute, index, offset);\n};\nVector3.prototype.distanceToManhattan = function(v) {\n  console.warn(\"THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().\");\n  return this.manhattanDistanceTo(v);\n};\nVector3.prototype.lengthManhattan = function() {\n  console.warn(\"THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().\");\n  return this.manhattanLength();\n};\nVector4.prototype.fromAttribute = function(attribute, index, offset) {\n  console.warn(\"THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().\");\n  return this.fromBufferAttribute(attribute, index, offset);\n};\nVector4.prototype.lengthManhattan = function() {\n  console.warn(\"THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().\");\n  return this.manhattanLength();\n};\nObject3D.prototype.getChildByName = function(name) {\n  console.warn(\"THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().\");\n  return this.getObjectByName(name);\n};\nObject3D.prototype.renderDepth = function() {\n  console.warn(\"THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.\");\n};\nObject3D.prototype.translate = function(distance, axis) {\n  console.warn(\"THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.\");\n  return this.translateOnAxis(axis, distance);\n};\nObject3D.prototype.getWorldRotation = function() {\n  console.error(\"THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.\");\n};\nObject3D.prototype.applyMatrix = function(matrix) {\n  console.warn(\"THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().\");\n  return this.applyMatrix4(matrix);\n};\nObject.defineProperties(Object3D.prototype, {\n  eulerOrder: {\n    get: function() {\n      console.warn(\"THREE.Object3D: .eulerOrder is now .rotation.order.\");\n      return this.rotation.order;\n    },\n    set: function(value) {\n      console.warn(\"THREE.Object3D: .eulerOrder is now .rotation.order.\");\n      this.rotation.order = value;\n    }\n  },\n  useQuaternion: {\n    get: function() {\n      console.warn(\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\");\n    },\n    set: function() {\n      console.warn(\"THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.\");\n    }\n  }\n});\nMesh.prototype.setDrawMode = function() {\n  console.error(\"THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.\");\n};\nObject.defineProperties(Mesh.prototype, {\n  drawMode: {\n    get: function() {\n      console.error(\"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.\");\n      return TrianglesDrawMode;\n    },\n    set: function() {\n      console.error(\"THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.\");\n    }\n  }\n});\nSkinnedMesh.prototype.initBones = function() {\n  console.error(\"THREE.SkinnedMesh: initBones() has been removed.\");\n};\nPerspectiveCamera.prototype.setLens = function(focalLength, filmGauge) {\n  console.warn(\"THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup.\");\n  if (filmGauge !== void 0)\n    this.filmGauge = filmGauge;\n  this.setFocalLength(focalLength);\n};\nObject.defineProperties(Light.prototype, {\n  onlyShadow: {\n    set: function() {\n      console.warn(\"THREE.Light: .onlyShadow has been removed.\");\n    }\n  },\n  shadowCameraFov: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowCameraFov is now .shadow.camera.fov.\");\n      this.shadow.camera.fov = value;\n    }\n  },\n  shadowCameraLeft: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowCameraLeft is now .shadow.camera.left.\");\n      this.shadow.camera.left = value;\n    }\n  },\n  shadowCameraRight: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowCameraRight is now .shadow.camera.right.\");\n      this.shadow.camera.right = value;\n    }\n  },\n  shadowCameraTop: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowCameraTop is now .shadow.camera.top.\");\n      this.shadow.camera.top = value;\n    }\n  },\n  shadowCameraBottom: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.\");\n      this.shadow.camera.bottom = value;\n    }\n  },\n  shadowCameraNear: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowCameraNear is now .shadow.camera.near.\");\n      this.shadow.camera.near = value;\n    }\n  },\n  shadowCameraFar: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowCameraFar is now .shadow.camera.far.\");\n      this.shadow.camera.far = value;\n    }\n  },\n  shadowCameraVisible: {\n    set: function() {\n      console.warn(\"THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.\");\n    }\n  },\n  shadowBias: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowBias is now .shadow.bias.\");\n      this.shadow.bias = value;\n    }\n  },\n  shadowDarkness: {\n    set: function() {\n      console.warn(\"THREE.Light: .shadowDarkness has been removed.\");\n    }\n  },\n  shadowMapWidth: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.\");\n      this.shadow.mapSize.width = value;\n    }\n  },\n  shadowMapHeight: {\n    set: function(value) {\n      console.warn(\"THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.\");\n      this.shadow.mapSize.height = value;\n    }\n  }\n});\nObject.defineProperties(BufferAttribute.prototype, {\n  length: {\n    get: function() {\n      console.warn(\"THREE.BufferAttribute: .length has been deprecated. Use .count instead.\");\n      return this.array.length;\n    }\n  },\n  dynamic: {\n    get: function() {\n      console.warn(\"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.\");\n      return this.usage === DynamicDrawUsage;\n    },\n    set: function() {\n      console.warn(\"THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.\");\n      this.setUsage(DynamicDrawUsage);\n    }\n  }\n});\nBufferAttribute.prototype.setDynamic = function(value) {\n  console.warn(\"THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.\");\n  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n  return this;\n};\nBufferAttribute.prototype.copyIndicesArray = function() {\n  console.error(\"THREE.BufferAttribute: .copyIndicesArray() has been removed.\");\n}, BufferAttribute.prototype.setArray = function() {\n  console.error(\"THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers\");\n};\nBufferGeometry.prototype.addIndex = function(index) {\n  console.warn(\"THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().\");\n  this.setIndex(index);\n};\nBufferGeometry.prototype.addAttribute = function(name, attribute) {\n  console.warn(\"THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().\");\n  if (!(attribute && attribute.isBufferAttribute) && !(attribute && attribute.isInterleavedBufferAttribute)) {\n    console.warn(\"THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).\");\n    return this.setAttribute(name, new BufferAttribute(arguments[1], arguments[2]));\n  }\n  if (name === \"index\") {\n    console.warn(\"THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.\");\n    this.setIndex(attribute);\n    return this;\n  }\n  return this.setAttribute(name, attribute);\n};\nBufferGeometry.prototype.addDrawCall = function(start, count, indexOffset) {\n  if (indexOffset !== void 0) {\n    console.warn(\"THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.\");\n  }\n  console.warn(\"THREE.BufferGeometry: .addDrawCall() is now .addGroup().\");\n  this.addGroup(start, count);\n};\nBufferGeometry.prototype.clearDrawCalls = function() {\n  console.warn(\"THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().\");\n  this.clearGroups();\n};\nBufferGeometry.prototype.computeOffsets = function() {\n  console.warn(\"THREE.BufferGeometry: .computeOffsets() has been removed.\");\n};\nBufferGeometry.prototype.removeAttribute = function(name) {\n  console.warn(\"THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().\");\n  return this.deleteAttribute(name);\n};\nBufferGeometry.prototype.applyMatrix = function(matrix) {\n  console.warn(\"THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().\");\n  return this.applyMatrix4(matrix);\n};\nObject.defineProperties(BufferGeometry.prototype, {\n  drawcalls: {\n    get: function() {\n      console.error(\"THREE.BufferGeometry: .drawcalls has been renamed to .groups.\");\n      return this.groups;\n    }\n  },\n  offsets: {\n    get: function() {\n      console.warn(\"THREE.BufferGeometry: .offsets has been renamed to .groups.\");\n      return this.groups;\n    }\n  }\n});\nInterleavedBuffer.prototype.setDynamic = function(value) {\n  console.warn(\"THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.\");\n  this.setUsage(value === true ? DynamicDrawUsage : StaticDrawUsage);\n  return this;\n};\nInterleavedBuffer.prototype.setArray = function() {\n  console.error(\"THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers\");\n};\nExtrudeGeometry.prototype.getArrays = function() {\n  console.error(\"THREE.ExtrudeGeometry: .getArrays() has been removed.\");\n};\nExtrudeGeometry.prototype.addShapeList = function() {\n  console.error(\"THREE.ExtrudeGeometry: .addShapeList() has been removed.\");\n};\nExtrudeGeometry.prototype.addShape = function() {\n  console.error(\"THREE.ExtrudeGeometry: .addShape() has been removed.\");\n};\nScene.prototype.dispose = function() {\n  console.error(\"THREE.Scene: .dispose() has been removed.\");\n};\nUniform.prototype.onUpdate = function() {\n  console.warn(\"THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.\");\n  return this;\n};\nObject.defineProperties(Material.prototype, {\n  wrapAround: {\n    get: function() {\n      console.warn(\"THREE.Material: .wrapAround has been removed.\");\n    },\n    set: function() {\n      console.warn(\"THREE.Material: .wrapAround has been removed.\");\n    }\n  },\n  overdraw: {\n    get: function() {\n      console.warn(\"THREE.Material: .overdraw has been removed.\");\n    },\n    set: function() {\n      console.warn(\"THREE.Material: .overdraw has been removed.\");\n    }\n  },\n  wrapRGB: {\n    get: function() {\n      console.warn(\"THREE.Material: .wrapRGB has been removed.\");\n      return new Color();\n    }\n  },\n  shading: {\n    get: function() {\n      console.error(\"THREE.\" + this.type + \": .shading has been removed. Use the boolean .flatShading instead.\");\n    },\n    set: function(value) {\n      console.warn(\"THREE.\" + this.type + \": .shading has been removed. Use the boolean .flatShading instead.\");\n      this.flatShading = value === FlatShading;\n    }\n  },\n  stencilMask: {\n    get: function() {\n      console.warn(\"THREE.\" + this.type + \": .stencilMask has been removed. Use .stencilFuncMask instead.\");\n      return this.stencilFuncMask;\n    },\n    set: function(value) {\n      console.warn(\"THREE.\" + this.type + \": .stencilMask has been removed. Use .stencilFuncMask instead.\");\n      this.stencilFuncMask = value;\n    }\n  }\n});\nObject.defineProperties(ShaderMaterial.prototype, {\n  derivatives: {\n    get: function() {\n      console.warn(\"THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.\");\n      return this.extensions.derivatives;\n    },\n    set: function(value) {\n      console.warn(\"THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.\");\n      this.extensions.derivatives = value;\n    }\n  }\n});\nWebGLRenderer.prototype.clearTarget = function(renderTarget, color, depth, stencil) {\n  console.warn(\"THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.\");\n  this.setRenderTarget(renderTarget);\n  this.clear(color, depth, stencil);\n};\nWebGLRenderer.prototype.animate = function(callback) {\n  console.warn(\"THREE.WebGLRenderer: .animate() is now .setAnimationLoop().\");\n  this.setAnimationLoop(callback);\n};\nWebGLRenderer.prototype.getCurrentRenderTarget = function() {\n  console.warn(\"THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().\");\n  return this.getRenderTarget();\n};\nWebGLRenderer.prototype.getMaxAnisotropy = function() {\n  console.warn(\"THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().\");\n  return this.capabilities.getMaxAnisotropy();\n};\nWebGLRenderer.prototype.getPrecision = function() {\n  console.warn(\"THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.\");\n  return this.capabilities.precision;\n};\nWebGLRenderer.prototype.resetGLState = function() {\n  console.warn(\"THREE.WebGLRenderer: .resetGLState() is now .state.reset().\");\n  return this.state.reset();\n};\nWebGLRenderer.prototype.supportsFloatTextures = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' ).\");\n  return this.extensions.get(\"OES_texture_float\");\n};\nWebGLRenderer.prototype.supportsHalfFloatTextures = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' ).\");\n  return this.extensions.get(\"OES_texture_half_float\");\n};\nWebGLRenderer.prototype.supportsStandardDerivatives = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' ).\");\n  return this.extensions.get(\"OES_standard_derivatives\");\n};\nWebGLRenderer.prototype.supportsCompressedTextureS3TC = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' ).\");\n  return this.extensions.get(\"WEBGL_compressed_texture_s3tc\");\n};\nWebGLRenderer.prototype.supportsCompressedTexturePVRTC = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' ).\");\n  return this.extensions.get(\"WEBGL_compressed_texture_pvrtc\");\n};\nWebGLRenderer.prototype.supportsBlendMinMax = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' ).\");\n  return this.extensions.get(\"EXT_blend_minmax\");\n};\nWebGLRenderer.prototype.supportsVertexTextures = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.\");\n  return this.capabilities.vertexTextures;\n};\nWebGLRenderer.prototype.supportsInstancedArrays = function() {\n  console.warn(\"THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' ).\");\n  return this.extensions.get(\"ANGLE_instanced_arrays\");\n};\nWebGLRenderer.prototype.enableScissorTest = function(boolean) {\n  console.warn(\"THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().\");\n  this.setScissorTest(boolean);\n};\nWebGLRenderer.prototype.initMaterial = function() {\n  console.warn(\"THREE.WebGLRenderer: .initMaterial() has been removed.\");\n};\nWebGLRenderer.prototype.addPrePlugin = function() {\n  console.warn(\"THREE.WebGLRenderer: .addPrePlugin() has been removed.\");\n};\nWebGLRenderer.prototype.addPostPlugin = function() {\n  console.warn(\"THREE.WebGLRenderer: .addPostPlugin() has been removed.\");\n};\nWebGLRenderer.prototype.updateShadowMap = function() {\n  console.warn(\"THREE.WebGLRenderer: .updateShadowMap() has been removed.\");\n};\nWebGLRenderer.prototype.setFaceCulling = function() {\n  console.warn(\"THREE.WebGLRenderer: .setFaceCulling() has been removed.\");\n};\nWebGLRenderer.prototype.allocTextureUnit = function() {\n  console.warn(\"THREE.WebGLRenderer: .allocTextureUnit() has been removed.\");\n};\nWebGLRenderer.prototype.setTexture = function() {\n  console.warn(\"THREE.WebGLRenderer: .setTexture() has been removed.\");\n};\nWebGLRenderer.prototype.setTexture2D = function() {\n  console.warn(\"THREE.WebGLRenderer: .setTexture2D() has been removed.\");\n};\nWebGLRenderer.prototype.setTextureCube = function() {\n  console.warn(\"THREE.WebGLRenderer: .setTextureCube() has been removed.\");\n};\nWebGLRenderer.prototype.getActiveMipMapLevel = function() {\n  console.warn(\"THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().\");\n  return this.getActiveMipmapLevel();\n};\nObject.defineProperties(WebGLRenderer.prototype, {\n  shadowMapEnabled: {\n    get: function() {\n      return this.shadowMap.enabled;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.\");\n      this.shadowMap.enabled = value;\n    }\n  },\n  shadowMapType: {\n    get: function() {\n      return this.shadowMap.type;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.\");\n      this.shadowMap.type = value;\n    }\n  },\n  shadowMapCullFace: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.\");\n      return void 0;\n    },\n    set: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.\");\n    }\n  },\n  context: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.\");\n      return this.getContext();\n    }\n  },\n  vr: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .vr has been renamed to .xr\");\n      return this.xr;\n    }\n  },\n  gammaInput: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.\");\n      return false;\n    },\n    set: function() {\n      console.warn(\"THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.\");\n    }\n  },\n  gammaOutput: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.\");\n      return false;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.\");\n      this.outputEncoding = value === true ? sRGBEncoding : LinearEncoding;\n    }\n  },\n  toneMappingWhitePoint: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.\");\n      return 1;\n    },\n    set: function() {\n      console.warn(\"THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.\");\n    }\n  }\n});\nObject.defineProperties(WebGLShadowMap.prototype, {\n  cullFace: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.\");\n      return void 0;\n    },\n    set: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.\");\n    }\n  },\n  renderReverseSided: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.\");\n      return void 0;\n    },\n    set: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.\");\n    }\n  },\n  renderSingleSided: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.\");\n      return void 0;\n    },\n    set: function() {\n      console.warn(\"THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.\");\n    }\n  }\n});\nfunction WebGLRenderTargetCube(width, height, options) {\n  console.warn(\"THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).\");\n  return new WebGLCubeRenderTarget(width, options);\n}\nObject.defineProperties(WebGLRenderTarget.prototype, {\n  wrapS: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.\");\n      return this.texture.wrapS;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.\");\n      this.texture.wrapS = value;\n    }\n  },\n  wrapT: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.\");\n      return this.texture.wrapT;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.\");\n      this.texture.wrapT = value;\n    }\n  },\n  magFilter: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.\");\n      return this.texture.magFilter;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.\");\n      this.texture.magFilter = value;\n    }\n  },\n  minFilter: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.\");\n      return this.texture.minFilter;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.\");\n      this.texture.minFilter = value;\n    }\n  },\n  anisotropy: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.\");\n      return this.texture.anisotropy;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.\");\n      this.texture.anisotropy = value;\n    }\n  },\n  offset: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .offset is now .texture.offset.\");\n      return this.texture.offset;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .offset is now .texture.offset.\");\n      this.texture.offset = value;\n    }\n  },\n  repeat: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .repeat is now .texture.repeat.\");\n      return this.texture.repeat;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .repeat is now .texture.repeat.\");\n      this.texture.repeat = value;\n    }\n  },\n  format: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .format is now .texture.format.\");\n      return this.texture.format;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .format is now .texture.format.\");\n      this.texture.format = value;\n    }\n  },\n  type: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .type is now .texture.type.\");\n      return this.texture.type;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .type is now .texture.type.\");\n      this.texture.type = value;\n    }\n  },\n  generateMipmaps: {\n    get: function() {\n      console.warn(\"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.\");\n      return this.texture.generateMipmaps;\n    },\n    set: function(value) {\n      console.warn(\"THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.\");\n      this.texture.generateMipmaps = value;\n    }\n  }\n});\nAudio.prototype.load = function(file) {\n  console.warn(\"THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.\");\n  const scope = this;\n  const audioLoader = new AudioLoader();\n  audioLoader.load(file, function(buffer) {\n    scope.setBuffer(buffer);\n  });\n  return this;\n};\nAudioAnalyser.prototype.getData = function() {\n  console.warn(\"THREE.AudioAnalyser: .getData() is now .getFrequencyData().\");\n  return this.getFrequencyData();\n};\nCubeCamera.prototype.updateCubeMap = function(renderer, scene) {\n  console.warn(\"THREE.CubeCamera: .updateCubeMap() is now .update().\");\n  return this.update(renderer, scene);\n};\nCubeCamera.prototype.clear = function(renderer, color, depth, stencil) {\n  console.warn(\"THREE.CubeCamera: .clear() is now .renderTarget.clear().\");\n  return this.renderTarget.clear(renderer, color, depth, stencil);\n};\nImageUtils.crossOrigin = void 0;\nImageUtils.loadTexture = function(url, mapping, onLoad, onError) {\n  console.warn(\"THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.\");\n  const loader = new TextureLoader();\n  loader.setCrossOrigin(this.crossOrigin);\n  const texture = loader.load(url, onLoad, void 0, onError);\n  if (mapping)\n    texture.mapping = mapping;\n  return texture;\n};\nImageUtils.loadTextureCube = function(urls, mapping, onLoad, onError) {\n  console.warn(\"THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.\");\n  const loader = new CubeTextureLoader();\n  loader.setCrossOrigin(this.crossOrigin);\n  const texture = loader.load(urls, onLoad, void 0, onError);\n  if (mapping)\n    texture.mapping = mapping;\n  return texture;\n};\nImageUtils.loadCompressedTexture = function() {\n  console.error(\"THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.\");\n};\nImageUtils.loadCompressedTextureCube = function() {\n  console.error(\"THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.\");\n};\nfunction CanvasRenderer() {\n  console.error(\"THREE.CanvasRenderer has been removed\");\n}\nfunction JSONLoader() {\n  console.error(\"THREE.JSONLoader has been removed.\");\n}\nconst SceneUtils = {\n  createMultiMaterialObject: function() {\n    console.error(\"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js\");\n  },\n  detach: function() {\n    console.error(\"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js\");\n  },\n  attach: function() {\n    console.error(\"THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js\");\n  }\n};\nfunction LensFlare() {\n  console.error(\"THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js\");\n}\nif (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", {detail: {\n    revision: REVISION\n  }}));\n}\nif (typeof window !== \"undefined\") {\n  if (window.__THREE__) {\n    console.warn(\"WARNING: Multiple instances of Three.js being imported.\");\n  } else {\n    window.__THREE__ = REVISION;\n  }\n}\n\n\n\n//# sourceURL=webpack://esbuild-three-starter/./node_modules/three/build/three.module.js?");

/***/ }),

/***/ "./node_modules/three/examples/jsm/loaders/GLTFLoader.js":
/*!***************************************************************!*\
  !*** ./node_modules/three/examples/jsm/loaders/GLTFLoader.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLTFLoader\": () => (/* binding */ GLTFLoader)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nclass GLTFLoader extends three__WEBPACK_IMPORTED_MODULE_0__.Loader {\n  constructor(manager) {\n    super(manager);\n    this.dracoLoader = null;\n    this.ktx2Loader = null;\n    this.meshoptDecoder = null;\n    this.pluginCallbacks = [];\n    this.register(function(parser) {\n      return new GLTFMaterialsClearcoatExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureBasisUExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFTextureWebPExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMaterialsTransmissionExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFLightsExtension(parser);\n    });\n    this.register(function(parser) {\n      return new GLTFMeshoptCompression(parser);\n    });\n  }\n  load(url, onLoad, onProgress, onError) {\n    const scope = this;\n    let resourcePath;\n    if (this.resourcePath !== \"\") {\n      resourcePath = this.resourcePath;\n    } else if (this.path !== \"\") {\n      resourcePath = this.path;\n    } else {\n      resourcePath = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.extractUrlBase(url);\n    }\n    this.manager.itemStart(url);\n    const _onError = function(e) {\n      if (onError) {\n        onError(e);\n      } else {\n        console.error(e);\n      }\n      scope.manager.itemError(url);\n      scope.manager.itemEnd(url);\n    };\n    const loader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.manager);\n    loader.setPath(this.path);\n    loader.setResponseType(\"arraybuffer\");\n    loader.setRequestHeader(this.requestHeader);\n    loader.setWithCredentials(this.withCredentials);\n    loader.load(url, function(data) {\n      try {\n        scope.parse(data, resourcePath, function(gltf) {\n          onLoad(gltf);\n          scope.manager.itemEnd(url);\n        }, _onError);\n      } catch (e) {\n        _onError(e);\n      }\n    }, onProgress, _onError);\n  }\n  setDRACOLoader(dracoLoader) {\n    this.dracoLoader = dracoLoader;\n    return this;\n  }\n  setDDSLoader() {\n    throw new Error('THREE.GLTFLoader: \"MSFT_texture_dds\" no longer supported. Please update to \"KHR_texture_basisu\".');\n  }\n  setKTX2Loader(ktx2Loader) {\n    this.ktx2Loader = ktx2Loader;\n    return this;\n  }\n  setMeshoptDecoder(meshoptDecoder) {\n    this.meshoptDecoder = meshoptDecoder;\n    return this;\n  }\n  register(callback) {\n    if (this.pluginCallbacks.indexOf(callback) === -1) {\n      this.pluginCallbacks.push(callback);\n    }\n    return this;\n  }\n  unregister(callback) {\n    if (this.pluginCallbacks.indexOf(callback) !== -1) {\n      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);\n    }\n    return this;\n  }\n  parse(data, path, onLoad, onError) {\n    let content;\n    const extensions = {};\n    const plugins = {};\n    if (typeof data === \"string\") {\n      content = data;\n    } else {\n      const magic = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data, 0, 4));\n      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {\n        try {\n          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);\n        } catch (error) {\n          if (onError)\n            onError(error);\n          return;\n        }\n        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;\n      } else {\n        content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data));\n      }\n    }\n    const json = JSON.parse(content);\n    if (json.asset === void 0 || json.asset.version[0] < 2) {\n      if (onError)\n        onError(new Error(\"THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.\"));\n      return;\n    }\n    const parser = new GLTFParser(json, {\n      path: path || this.resourcePath || \"\",\n      crossOrigin: this.crossOrigin,\n      requestHeader: this.requestHeader,\n      manager: this.manager,\n      ktx2Loader: this.ktx2Loader,\n      meshoptDecoder: this.meshoptDecoder\n    });\n    parser.fileLoader.setRequestHeader(this.requestHeader);\n    for (let i = 0; i < this.pluginCallbacks.length; i++) {\n      const plugin = this.pluginCallbacks[i](parser);\n      plugins[plugin.name] = plugin;\n      extensions[plugin.name] = true;\n    }\n    if (json.extensionsUsed) {\n      for (let i = 0; i < json.extensionsUsed.length; ++i) {\n        const extensionName = json.extensionsUsed[i];\n        const extensionsRequired = json.extensionsRequired || [];\n        switch (extensionName) {\n          case EXTENSIONS.KHR_MATERIALS_UNLIT:\n            extensions[extensionName] = new GLTFMaterialsUnlitExtension();\n            break;\n          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:\n            extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();\n            break;\n          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:\n            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);\n            break;\n          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:\n            extensions[extensionName] = new GLTFTextureTransformExtension();\n            break;\n          case EXTENSIONS.KHR_MESH_QUANTIZATION:\n            extensions[extensionName] = new GLTFMeshQuantizationExtension();\n            break;\n          default:\n            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {\n              console.warn('THREE.GLTFLoader: Unknown extension \"' + extensionName + '\".');\n            }\n        }\n      }\n    }\n    parser.setExtensions(extensions);\n    parser.setPlugins(plugins);\n    parser.parse(onLoad, onError);\n  }\n}\nfunction GLTFRegistry() {\n  let objects = {};\n  return {\n    get: function(key) {\n      return objects[key];\n    },\n    add: function(key, object) {\n      objects[key] = object;\n    },\n    remove: function(key) {\n      delete objects[key];\n    },\n    removeAll: function() {\n      objects = {};\n    }\n  };\n}\nconst EXTENSIONS = {\n  KHR_BINARY_GLTF: \"KHR_binary_glTF\",\n  KHR_DRACO_MESH_COMPRESSION: \"KHR_draco_mesh_compression\",\n  KHR_LIGHTS_PUNCTUAL: \"KHR_lights_punctual\",\n  KHR_MATERIALS_CLEARCOAT: \"KHR_materials_clearcoat\",\n  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: \"KHR_materials_pbrSpecularGlossiness\",\n  KHR_MATERIALS_TRANSMISSION: \"KHR_materials_transmission\",\n  KHR_MATERIALS_UNLIT: \"KHR_materials_unlit\",\n  KHR_TEXTURE_BASISU: \"KHR_texture_basisu\",\n  KHR_TEXTURE_TRANSFORM: \"KHR_texture_transform\",\n  KHR_MESH_QUANTIZATION: \"KHR_mesh_quantization\",\n  EXT_TEXTURE_WEBP: \"EXT_texture_webp\",\n  EXT_MESHOPT_COMPRESSION: \"EXT_meshopt_compression\"\n};\nclass GLTFLightsExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;\n    this.cache = {refs: {}, uses: {}};\n  }\n  _markDefs() {\n    const parser = this.parser;\n    const nodeDefs = this.parser.json.nodes || [];\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {\n        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);\n      }\n    }\n  }\n  _loadLight(lightIndex) {\n    const parser = this.parser;\n    const cacheKey = \"light:\" + lightIndex;\n    let dependency = parser.cache.get(cacheKey);\n    if (dependency)\n      return dependency;\n    const json = parser.json;\n    const extensions = json.extensions && json.extensions[this.name] || {};\n    const lightDefs = extensions.lights || [];\n    const lightDef = lightDefs[lightIndex];\n    let lightNode;\n    const color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(16777215);\n    if (lightDef.color !== void 0)\n      color.fromArray(lightDef.color);\n    const range = lightDef.range !== void 0 ? lightDef.range : 0;\n    switch (lightDef.type) {\n      case \"directional\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.DirectionalLight(color);\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      case \"point\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.PointLight(color);\n        lightNode.distance = range;\n        break;\n      case \"spot\":\n        lightNode = new three__WEBPACK_IMPORTED_MODULE_0__.SpotLight(color);\n        lightNode.distance = range;\n        lightDef.spot = lightDef.spot || {};\n        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;\n        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;\n        lightNode.angle = lightDef.spot.outerConeAngle;\n        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;\n        lightNode.target.position.set(0, 0, -1);\n        lightNode.add(lightNode.target);\n        break;\n      default:\n        throw new Error(\"THREE.GLTFLoader: Unexpected light type: \" + lightDef.type);\n    }\n    lightNode.position.set(0, 0, 0);\n    lightNode.decay = 2;\n    if (lightDef.intensity !== void 0)\n      lightNode.intensity = lightDef.intensity;\n    lightNode.name = parser.createUniqueName(lightDef.name || \"light_\" + lightIndex);\n    dependency = Promise.resolve(lightNode);\n    parser.cache.add(cacheKey, dependency);\n    return dependency;\n  }\n  createNodeAttachment(nodeIndex) {\n    const self2 = this;\n    const parser = this.parser;\n    const json = parser.json;\n    const nodeDef = json.nodes[nodeIndex];\n    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};\n    const lightIndex = lightDef.light;\n    if (lightIndex === void 0)\n      return null;\n    return this._loadLight(lightIndex).then(function(light) {\n      return parser._getNodeRef(self2.cache, lightIndex, light);\n    });\n  }\n}\nclass GLTFMaterialsUnlitExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pending = [];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const metallicRoughness = materialDef.pbrMetallicRoughness;\n    if (metallicRoughness) {\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture));\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsClearcoatExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.clearcoatFactor !== void 0) {\n      materialParams.clearcoat = extension.clearcoatFactor;\n    }\n    if (extension.clearcoatTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatMap\", extension.clearcoatTexture));\n    }\n    if (extension.clearcoatRoughnessFactor !== void 0) {\n      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;\n    }\n    if (extension.clearcoatRoughnessTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatRoughnessMap\", extension.clearcoatRoughnessTexture));\n    }\n    if (extension.clearcoatNormalTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"clearcoatNormalMap\", extension.clearcoatNormalTexture));\n      if (extension.clearcoatNormalTexture.scale !== void 0) {\n        const scale = extension.clearcoatNormalTexture.scale;\n        materialParams.clearcoatNormalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(scale, -scale);\n      }\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFMaterialsTransmissionExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;\n  }\n  getMaterialType(materialIndex) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name])\n      return null;\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshPhysicalMaterial;\n  }\n  extendMaterialParams(materialIndex, materialParams) {\n    const parser = this.parser;\n    const materialDef = parser.json.materials[materialIndex];\n    if (!materialDef.extensions || !materialDef.extensions[this.name]) {\n      return Promise.resolve();\n    }\n    const pending = [];\n    const extension = materialDef.extensions[this.name];\n    if (extension.transmissionFactor !== void 0) {\n      materialParams.transmission = extension.transmissionFactor;\n    }\n    if (extension.transmissionTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"transmissionMap\", extension.transmissionTexture));\n    }\n    return Promise.all(pending);\n  }\n}\nclass GLTFTextureBasisUExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;\n  }\n  loadTexture(textureIndex) {\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[this.name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[this.name];\n    const source = json.images[extension.source];\n    const loader = parser.options.ktx2Loader;\n    if (!loader) {\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures\");\n      } else {\n        return null;\n      }\n    }\n    return parser.loadTextureImage(textureIndex, source, loader);\n  }\n}\nclass GLTFTextureWebPExtension {\n  constructor(parser) {\n    this.parser = parser;\n    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;\n    this.isSupported = null;\n  }\n  loadTexture(textureIndex) {\n    const name = this.name;\n    const parser = this.parser;\n    const json = parser.json;\n    const textureDef = json.textures[textureIndex];\n    if (!textureDef.extensions || !textureDef.extensions[name]) {\n      return null;\n    }\n    const extension = textureDef.extensions[name];\n    const source = json.images[extension.source];\n    let loader = parser.textureLoader;\n    if (source.uri) {\n      const handler = parser.options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.detectSupport().then(function(isSupported) {\n      if (isSupported)\n        return parser.loadTextureImage(textureIndex, source, loader);\n      if (json.extensionsRequired && json.extensionsRequired.indexOf(name) >= 0) {\n        throw new Error(\"THREE.GLTFLoader: WebP required by asset but unsupported.\");\n      }\n      return parser.loadTexture(textureIndex);\n    });\n  }\n  detectSupport() {\n    if (!this.isSupported) {\n      this.isSupported = new Promise(function(resolve) {\n        const image = new Image();\n        image.src = \"data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA\";\n        image.onload = image.onerror = function() {\n          resolve(image.height === 1);\n        };\n      });\n    }\n    return this.isSupported;\n  }\n}\nclass GLTFMeshoptCompression {\n  constructor(parser) {\n    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;\n    this.parser = parser;\n  }\n  loadBufferView(index) {\n    const json = this.parser.json;\n    const bufferView = json.bufferViews[index];\n    if (bufferView.extensions && bufferView.extensions[this.name]) {\n      const extensionDef = bufferView.extensions[this.name];\n      const buffer = this.parser.getDependency(\"buffer\", extensionDef.buffer);\n      const decoder = this.parser.options.meshoptDecoder;\n      if (!decoder || !decoder.supported) {\n        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {\n          throw new Error(\"THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files\");\n        } else {\n          return null;\n        }\n      }\n      return Promise.all([buffer, decoder.ready]).then(function(res) {\n        const byteOffset = extensionDef.byteOffset || 0;\n        const byteLength = extensionDef.byteLength || 0;\n        const count = extensionDef.count;\n        const stride = extensionDef.byteStride;\n        const result = new ArrayBuffer(count * stride);\n        const source = new Uint8Array(res[0], byteOffset, byteLength);\n        decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);\n        return result;\n      });\n    } else {\n      return null;\n    }\n  }\n}\nconst BINARY_EXTENSION_HEADER_MAGIC = \"glTF\";\nconst BINARY_EXTENSION_HEADER_LENGTH = 12;\nconst BINARY_EXTENSION_CHUNK_TYPES = {JSON: 1313821514, BIN: 5130562};\nclass GLTFBinaryExtension {\n  constructor(data) {\n    this.name = EXTENSIONS.KHR_BINARY_GLTF;\n    this.content = null;\n    this.body = null;\n    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);\n    this.header = {\n      magic: three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),\n      version: headerView.getUint32(4, true),\n      length: headerView.getUint32(8, true)\n    };\n    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {\n      throw new Error(\"THREE.GLTFLoader: Unsupported glTF-Binary header.\");\n    } else if (this.header.version < 2) {\n      throw new Error(\"THREE.GLTFLoader: Legacy binary file detected.\");\n    }\n    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;\n    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);\n    let chunkIndex = 0;\n    while (chunkIndex < chunkContentsLength) {\n      const chunkLength = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      const chunkType = chunkView.getUint32(chunkIndex, true);\n      chunkIndex += 4;\n      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {\n        const contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);\n        this.content = three__WEBPACK_IMPORTED_MODULE_0__.LoaderUtils.decodeText(contentArray);\n      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {\n        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;\n        this.body = data.slice(byteOffset, byteOffset + chunkLength);\n      }\n      chunkIndex += chunkLength;\n    }\n    if (this.content === null) {\n      throw new Error(\"THREE.GLTFLoader: JSON content not found.\");\n    }\n  }\n}\nclass GLTFDracoMeshCompressionExtension {\n  constructor(json, dracoLoader) {\n    if (!dracoLoader) {\n      throw new Error(\"THREE.GLTFLoader: No DRACOLoader instance provided.\");\n    }\n    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;\n    this.json = json;\n    this.dracoLoader = dracoLoader;\n    this.dracoLoader.preload();\n  }\n  decodePrimitive(primitive, parser) {\n    const json = this.json;\n    const dracoLoader = this.dracoLoader;\n    const bufferViewIndex = primitive.extensions[this.name].bufferView;\n    const gltfAttributeMap = primitive.extensions[this.name].attributes;\n    const threeAttributeMap = {};\n    const attributeNormalizedMap = {};\n    const attributeTypeMap = {};\n    for (const attributeName in gltfAttributeMap) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];\n    }\n    for (const attributeName in primitive.attributes) {\n      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();\n      if (gltfAttributeMap[attributeName] !== void 0) {\n        const accessorDef = json.accessors[primitive.attributes[attributeName]];\n        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n        attributeTypeMap[threeAttributeName] = componentType;\n        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;\n      }\n    }\n    return parser.getDependency(\"bufferView\", bufferViewIndex).then(function(bufferView) {\n      return new Promise(function(resolve) {\n        dracoLoader.decodeDracoFile(bufferView, function(geometry) {\n          for (const attributeName in geometry.attributes) {\n            const attribute = geometry.attributes[attributeName];\n            const normalized = attributeNormalizedMap[attributeName];\n            if (normalized !== void 0)\n              attribute.normalized = normalized;\n          }\n          resolve(geometry);\n        }, threeAttributeMap, attributeTypeMap);\n      });\n    });\n  }\n}\nclass GLTFTextureTransformExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;\n  }\n  extendTexture(texture, transform) {\n    texture = texture.clone();\n    if (transform.offset !== void 0) {\n      texture.offset.fromArray(transform.offset);\n    }\n    if (transform.rotation !== void 0) {\n      texture.rotation = transform.rotation;\n    }\n    if (transform.scale !== void 0) {\n      texture.repeat.fromArray(transform.scale);\n    }\n    if (transform.texCoord !== void 0) {\n      console.warn('THREE.GLTFLoader: Custom UV sets in \"' + this.name + '\" extension not yet supported.');\n    }\n    texture.needsUpdate = true;\n    return texture;\n  }\n}\nclass GLTFMeshStandardSGMaterial extends three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial {\n  constructor(params) {\n    super();\n    this.isGLTFSpecularGlossinessMaterial = true;\n    const specularMapParsFragmentChunk = [\n      \"#ifdef USE_SPECULARMAP\",\n      \"\tuniform sampler2D specularMap;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const glossinessMapParsFragmentChunk = [\n      \"#ifdef USE_GLOSSINESSMAP\",\n      \"\tuniform sampler2D glossinessMap;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const specularMapFragmentChunk = [\n      \"vec3 specularFactor = specular;\",\n      \"#ifdef USE_SPECULARMAP\",\n      \"\tvec4 texelSpecular = texture2D( specularMap, vUv );\",\n      \"\ttexelSpecular = sRGBToLinear( texelSpecular );\",\n      \"\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture\",\n      \"\tspecularFactor *= texelSpecular.rgb;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const glossinessMapFragmentChunk = [\n      \"float glossinessFactor = glossiness;\",\n      \"#ifdef USE_GLOSSINESSMAP\",\n      \"\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );\",\n      \"\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture\",\n      \"\tglossinessFactor *= texelGlossiness.a;\",\n      \"#endif\"\n    ].join(\"\\n\");\n    const lightPhysicalFragmentChunk = [\n      \"PhysicalMaterial material;\",\n      \"material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );\",\n      \"vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\",\n      \"float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\",\n      \"material.specularRoughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.\",\n      \"material.specularRoughness += geometryRoughness;\",\n      \"material.specularRoughness = min( material.specularRoughness, 1.0 );\",\n      \"material.specularColor = specularFactor;\"\n    ].join(\"\\n\");\n    const uniforms = {\n      specular: {value: new three__WEBPACK_IMPORTED_MODULE_0__.Color().setHex(16777215)},\n      glossiness: {value: 1},\n      specularMap: {value: null},\n      glossinessMap: {value: null}\n    };\n    this._extraUniforms = uniforms;\n    this.onBeforeCompile = function(shader) {\n      for (const uniformName in uniforms) {\n        shader.uniforms[uniformName] = uniforms[uniformName];\n      }\n      shader.fragmentShader = shader.fragmentShader.replace(\"uniform float roughness;\", \"uniform vec3 specular;\").replace(\"uniform float metalness;\", \"uniform float glossiness;\").replace(\"#include <roughnessmap_pars_fragment>\", specularMapParsFragmentChunk).replace(\"#include <metalnessmap_pars_fragment>\", glossinessMapParsFragmentChunk).replace(\"#include <roughnessmap_fragment>\", specularMapFragmentChunk).replace(\"#include <metalnessmap_fragment>\", glossinessMapFragmentChunk).replace(\"#include <lights_physical_fragment>\", lightPhysicalFragmentChunk);\n    };\n    Object.defineProperties(this, {\n      specular: {\n        get: function() {\n          return uniforms.specular.value;\n        },\n        set: function(v) {\n          uniforms.specular.value = v;\n        }\n      },\n      specularMap: {\n        get: function() {\n          return uniforms.specularMap.value;\n        },\n        set: function(v) {\n          uniforms.specularMap.value = v;\n          if (v) {\n            this.defines.USE_SPECULARMAP = \"\";\n          } else {\n            delete this.defines.USE_SPECULARMAP;\n          }\n        }\n      },\n      glossiness: {\n        get: function() {\n          return uniforms.glossiness.value;\n        },\n        set: function(v) {\n          uniforms.glossiness.value = v;\n        }\n      },\n      glossinessMap: {\n        get: function() {\n          return uniforms.glossinessMap.value;\n        },\n        set: function(v) {\n          uniforms.glossinessMap.value = v;\n          if (v) {\n            this.defines.USE_GLOSSINESSMAP = \"\";\n            this.defines.USE_UV = \"\";\n          } else {\n            delete this.defines.USE_GLOSSINESSMAP;\n            delete this.defines.USE_UV;\n          }\n        }\n      }\n    });\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    this.setValues(params);\n  }\n  copy(source) {\n    super.copy(source);\n    this.specularMap = source.specularMap;\n    this.specular.copy(source.specular);\n    this.glossinessMap = source.glossinessMap;\n    this.glossiness = source.glossiness;\n    delete this.metalness;\n    delete this.roughness;\n    delete this.metalnessMap;\n    delete this.roughnessMap;\n    return this;\n  }\n}\nclass GLTFMaterialsPbrSpecularGlossinessExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS;\n    this.specularGlossinessParams = [\n      \"color\",\n      \"map\",\n      \"lightMap\",\n      \"lightMapIntensity\",\n      \"aoMap\",\n      \"aoMapIntensity\",\n      \"emissive\",\n      \"emissiveIntensity\",\n      \"emissiveMap\",\n      \"bumpMap\",\n      \"bumpScale\",\n      \"normalMap\",\n      \"normalMapType\",\n      \"displacementMap\",\n      \"displacementScale\",\n      \"displacementBias\",\n      \"specularMap\",\n      \"specular\",\n      \"glossinessMap\",\n      \"glossiness\",\n      \"alphaMap\",\n      \"envMap\",\n      \"envMapIntensity\",\n      \"refractionRatio\"\n    ];\n  }\n  getMaterialType() {\n    return GLTFMeshStandardSGMaterial;\n  }\n  extendParams(materialParams, materialDef, parser) {\n    const pbrSpecularGlossiness = materialDef.extensions[this.name];\n    materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    materialParams.opacity = 1;\n    const pending = [];\n    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {\n      const array = pbrSpecularGlossiness.diffuseFactor;\n      materialParams.color.fromArray(array);\n      materialParams.opacity = array[3];\n    }\n    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {\n      pending.push(parser.assignTexture(materialParams, \"map\", pbrSpecularGlossiness.diffuseTexture));\n    }\n    materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n    materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== void 0 ? pbrSpecularGlossiness.glossinessFactor : 1;\n    materialParams.specular = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {\n      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);\n    }\n    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {\n      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;\n      pending.push(parser.assignTexture(materialParams, \"glossinessMap\", specGlossMapDef));\n      pending.push(parser.assignTexture(materialParams, \"specularMap\", specGlossMapDef));\n    }\n    return Promise.all(pending);\n  }\n  createMaterial(materialParams) {\n    const material = new GLTFMeshStandardSGMaterial(materialParams);\n    material.fog = true;\n    material.color = materialParams.color;\n    material.map = materialParams.map === void 0 ? null : materialParams.map;\n    material.lightMap = null;\n    material.lightMapIntensity = 1;\n    material.aoMap = materialParams.aoMap === void 0 ? null : materialParams.aoMap;\n    material.aoMapIntensity = 1;\n    material.emissive = materialParams.emissive;\n    material.emissiveIntensity = 1;\n    material.emissiveMap = materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap;\n    material.bumpMap = materialParams.bumpMap === void 0 ? null : materialParams.bumpMap;\n    material.bumpScale = 1;\n    material.normalMap = materialParams.normalMap === void 0 ? null : materialParams.normalMap;\n    material.normalMapType = three__WEBPACK_IMPORTED_MODULE_0__.TangentSpaceNormalMap;\n    if (materialParams.normalScale)\n      material.normalScale = materialParams.normalScale;\n    material.displacementMap = null;\n    material.displacementScale = 1;\n    material.displacementBias = 0;\n    material.specularMap = materialParams.specularMap === void 0 ? null : materialParams.specularMap;\n    material.specular = materialParams.specular;\n    material.glossinessMap = materialParams.glossinessMap === void 0 ? null : materialParams.glossinessMap;\n    material.glossiness = materialParams.glossiness;\n    material.alphaMap = null;\n    material.envMap = materialParams.envMap === void 0 ? null : materialParams.envMap;\n    material.envMapIntensity = 1;\n    material.refractionRatio = 0.98;\n    return material;\n  }\n}\nclass GLTFMeshQuantizationExtension {\n  constructor() {\n    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;\n  }\n}\nclass GLTFCubicSplineInterpolant extends three__WEBPACK_IMPORTED_MODULE_0__.Interpolant {\n  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {\n    super(parameterPositions, sampleValues, sampleSize, resultBuffer);\n  }\n  copySampleValue_(index) {\n    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;\n    for (let i = 0; i !== valueSize; i++) {\n      result[i] = values[offset + i];\n    }\n    return result;\n  }\n}\nGLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;\nGLTFCubicSplineInterpolant.prototype.interpolate_ = function(i1, t0, t, t1) {\n  const result = this.resultBuffer;\n  const values = this.sampleValues;\n  const stride = this.valueSize;\n  const stride2 = stride * 2;\n  const stride3 = stride * 3;\n  const td = t1 - t0;\n  const p = (t - t0) / td;\n  const pp = p * p;\n  const ppp = pp * p;\n  const offset1 = i1 * stride3;\n  const offset0 = offset1 - stride3;\n  const s2 = -2 * ppp + 3 * pp;\n  const s3 = ppp - pp;\n  const s0 = 1 - s2;\n  const s1 = s3 - pp + p;\n  for (let i = 0; i !== stride; i++) {\n    const p0 = values[offset0 + i + stride];\n    const m0 = values[offset0 + i + stride2] * td;\n    const p1 = values[offset1 + i + stride];\n    const m1 = values[offset1 + i] * td;\n    result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;\n  }\n  return result;\n};\nconst WEBGL_CONSTANTS = {\n  FLOAT: 5126,\n  FLOAT_MAT3: 35675,\n  FLOAT_MAT4: 35676,\n  FLOAT_VEC2: 35664,\n  FLOAT_VEC3: 35665,\n  FLOAT_VEC4: 35666,\n  LINEAR: 9729,\n  REPEAT: 10497,\n  SAMPLER_2D: 35678,\n  POINTS: 0,\n  LINES: 1,\n  LINE_LOOP: 2,\n  LINE_STRIP: 3,\n  TRIANGLES: 4,\n  TRIANGLE_STRIP: 5,\n  TRIANGLE_FAN: 6,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_SHORT: 5123\n};\nconst WEBGL_COMPONENT_TYPES = {\n  5120: Int8Array,\n  5121: Uint8Array,\n  5122: Int16Array,\n  5123: Uint16Array,\n  5125: Uint32Array,\n  5126: Float32Array\n};\nconst WEBGL_FILTERS = {\n  9728: three__WEBPACK_IMPORTED_MODULE_0__.NearestFilter,\n  9729: three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter,\n  9984: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapNearestFilter,\n  9985: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapNearestFilter,\n  9986: three__WEBPACK_IMPORTED_MODULE_0__.NearestMipmapLinearFilter,\n  9987: three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter\n};\nconst WEBGL_WRAPPINGS = {\n  33071: three__WEBPACK_IMPORTED_MODULE_0__.ClampToEdgeWrapping,\n  33648: three__WEBPACK_IMPORTED_MODULE_0__.MirroredRepeatWrapping,\n  10497: three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping\n};\nconst WEBGL_TYPE_SIZES = {\n  \"SCALAR\": 1,\n  \"VEC2\": 2,\n  \"VEC3\": 3,\n  \"VEC4\": 4,\n  \"MAT2\": 4,\n  \"MAT3\": 9,\n  \"MAT4\": 16\n};\nconst ATTRIBUTES = {\n  POSITION: \"position\",\n  NORMAL: \"normal\",\n  TANGENT: \"tangent\",\n  TEXCOORD_0: \"uv\",\n  TEXCOORD_1: \"uv2\",\n  COLOR_0: \"color\",\n  WEIGHTS_0: \"skinWeight\",\n  JOINTS_0: \"skinIndex\"\n};\nconst PATH_PROPERTIES = {\n  scale: \"scale\",\n  translation: \"position\",\n  rotation: \"quaternion\",\n  weights: \"morphTargetInfluences\"\n};\nconst INTERPOLATION = {\n  CUBICSPLINE: void 0,\n  LINEAR: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear,\n  STEP: three__WEBPACK_IMPORTED_MODULE_0__.InterpolateDiscrete\n};\nconst ALPHA_MODES = {\n  OPAQUE: \"OPAQUE\",\n  MASK: \"MASK\",\n  BLEND: \"BLEND\"\n};\nfunction resolveURL(url, path) {\n  if (typeof url !== \"string\" || url === \"\")\n    return \"\";\n  if (/^https?:\\/\\//i.test(path) && /^\\//.test(url)) {\n    path = path.replace(/(^https?:\\/\\/[^\\/]+).*/i, \"$1\");\n  }\n  if (/^(https?:)?\\/\\//i.test(url))\n    return url;\n  if (/^data:.*,.*$/i.test(url))\n    return url;\n  if (/^blob:.*$/i.test(url))\n    return url;\n  return path + url;\n}\nfunction createDefaultMaterial(cache) {\n  if (cache[\"DefaultMaterial\"] === void 0) {\n    cache[\"DefaultMaterial\"] = new three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial({\n      color: 16777215,\n      emissive: 0,\n      metalness: 1,\n      roughness: 1,\n      transparent: false,\n      depthTest: true,\n      side: three__WEBPACK_IMPORTED_MODULE_0__.FrontSide\n    });\n  }\n  return cache[\"DefaultMaterial\"];\n}\nfunction addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {\n  for (const name in objectDef.extensions) {\n    if (knownExtensions[name] === void 0) {\n      object.userData.gltfExtensions = object.userData.gltfExtensions || {};\n      object.userData.gltfExtensions[name] = objectDef.extensions[name];\n    }\n  }\n}\nfunction assignExtrasToUserData(object, gltfDef) {\n  if (gltfDef.extras !== void 0) {\n    if (typeof gltfDef.extras === \"object\") {\n      Object.assign(object.userData, gltfDef.extras);\n    } else {\n      console.warn(\"THREE.GLTFLoader: Ignoring primitive type .extras, \" + gltfDef.extras);\n    }\n  }\n}\nfunction addMorphTargets(geometry, targets, parser) {\n  let hasMorphPosition = false;\n  let hasMorphNormal = false;\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (target.POSITION !== void 0)\n      hasMorphPosition = true;\n    if (target.NORMAL !== void 0)\n      hasMorphNormal = true;\n    if (hasMorphPosition && hasMorphNormal)\n      break;\n  }\n  if (!hasMorphPosition && !hasMorphNormal)\n    return Promise.resolve(geometry);\n  const pendingPositionAccessors = [];\n  const pendingNormalAccessors = [];\n  for (let i = 0, il = targets.length; i < il; i++) {\n    const target = targets[i];\n    if (hasMorphPosition) {\n      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency(\"accessor\", target.POSITION) : geometry.attributes.position;\n      pendingPositionAccessors.push(pendingAccessor);\n    }\n    if (hasMorphNormal) {\n      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency(\"accessor\", target.NORMAL) : geometry.attributes.normal;\n      pendingNormalAccessors.push(pendingAccessor);\n    }\n  }\n  return Promise.all([\n    Promise.all(pendingPositionAccessors),\n    Promise.all(pendingNormalAccessors)\n  ]).then(function(accessors) {\n    const morphPositions = accessors[0];\n    const morphNormals = accessors[1];\n    if (hasMorphPosition)\n      geometry.morphAttributes.position = morphPositions;\n    if (hasMorphNormal)\n      geometry.morphAttributes.normal = morphNormals;\n    geometry.morphTargetsRelative = true;\n    return geometry;\n  });\n}\nfunction updateMorphTargets(mesh, meshDef) {\n  mesh.updateMorphTargets();\n  if (meshDef.weights !== void 0) {\n    for (let i = 0, il = meshDef.weights.length; i < il; i++) {\n      mesh.morphTargetInfluences[i] = meshDef.weights[i];\n    }\n  }\n  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {\n    const targetNames = meshDef.extras.targetNames;\n    if (mesh.morphTargetInfluences.length === targetNames.length) {\n      mesh.morphTargetDictionary = {};\n      for (let i = 0, il = targetNames.length; i < il; i++) {\n        mesh.morphTargetDictionary[targetNames[i]] = i;\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.\");\n    }\n  }\n}\nfunction createPrimitiveKey(primitiveDef) {\n  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];\n  let geometryKey;\n  if (dracoExtension) {\n    geometryKey = \"draco:\" + dracoExtension.bufferView + \":\" + dracoExtension.indices + \":\" + createAttributesKey(dracoExtension.attributes);\n  } else {\n    geometryKey = primitiveDef.indices + \":\" + createAttributesKey(primitiveDef.attributes) + \":\" + primitiveDef.mode;\n  }\n  return geometryKey;\n}\nfunction createAttributesKey(attributes) {\n  let attributesKey = \"\";\n  const keys = Object.keys(attributes).sort();\n  for (let i = 0, il = keys.length; i < il; i++) {\n    attributesKey += keys[i] + \":\" + attributes[keys[i]] + \";\";\n  }\n  return attributesKey;\n}\nfunction getNormalizedComponentScale(constructor) {\n  switch (constructor) {\n    case Int8Array:\n      return 1 / 127;\n    case Uint8Array:\n      return 1 / 255;\n    case Int16Array:\n      return 1 / 32767;\n    case Uint16Array:\n      return 1 / 65535;\n    default:\n      throw new Error(\"THREE.GLTFLoader: Unsupported normalized accessor component type.\");\n  }\n}\nclass GLTFParser {\n  constructor(json = {}, options = {}) {\n    this.json = json;\n    this.extensions = {};\n    this.plugins = {};\n    this.options = options;\n    this.cache = new GLTFRegistry();\n    this.associations = new Map();\n    this.primitiveCache = {};\n    this.meshCache = {refs: {}, uses: {}};\n    this.cameraCache = {refs: {}, uses: {}};\n    this.lightCache = {refs: {}, uses: {}};\n    this.nodeNamesUsed = {};\n    if (typeof createImageBitmap !== \"undefined\" && /Firefox/.test(navigator.userAgent) === false) {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.ImageBitmapLoader(this.options.manager);\n    } else {\n      this.textureLoader = new three__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this.options.manager);\n    }\n    this.textureLoader.setCrossOrigin(this.options.crossOrigin);\n    this.textureLoader.setRequestHeader(this.options.requestHeader);\n    this.fileLoader = new three__WEBPACK_IMPORTED_MODULE_0__.FileLoader(this.options.manager);\n    this.fileLoader.setResponseType(\"arraybuffer\");\n    if (this.options.crossOrigin === \"use-credentials\") {\n      this.fileLoader.setWithCredentials(true);\n    }\n  }\n  setExtensions(extensions) {\n    this.extensions = extensions;\n  }\n  setPlugins(plugins) {\n    this.plugins = plugins;\n  }\n  parse(onLoad, onError) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    this.cache.removeAll();\n    this._invokeAll(function(ext) {\n      return ext._markDefs && ext._markDefs();\n    });\n    Promise.all(this._invokeAll(function(ext) {\n      return ext.beforeRoot && ext.beforeRoot();\n    })).then(function() {\n      return Promise.all([\n        parser.getDependencies(\"scene\"),\n        parser.getDependencies(\"animation\"),\n        parser.getDependencies(\"camera\")\n      ]);\n    }).then(function(dependencies) {\n      const result = {\n        scene: dependencies[0][json.scene || 0],\n        scenes: dependencies[0],\n        animations: dependencies[1],\n        cameras: dependencies[2],\n        asset: json.asset,\n        parser,\n        userData: {}\n      };\n      addUnknownExtensionsToUserData(extensions, result, json);\n      assignExtrasToUserData(result, json);\n      Promise.all(parser._invokeAll(function(ext) {\n        return ext.afterRoot && ext.afterRoot(result);\n      })).then(function() {\n        onLoad(result);\n      });\n    }).catch(onError);\n  }\n  _markDefs() {\n    const nodeDefs = this.json.nodes || [];\n    const skinDefs = this.json.skins || [];\n    const meshDefs = this.json.meshes || [];\n    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {\n      const joints = skinDefs[skinIndex].joints;\n      for (let i = 0, il = joints.length; i < il; i++) {\n        nodeDefs[joints[i]].isBone = true;\n      }\n    }\n    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {\n      const nodeDef = nodeDefs[nodeIndex];\n      if (nodeDef.mesh !== void 0) {\n        this._addNodeRef(this.meshCache, nodeDef.mesh);\n        if (nodeDef.skin !== void 0) {\n          meshDefs[nodeDef.mesh].isSkinnedMesh = true;\n        }\n      }\n      if (nodeDef.camera !== void 0) {\n        this._addNodeRef(this.cameraCache, nodeDef.camera);\n      }\n    }\n  }\n  _addNodeRef(cache, index) {\n    if (index === void 0)\n      return;\n    if (cache.refs[index] === void 0) {\n      cache.refs[index] = cache.uses[index] = 0;\n    }\n    cache.refs[index]++;\n  }\n  _getNodeRef(cache, index, object) {\n    if (cache.refs[index] <= 1)\n      return object;\n    const ref = object.clone();\n    ref.name += \"_instance_\" + cache.uses[index]++;\n    return ref;\n  }\n  _invokeOne(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.push(this);\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        return result;\n    }\n    return null;\n  }\n  _invokeAll(func) {\n    const extensions = Object.values(this.plugins);\n    extensions.unshift(this);\n    const pending = [];\n    for (let i = 0; i < extensions.length; i++) {\n      const result = func(extensions[i]);\n      if (result)\n        pending.push(result);\n    }\n    return pending;\n  }\n  getDependency(type, index) {\n    const cacheKey = type + \":\" + index;\n    let dependency = this.cache.get(cacheKey);\n    if (!dependency) {\n      switch (type) {\n        case \"scene\":\n          dependency = this.loadScene(index);\n          break;\n        case \"node\":\n          dependency = this.loadNode(index);\n          break;\n        case \"mesh\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMesh && ext.loadMesh(index);\n          });\n          break;\n        case \"accessor\":\n          dependency = this.loadAccessor(index);\n          break;\n        case \"bufferView\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadBufferView && ext.loadBufferView(index);\n          });\n          break;\n        case \"buffer\":\n          dependency = this.loadBuffer(index);\n          break;\n        case \"material\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadMaterial && ext.loadMaterial(index);\n          });\n          break;\n        case \"texture\":\n          dependency = this._invokeOne(function(ext) {\n            return ext.loadTexture && ext.loadTexture(index);\n          });\n          break;\n        case \"skin\":\n          dependency = this.loadSkin(index);\n          break;\n        case \"animation\":\n          dependency = this.loadAnimation(index);\n          break;\n        case \"camera\":\n          dependency = this.loadCamera(index);\n          break;\n        default:\n          throw new Error(\"Unknown type: \" + type);\n      }\n      this.cache.add(cacheKey, dependency);\n    }\n    return dependency;\n  }\n  getDependencies(type) {\n    let dependencies = this.cache.get(type);\n    if (!dependencies) {\n      const parser = this;\n      const defs = this.json[type + (type === \"mesh\" ? \"es\" : \"s\")] || [];\n      dependencies = Promise.all(defs.map(function(def, index) {\n        return parser.getDependency(type, index);\n      }));\n      this.cache.add(type, dependencies);\n    }\n    return dependencies;\n  }\n  loadBuffer(bufferIndex) {\n    const bufferDef = this.json.buffers[bufferIndex];\n    const loader = this.fileLoader;\n    if (bufferDef.type && bufferDef.type !== \"arraybuffer\") {\n      throw new Error(\"THREE.GLTFLoader: \" + bufferDef.type + \" buffer type is not supported.\");\n    }\n    if (bufferDef.uri === void 0 && bufferIndex === 0) {\n      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);\n    }\n    const options = this.options;\n    return new Promise(function(resolve, reject) {\n      loader.load(resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {\n        reject(new Error('THREE.GLTFLoader: Failed to load buffer \"' + bufferDef.uri + '\".'));\n      });\n    });\n  }\n  loadBufferView(bufferViewIndex) {\n    const bufferViewDef = this.json.bufferViews[bufferViewIndex];\n    return this.getDependency(\"buffer\", bufferViewDef.buffer).then(function(buffer) {\n      const byteLength = bufferViewDef.byteLength || 0;\n      const byteOffset = bufferViewDef.byteOffset || 0;\n      return buffer.slice(byteOffset, byteOffset + byteLength);\n    });\n  }\n  loadAccessor(accessorIndex) {\n    const parser = this;\n    const json = this.json;\n    const accessorDef = this.json.accessors[accessorIndex];\n    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {\n      return Promise.resolve(null);\n    }\n    const pendingBufferViews = [];\n    if (accessorDef.bufferView !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.bufferView));\n    } else {\n      pendingBufferViews.push(null);\n    }\n    if (accessorDef.sparse !== void 0) {\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.indices.bufferView));\n      pendingBufferViews.push(this.getDependency(\"bufferView\", accessorDef.sparse.values.bufferView));\n    }\n    return Promise.all(pendingBufferViews).then(function(bufferViews) {\n      const bufferView = bufferViews[0];\n      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];\n      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];\n      const elementBytes = TypedArray.BYTES_PER_ELEMENT;\n      const itemBytes = elementBytes * itemSize;\n      const byteOffset = accessorDef.byteOffset || 0;\n      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;\n      const normalized = accessorDef.normalized === true;\n      let array, bufferAttribute;\n      if (byteStride && byteStride !== itemBytes) {\n        const ibSlice = Math.floor(byteOffset / byteStride);\n        const ibCacheKey = \"InterleavedBuffer:\" + accessorDef.bufferView + \":\" + accessorDef.componentType + \":\" + ibSlice + \":\" + accessorDef.count;\n        let ib = parser.cache.get(ibCacheKey);\n        if (!ib) {\n          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);\n          ib = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBuffer(array, byteStride / elementBytes);\n          parser.cache.add(ibCacheKey, ib);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);\n      } else {\n        if (bufferView === null) {\n          array = new TypedArray(accessorDef.count * itemSize);\n        } else {\n          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);\n        }\n        bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(array, itemSize, normalized);\n      }\n      if (accessorDef.sparse !== void 0) {\n        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;\n        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];\n        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;\n        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;\n        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);\n        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);\n        if (bufferView !== null) {\n          bufferAttribute = new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);\n        }\n        for (let i = 0, il = sparseIndices.length; i < il; i++) {\n          const index = sparseIndices[i];\n          bufferAttribute.setX(index, sparseValues[i * itemSize]);\n          if (itemSize >= 2)\n            bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);\n          if (itemSize >= 3)\n            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);\n          if (itemSize >= 4)\n            bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);\n          if (itemSize >= 5)\n            throw new Error(\"THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.\");\n        }\n      }\n      return bufferAttribute;\n    });\n  }\n  loadTexture(textureIndex) {\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const source = json.images[textureDef.source];\n    let loader = this.textureLoader;\n    if (source.uri) {\n      const handler = options.manager.getHandler(source.uri);\n      if (handler !== null)\n        loader = handler;\n    }\n    return this.loadTextureImage(textureIndex, source, loader);\n  }\n  loadTextureImage(textureIndex, source, loader) {\n    const parser = this;\n    const json = this.json;\n    const options = this.options;\n    const textureDef = json.textures[textureIndex];\n    const URL = self.URL || self.webkitURL;\n    let sourceURI = source.uri;\n    let isObjectURL = false;\n    let hasAlpha = true;\n    if (source.mimeType === \"image/jpeg\")\n      hasAlpha = false;\n    if (source.bufferView !== void 0) {\n      sourceURI = parser.getDependency(\"bufferView\", source.bufferView).then(function(bufferView) {\n        if (source.mimeType === \"image/png\") {\n          const colorType = new DataView(bufferView, 25, 1).getUint8(0, false);\n          hasAlpha = colorType === 6 || colorType === 4 || colorType === 3;\n        }\n        isObjectURL = true;\n        const blob = new Blob([bufferView], {type: source.mimeType});\n        sourceURI = URL.createObjectURL(blob);\n        return sourceURI;\n      });\n    } else if (source.uri === void 0) {\n      throw new Error(\"THREE.GLTFLoader: Image \" + textureIndex + \" is missing URI and bufferView\");\n    }\n    return Promise.resolve(sourceURI).then(function(sourceURI2) {\n      return new Promise(function(resolve, reject) {\n        let onLoad = resolve;\n        if (loader.isImageBitmapLoader === true) {\n          onLoad = function(imageBitmap) {\n            resolve(new three__WEBPACK_IMPORTED_MODULE_0__.CanvasTexture(imageBitmap));\n          };\n        }\n        loader.load(resolveURL(sourceURI2, options.path), onLoad, void 0, reject);\n      });\n    }).then(function(texture) {\n      if (isObjectURL === true) {\n        URL.revokeObjectURL(sourceURI);\n      }\n      texture.flipY = false;\n      if (textureDef.name)\n        texture.name = textureDef.name;\n      if (!hasAlpha)\n        texture.format = three__WEBPACK_IMPORTED_MODULE_0__.RGBFormat;\n      const samplers = json.samplers || {};\n      const sampler = samplers[textureDef.sampler] || {};\n      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearFilter;\n      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || three__WEBPACK_IMPORTED_MODULE_0__.LinearMipmapLinearFilter;\n      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || three__WEBPACK_IMPORTED_MODULE_0__.RepeatWrapping;\n      parser.associations.set(texture, {\n        type: \"textures\",\n        index: textureIndex\n      });\n      return texture;\n    });\n  }\n  assignTexture(materialParams, mapName, mapDef) {\n    const parser = this;\n    return this.getDependency(\"texture\", mapDef.index).then(function(texture) {\n      if (mapDef.texCoord !== void 0 && mapDef.texCoord != 0 && !(mapName === \"aoMap\" && mapDef.texCoord == 1)) {\n        console.warn(\"THREE.GLTFLoader: Custom UV set \" + mapDef.texCoord + \" for texture \" + mapName + \" not yet supported.\");\n      }\n      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {\n        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;\n        if (transform) {\n          const gltfReference = parser.associations.get(texture);\n          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);\n          parser.associations.set(texture, gltfReference);\n        }\n      }\n      materialParams[mapName] = texture;\n    });\n  }\n  assignFinalMaterial(mesh) {\n    const geometry = mesh.geometry;\n    let material = mesh.material;\n    const useVertexTangents = geometry.attributes.tangent !== void 0;\n    const useVertexColors = geometry.attributes.color !== void 0;\n    const useFlatShading = geometry.attributes.normal === void 0;\n    const useSkinning = mesh.isSkinnedMesh === true;\n    const useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;\n    const useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== void 0;\n    if (mesh.isPoints) {\n      const cacheKey = \"PointsMaterial:\" + material.uuid;\n      let pointsMaterial = this.cache.get(cacheKey);\n      if (!pointsMaterial) {\n        pointsMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.PointsMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(pointsMaterial, material);\n        pointsMaterial.color.copy(material.color);\n        pointsMaterial.map = material.map;\n        pointsMaterial.sizeAttenuation = false;\n        this.cache.add(cacheKey, pointsMaterial);\n      }\n      material = pointsMaterial;\n    } else if (mesh.isLine) {\n      const cacheKey = \"LineBasicMaterial:\" + material.uuid;\n      let lineMaterial = this.cache.get(cacheKey);\n      if (!lineMaterial) {\n        lineMaterial = new three__WEBPACK_IMPORTED_MODULE_0__.LineBasicMaterial();\n        three__WEBPACK_IMPORTED_MODULE_0__.Material.prototype.copy.call(lineMaterial, material);\n        lineMaterial.color.copy(material.color);\n        this.cache.add(cacheKey, lineMaterial);\n      }\n      material = lineMaterial;\n    }\n    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {\n      let cacheKey = \"ClonedMaterial:\" + material.uuid + \":\";\n      if (material.isGLTFSpecularGlossinessMaterial)\n        cacheKey += \"specular-glossiness:\";\n      if (useSkinning)\n        cacheKey += \"skinning:\";\n      if (useVertexTangents)\n        cacheKey += \"vertex-tangents:\";\n      if (useVertexColors)\n        cacheKey += \"vertex-colors:\";\n      if (useFlatShading)\n        cacheKey += \"flat-shading:\";\n      if (useMorphTargets)\n        cacheKey += \"morph-targets:\";\n      if (useMorphNormals)\n        cacheKey += \"morph-normals:\";\n      let cachedMaterial = this.cache.get(cacheKey);\n      if (!cachedMaterial) {\n        cachedMaterial = material.clone();\n        if (useSkinning)\n          cachedMaterial.skinning = true;\n        if (useVertexColors)\n          cachedMaterial.vertexColors = true;\n        if (useFlatShading)\n          cachedMaterial.flatShading = true;\n        if (useMorphTargets)\n          cachedMaterial.morphTargets = true;\n        if (useMorphNormals)\n          cachedMaterial.morphNormals = true;\n        if (useVertexTangents) {\n          cachedMaterial.vertexTangents = true;\n          if (cachedMaterial.normalScale)\n            cachedMaterial.normalScale.y *= -1;\n          if (cachedMaterial.clearcoatNormalScale)\n            cachedMaterial.clearcoatNormalScale.y *= -1;\n        }\n        this.cache.add(cacheKey, cachedMaterial);\n        this.associations.set(cachedMaterial, this.associations.get(material));\n      }\n      material = cachedMaterial;\n    }\n    if (material.aoMap && geometry.attributes.uv2 === void 0 && geometry.attributes.uv !== void 0) {\n      geometry.setAttribute(\"uv2\", geometry.attributes.uv);\n    }\n    mesh.material = material;\n  }\n  getMaterialType() {\n    return three__WEBPACK_IMPORTED_MODULE_0__.MeshStandardMaterial;\n  }\n  loadMaterial(materialIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const materialDef = json.materials[materialIndex];\n    let materialType;\n    const materialParams = {};\n    const materialExtensions = materialDef.extensions || {};\n    const pending = [];\n    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {\n      const sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];\n      materialType = sgExtension.getMaterialType();\n      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));\n    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {\n      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];\n      materialType = kmuExtension.getMaterialType();\n      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));\n    } else {\n      const metallicRoughness = materialDef.pbrMetallicRoughness || {};\n      materialParams.color = new three__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);\n      materialParams.opacity = 1;\n      if (Array.isArray(metallicRoughness.baseColorFactor)) {\n        const array = metallicRoughness.baseColorFactor;\n        materialParams.color.fromArray(array);\n        materialParams.opacity = array[3];\n      }\n      if (metallicRoughness.baseColorTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"map\", metallicRoughness.baseColorTexture));\n      }\n      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;\n      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;\n      if (metallicRoughness.metallicRoughnessTexture !== void 0) {\n        pending.push(parser.assignTexture(materialParams, \"metalnessMap\", metallicRoughness.metallicRoughnessTexture));\n        pending.push(parser.assignTexture(materialParams, \"roughnessMap\", metallicRoughness.metallicRoughnessTexture));\n      }\n      materialType = this._invokeOne(function(ext) {\n        return ext.getMaterialType && ext.getMaterialType(materialIndex);\n      });\n      pending.push(Promise.all(this._invokeAll(function(ext) {\n        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);\n      })));\n    }\n    if (materialDef.doubleSided === true) {\n      materialParams.side = three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide;\n    }\n    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;\n    if (alphaMode === ALPHA_MODES.BLEND) {\n      materialParams.transparent = true;\n      materialParams.depthWrite = false;\n    } else {\n      materialParams.transparent = false;\n      if (alphaMode === ALPHA_MODES.MASK) {\n        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;\n      }\n    }\n    if (materialDef.normalTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"normalMap\", materialDef.normalTexture));\n      materialParams.normalScale = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, -1);\n      if (materialDef.normalTexture.scale !== void 0) {\n        materialParams.normalScale.set(materialDef.normalTexture.scale, -materialDef.normalTexture.scale);\n      }\n    }\n    if (materialDef.occlusionTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"aoMap\", materialDef.occlusionTexture));\n      if (materialDef.occlusionTexture.strength !== void 0) {\n        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;\n      }\n    }\n    if (materialDef.emissiveFactor !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      materialParams.emissive = new three__WEBPACK_IMPORTED_MODULE_0__.Color().fromArray(materialDef.emissiveFactor);\n    }\n    if (materialDef.emissiveTexture !== void 0 && materialType !== three__WEBPACK_IMPORTED_MODULE_0__.MeshBasicMaterial) {\n      pending.push(parser.assignTexture(materialParams, \"emissiveMap\", materialDef.emissiveTexture));\n    }\n    return Promise.all(pending).then(function() {\n      let material;\n      if (materialType === GLTFMeshStandardSGMaterial) {\n        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);\n      } else {\n        material = new materialType(materialParams);\n      }\n      if (materialDef.name)\n        material.name = materialDef.name;\n      if (material.map)\n        material.map.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n      if (material.emissiveMap)\n        material.emissiveMap.encoding = three__WEBPACK_IMPORTED_MODULE_0__.sRGBEncoding;\n      assignExtrasToUserData(material, materialDef);\n      parser.associations.set(material, {type: \"materials\", index: materialIndex});\n      if (materialDef.extensions)\n        addUnknownExtensionsToUserData(extensions, material, materialDef);\n      return material;\n    });\n  }\n  createUniqueName(originalName) {\n    const sanitizedName = three__WEBPACK_IMPORTED_MODULE_0__.PropertyBinding.sanitizeNodeName(originalName || \"\");\n    let name = sanitizedName;\n    for (let i = 1; this.nodeNamesUsed[name]; ++i) {\n      name = sanitizedName + \"_\" + i;\n    }\n    this.nodeNamesUsed[name] = true;\n    return name;\n  }\n  loadGeometries(primitives) {\n    const parser = this;\n    const extensions = this.extensions;\n    const cache = this.primitiveCache;\n    function createDracoPrimitive(primitive) {\n      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {\n        return addPrimitiveAttributes(geometry, primitive, parser);\n      });\n    }\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const primitive = primitives[i];\n      const cacheKey = createPrimitiveKey(primitive);\n      const cached = cache[cacheKey];\n      if (cached) {\n        pending.push(cached.promise);\n      } else {\n        let geometryPromise;\n        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {\n          geometryPromise = createDracoPrimitive(primitive);\n        } else {\n          geometryPromise = addPrimitiveAttributes(new three__WEBPACK_IMPORTED_MODULE_0__.BufferGeometry(), primitive, parser);\n        }\n        cache[cacheKey] = {primitive, promise: geometryPromise};\n        pending.push(geometryPromise);\n      }\n    }\n    return Promise.all(pending);\n  }\n  loadMesh(meshIndex) {\n    const parser = this;\n    const json = this.json;\n    const extensions = this.extensions;\n    const meshDef = json.meshes[meshIndex];\n    const primitives = meshDef.primitives;\n    const pending = [];\n    for (let i = 0, il = primitives.length; i < il; i++) {\n      const material = primitives[i].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency(\"material\", primitives[i].material);\n      pending.push(material);\n    }\n    pending.push(parser.loadGeometries(primitives));\n    return Promise.all(pending).then(function(results) {\n      const materials = results.slice(0, results.length - 1);\n      const geometries = results[results.length - 1];\n      const meshes = [];\n      for (let i = 0, il = geometries.length; i < il; i++) {\n        const geometry = geometries[i];\n        const primitive = primitives[i];\n        let mesh;\n        const material = materials[i];\n        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {\n          mesh = meshDef.isSkinnedMesh === true ? new three__WEBPACK_IMPORTED_MODULE_0__.SkinnedMesh(geometry, material) : new three__WEBPACK_IMPORTED_MODULE_0__.Mesh(geometry, material);\n          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {\n            mesh.normalizeSkinWeights();\n          }\n          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleStripDrawMode);\n          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {\n            mesh.geometry = toTrianglesDrawMode(mesh.geometry, three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode);\n          }\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineSegments(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Line(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.LineLoop(geometry, material);\n        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {\n          mesh = new three__WEBPACK_IMPORTED_MODULE_0__.Points(geometry, material);\n        } else {\n          throw new Error(\"THREE.GLTFLoader: Primitive mode unsupported: \" + primitive.mode);\n        }\n        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {\n          updateMorphTargets(mesh, meshDef);\n        }\n        mesh.name = parser.createUniqueName(meshDef.name || \"mesh_\" + meshIndex);\n        assignExtrasToUserData(mesh, meshDef);\n        if (primitive.extensions)\n          addUnknownExtensionsToUserData(extensions, mesh, primitive);\n        parser.assignFinalMaterial(mesh);\n        meshes.push(mesh);\n      }\n      if (meshes.length === 1) {\n        return meshes[0];\n      }\n      const group = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      for (let i = 0, il = meshes.length; i < il; i++) {\n        group.add(meshes[i]);\n      }\n      return group;\n    });\n  }\n  loadCamera(cameraIndex) {\n    let camera;\n    const cameraDef = this.json.cameras[cameraIndex];\n    const params = cameraDef[cameraDef.type];\n    if (!params) {\n      console.warn(\"THREE.GLTFLoader: Missing camera parameters.\");\n      return;\n    }\n    if (cameraDef.type === \"perspective\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);\n    } else if (cameraDef.type === \"orthographic\") {\n      camera = new three__WEBPACK_IMPORTED_MODULE_0__.OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);\n    }\n    if (cameraDef.name)\n      camera.name = this.createUniqueName(cameraDef.name);\n    assignExtrasToUserData(camera, cameraDef);\n    return Promise.resolve(camera);\n  }\n  loadSkin(skinIndex) {\n    const skinDef = this.json.skins[skinIndex];\n    const skinEntry = {joints: skinDef.joints};\n    if (skinDef.inverseBindMatrices === void 0) {\n      return Promise.resolve(skinEntry);\n    }\n    return this.getDependency(\"accessor\", skinDef.inverseBindMatrices).then(function(accessor) {\n      skinEntry.inverseBindMatrices = accessor;\n      return skinEntry;\n    });\n  }\n  loadAnimation(animationIndex) {\n    const json = this.json;\n    const animationDef = json.animations[animationIndex];\n    const pendingNodes = [];\n    const pendingInputAccessors = [];\n    const pendingOutputAccessors = [];\n    const pendingSamplers = [];\n    const pendingTargets = [];\n    for (let i = 0, il = animationDef.channels.length; i < il; i++) {\n      const channel = animationDef.channels[i];\n      const sampler = animationDef.samplers[channel.sampler];\n      const target = channel.target;\n      const name = target.node !== void 0 ? target.node : target.id;\n      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;\n      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;\n      pendingNodes.push(this.getDependency(\"node\", name));\n      pendingInputAccessors.push(this.getDependency(\"accessor\", input));\n      pendingOutputAccessors.push(this.getDependency(\"accessor\", output));\n      pendingSamplers.push(sampler);\n      pendingTargets.push(target);\n    }\n    return Promise.all([\n      Promise.all(pendingNodes),\n      Promise.all(pendingInputAccessors),\n      Promise.all(pendingOutputAccessors),\n      Promise.all(pendingSamplers),\n      Promise.all(pendingTargets)\n    ]).then(function(dependencies) {\n      const nodes = dependencies[0];\n      const inputAccessors = dependencies[1];\n      const outputAccessors = dependencies[2];\n      const samplers = dependencies[3];\n      const targets = dependencies[4];\n      const tracks = [];\n      for (let i = 0, il = nodes.length; i < il; i++) {\n        const node = nodes[i];\n        const inputAccessor = inputAccessors[i];\n        const outputAccessor = outputAccessors[i];\n        const sampler = samplers[i];\n        const target = targets[i];\n        if (node === void 0)\n          continue;\n        node.updateMatrix();\n        node.matrixAutoUpdate = true;\n        let TypedKeyframeTrack;\n        switch (PATH_PROPERTIES[target.path]) {\n          case PATH_PROPERTIES.weights:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.NumberKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.rotation:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.QuaternionKeyframeTrack;\n            break;\n          case PATH_PROPERTIES.position:\n          case PATH_PROPERTIES.scale:\n          default:\n            TypedKeyframeTrack = three__WEBPACK_IMPORTED_MODULE_0__.VectorKeyframeTrack;\n            break;\n        }\n        const targetName = node.name ? node.name : node.uuid;\n        const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : three__WEBPACK_IMPORTED_MODULE_0__.InterpolateLinear;\n        const targetNames = [];\n        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {\n          node.traverse(function(object) {\n            if (object.isMesh === true && object.morphTargetInfluences) {\n              targetNames.push(object.name ? object.name : object.uuid);\n            }\n          });\n        } else {\n          targetNames.push(targetName);\n        }\n        let outputArray = outputAccessor.array;\n        if (outputAccessor.normalized) {\n          const scale = getNormalizedComponentScale(outputArray.constructor);\n          const scaled = new Float32Array(outputArray.length);\n          for (let j = 0, jl = outputArray.length; j < jl; j++) {\n            scaled[j] = outputArray[j] * scale;\n          }\n          outputArray = scaled;\n        }\n        for (let j = 0, jl = targetNames.length; j < jl; j++) {\n          const track = new TypedKeyframeTrack(targetNames[j] + \".\" + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation);\n          if (sampler.interpolation === \"CUBICSPLINE\") {\n            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {\n              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);\n            };\n            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;\n          }\n          tracks.push(track);\n        }\n      }\n      const name = animationDef.name ? animationDef.name : \"animation_\" + animationIndex;\n      return new three__WEBPACK_IMPORTED_MODULE_0__.AnimationClip(name, void 0, tracks);\n    });\n  }\n  createNodeMesh(nodeIndex) {\n    const json = this.json;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    if (nodeDef.mesh === void 0)\n      return null;\n    return parser.getDependency(\"mesh\", nodeDef.mesh).then(function(mesh) {\n      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);\n      if (nodeDef.weights !== void 0) {\n        node.traverse(function(o) {\n          if (!o.isMesh)\n            return;\n          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {\n            o.morphTargetInfluences[i] = nodeDef.weights[i];\n          }\n        });\n      }\n      return node;\n    });\n  }\n  loadNode(nodeIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const parser = this;\n    const nodeDef = json.nodes[nodeIndex];\n    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : \"\";\n    return function() {\n      const pending = [];\n      const meshPromise = parser._invokeOne(function(ext) {\n        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);\n      });\n      if (meshPromise) {\n        pending.push(meshPromise);\n      }\n      if (nodeDef.camera !== void 0) {\n        pending.push(parser.getDependency(\"camera\", nodeDef.camera).then(function(camera) {\n          return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);\n        }));\n      }\n      parser._invokeAll(function(ext) {\n        return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);\n      }).forEach(function(promise) {\n        pending.push(promise);\n      });\n      return Promise.all(pending);\n    }().then(function(objects) {\n      let node;\n      if (nodeDef.isBone === true) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Bone();\n      } else if (objects.length > 1) {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n      } else if (objects.length === 1) {\n        node = objects[0];\n      } else {\n        node = new three__WEBPACK_IMPORTED_MODULE_0__.Object3D();\n      }\n      if (node !== objects[0]) {\n        for (let i = 0, il = objects.length; i < il; i++) {\n          node.add(objects[i]);\n        }\n      }\n      if (nodeDef.name) {\n        node.userData.name = nodeDef.name;\n        node.name = nodeName;\n      }\n      assignExtrasToUserData(node, nodeDef);\n      if (nodeDef.extensions)\n        addUnknownExtensionsToUserData(extensions, node, nodeDef);\n      if (nodeDef.matrix !== void 0) {\n        const matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        matrix.fromArray(nodeDef.matrix);\n        node.applyMatrix4(matrix);\n      } else {\n        if (nodeDef.translation !== void 0) {\n          node.position.fromArray(nodeDef.translation);\n        }\n        if (nodeDef.rotation !== void 0) {\n          node.quaternion.fromArray(nodeDef.rotation);\n        }\n        if (nodeDef.scale !== void 0) {\n          node.scale.fromArray(nodeDef.scale);\n        }\n      }\n      parser.associations.set(node, {type: \"nodes\", index: nodeIndex});\n      return node;\n    });\n  }\n  loadScene(sceneIndex) {\n    const json = this.json;\n    const extensions = this.extensions;\n    const sceneDef = this.json.scenes[sceneIndex];\n    const parser = this;\n    const scene = new three__WEBPACK_IMPORTED_MODULE_0__.Group();\n    if (sceneDef.name)\n      scene.name = parser.createUniqueName(sceneDef.name);\n    assignExtrasToUserData(scene, sceneDef);\n    if (sceneDef.extensions)\n      addUnknownExtensionsToUserData(extensions, scene, sceneDef);\n    const nodeIds = sceneDef.nodes || [];\n    const pending = [];\n    for (let i = 0, il = nodeIds.length; i < il; i++) {\n      pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));\n    }\n    return Promise.all(pending).then(function() {\n      return scene;\n    });\n  }\n}\nfunction buildNodeHierachy(nodeId, parentObject, json, parser) {\n  const nodeDef = json.nodes[nodeId];\n  return parser.getDependency(\"node\", nodeId).then(function(node) {\n    if (nodeDef.skin === void 0)\n      return node;\n    let skinEntry;\n    return parser.getDependency(\"skin\", nodeDef.skin).then(function(skin) {\n      skinEntry = skin;\n      const pendingJoints = [];\n      for (let i = 0, il = skinEntry.joints.length; i < il; i++) {\n        pendingJoints.push(parser.getDependency(\"node\", skinEntry.joints[i]));\n      }\n      return Promise.all(pendingJoints);\n    }).then(function(jointNodes) {\n      node.traverse(function(mesh) {\n        if (!mesh.isMesh)\n          return;\n        const bones = [];\n        const boneInverses = [];\n        for (let j = 0, jl = jointNodes.length; j < jl; j++) {\n          const jointNode = jointNodes[j];\n          if (jointNode) {\n            bones.push(jointNode);\n            const mat = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n            if (skinEntry.inverseBindMatrices !== void 0) {\n              mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);\n            }\n            boneInverses.push(mat);\n          } else {\n            console.warn('THREE.GLTFLoader: Joint \"%s\" could not be found.', skinEntry.joints[j]);\n          }\n        }\n        mesh.bind(new three__WEBPACK_IMPORTED_MODULE_0__.Skeleton(bones, boneInverses), mesh.matrixWorld);\n      });\n      return node;\n    });\n  }).then(function(node) {\n    parentObject.add(node);\n    const pending = [];\n    if (nodeDef.children) {\n      const children = nodeDef.children;\n      for (let i = 0, il = children.length; i < il; i++) {\n        const child = children[i];\n        pending.push(buildNodeHierachy(child, node, json, parser));\n      }\n    }\n    return Promise.all(pending);\n  });\n}\nfunction computeBounds(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const box = new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\n  if (attributes.POSITION !== void 0) {\n    const accessor = parser.json.accessors[attributes.POSITION];\n    const min = accessor.min;\n    const max = accessor.max;\n    if (min !== void 0 && max !== void 0) {\n      box.set(new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(min[0], min[1], min[2]), new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(max[0], max[1], max[2]));\n      if (accessor.normalized) {\n        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n        box.min.multiplyScalar(boxScale);\n        box.max.multiplyScalar(boxScale);\n      }\n    } else {\n      console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n      return;\n    }\n  } else {\n    return;\n  }\n  const targets = primitiveDef.targets;\n  if (targets !== void 0) {\n    const maxDisplacement = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const vector = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    for (let i = 0, il = targets.length; i < il; i++) {\n      const target = targets[i];\n      if (target.POSITION !== void 0) {\n        const accessor = parser.json.accessors[target.POSITION];\n        const min = accessor.min;\n        const max = accessor.max;\n        if (min !== void 0 && max !== void 0) {\n          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));\n          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));\n          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));\n          if (accessor.normalized) {\n            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);\n            vector.multiplyScalar(boxScale);\n          }\n          maxDisplacement.max(vector);\n        } else {\n          console.warn(\"THREE.GLTFLoader: Missing min/max properties for accessor POSITION.\");\n        }\n      }\n    }\n    box.expandByVector(maxDisplacement);\n  }\n  geometry.boundingBox = box;\n  const sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n  box.getCenter(sphere.center);\n  sphere.radius = box.min.distanceTo(box.max) / 2;\n  geometry.boundingSphere = sphere;\n}\nfunction addPrimitiveAttributes(geometry, primitiveDef, parser) {\n  const attributes = primitiveDef.attributes;\n  const pending = [];\n  function assignAttributeAccessor(accessorIndex, attributeName) {\n    return parser.getDependency(\"accessor\", accessorIndex).then(function(accessor) {\n      geometry.setAttribute(attributeName, accessor);\n    });\n  }\n  for (const gltfAttributeName in attributes) {\n    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();\n    if (threeAttributeName in geometry.attributes)\n      continue;\n    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));\n  }\n  if (primitiveDef.indices !== void 0 && !geometry.index) {\n    const accessor = parser.getDependency(\"accessor\", primitiveDef.indices).then(function(accessor2) {\n      geometry.setIndex(accessor2);\n    });\n    pending.push(accessor);\n  }\n  assignExtrasToUserData(geometry, primitiveDef);\n  computeBounds(geometry, primitiveDef, parser);\n  return Promise.all(pending).then(function() {\n    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;\n  });\n}\nfunction toTrianglesDrawMode(geometry, drawMode) {\n  let index = geometry.getIndex();\n  if (index === null) {\n    const indices = [];\n    const position = geometry.getAttribute(\"position\");\n    if (position !== void 0) {\n      for (let i = 0; i < position.count; i++) {\n        indices.push(i);\n      }\n      geometry.setIndex(indices);\n      index = geometry.getIndex();\n    } else {\n      console.error(\"THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.\");\n      return geometry;\n    }\n  }\n  const numberOfTriangles = index.count - 2;\n  const newIndices = [];\n  if (drawMode === three__WEBPACK_IMPORTED_MODULE_0__.TriangleFanDrawMode) {\n    for (let i = 1; i <= numberOfTriangles; i++) {\n      newIndices.push(index.getX(0));\n      newIndices.push(index.getX(i));\n      newIndices.push(index.getX(i + 1));\n    }\n  } else {\n    for (let i = 0; i < numberOfTriangles; i++) {\n      if (i % 2 === 0) {\n        newIndices.push(index.getX(i));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i + 2));\n      } else {\n        newIndices.push(index.getX(i + 2));\n        newIndices.push(index.getX(i + 1));\n        newIndices.push(index.getX(i));\n      }\n    }\n  }\n  if (newIndices.length / 3 !== numberOfTriangles) {\n    console.error(\"THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.\");\n  }\n  const newGeometry = geometry.clone();\n  newGeometry.setIndex(newIndices);\n  return newGeometry;\n}\n\n\n\n//# sourceURL=webpack://esbuild-three-starter/./node_modules/three/examples/jsm/loaders/GLTFLoader.js?");

/***/ }),

/***/ "./src/js/GLStructure.js":
/*!*******************************!*\
  !*** ./src/js/GLStructure.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GLStructure\": () => (/* binding */ GLStructure)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n\nclass GLStructure {\n  constructor(container, canvas) {\n    this.container = container;\n    this.canvas = canvas;\n    this.vp = {\n      width: container.offsetWidth,\n      height: container.offsetHeight,\n      dpr: Math.min(window.devicePixelRatio, 2)\n    };\n    this.renderer = new three__WEBPACK_IMPORTED_MODULE_0__.WebGLRenderer({\n      antialias: true,\n      canvas,\n      stencil: false\n    });\n    this.renderer.setSize(this.vp.width, this.vp.height, false);\n    this.renderer.setPixelRatio(this.vp.dpr);\n    this.camera = new three__WEBPACK_IMPORTED_MODULE_0__.PerspectiveCamera(45, this.vp.width / this.vp.height, 0.1, 1e4);\n    this.camera.position.z = 50;\n    this.scene = new three__WEBPACK_IMPORTED_MODULE_0__.Scene();\n    this.clock = new three__WEBPACK_IMPORTED_MODULE_0__.Clock();\n    this.assets = {};\n    this.viewSize = this.getViewSizeAtDepth();\n    this.disposed = false;\n    this.tick = this.tick.bind(this);\n    this.init = this.init.bind(this);\n    this.onResize = this.onResize.bind(this);\n    this.addEvents();\n  }\n  addEvents() {\n    window.addEventListener(\"resize\", this.onResize);\n  }\n  dispose() {\n  }\n  getViewSizeAtDepth(depth = 0) {\n    const fovInRadians = this.camera.fov * Math.PI / 180;\n    const height = Math.abs((this.camera.position.z - depth) * Math.tan(fovInRadians / 2) * 2);\n    return {width: height * this.camera.aspect, height};\n  }\n  init() {\n  }\n  update() {\n  }\n  render() {\n    this.renderer.render(this.scene, this.camera);\n  }\n  onResize() {\n    this.vp.width = this.container.offsetWidth;\n    this.vp.height = this.container.offsetHeight;\n    this.vp.dpr = Math.min(window.devicePixelRatio, 2);\n    this.renderer.setSize(this.vp.width, this.vp.height, false);\n    this.camera.aspect = this.vp.width / this.vp.height;\n    this.camera.updateProjectionMatrix();\n    this.viewSize = this.getViewSizeAtDepth();\n  }\n  tick() {\n    if (this.disposed)\n      return;\n    this.update();\n    this.render();\n    requestAnimationFrame(this.tick);\n  }\n}\n\n\n//# sourceURL=webpack://esbuild-three-starter/./src/js/GLStructure.js?");

/***/ }),

/***/ "./src/js/index.js":
/*!*************************!*\
  !*** ./src/js/index.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var normalize_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! normalize.css */ \"./node_modules/normalize.css/normalize.css\");\n/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/css/index.css */ \"./src/css/index.css\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"./node_modules/three/build/three.module.js\");\n/* harmony import */ var _plugins__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./plugins */ \"./src/js/plugins/index.js\");\n/* harmony import */ var _GLStructure__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./GLStructure */ \"./src/js/GLStructure.js\");\n/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ \"./node_modules/three/examples/jsm/loaders/GLTFLoader.js\");\n\n\n\n\n\nlet canvas = document.getElementById(\"app-canvas\");\nlet wrapper = document.getElementById(\"app-wrapper\");\n\nclass GLApp extends _GLStructure__WEBPACK_IMPORTED_MODULE_3__.GLStructure {\n  constructor(container, canvas2) {\n    super(container, canvas2);\n    this.init();\n  }\n  loadAssets() {\n    let manager = new three__WEBPACK_IMPORTED_MODULE_4__.LoadingManager();\n    let loader = new three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_5__.GLTFLoader(manager);\n    loader.load(\"/static/models/cube.glb\", (gltf) => {\n      this.scene.add(gltf.scene);\n    });\n  }\n  init() {\n    let cubeGeo = new three__WEBPACK_IMPORTED_MODULE_4__.BoxBufferGeometry();\n    let cubeMat = new three__WEBPACK_IMPORTED_MODULE_4__.MeshNormalMaterial();\n    let cubeMesh = new three__WEBPACK_IMPORTED_MODULE_4__.Mesh(cubeGeo, cubeMat);\n    this.cube = cubeMesh;\n    this.scene.add(cubeMesh);\n    this.loadAssets();\n    this.tick();\n  }\n  update() {\n    this.cube.rotation.x += 0.01;\n    this.cube.rotation.y += 0.01;\n  }\n}\nnew GLApp(wrapper, canvas);\n\n\n//# sourceURL=webpack://esbuild-three-starter/./src/js/index.js?");

/***/ }),

/***/ "./src/js/plugins/events.js":
/*!**********************************!*\
  !*** ./src/js/plugins/events.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _unseenco_e__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @unseenco/e */ \"./node_modules/@unseenco/e/src/e.js\");\n\nconst evt = new _unseenco_e__WEBPACK_IMPORTED_MODULE_0__.default();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (evt);\n\n\n//# sourceURL=webpack://esbuild-three-starter/./src/js/plugins/events.js?");

/***/ }),

/***/ "./src/js/plugins/index.js":
/*!*********************************!*\
  !*** ./src/js/plugins/index.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"mouse\": () => (/* reexport safe */ _mouse__WEBPACK_IMPORTED_MODULE_0__.default),\n/* harmony export */   \"evt\": () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.default)\n/* harmony export */ });\n/* harmony import */ var _mouse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./mouse */ \"./src/js/plugins/mouse.js\");\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ \"./src/js/plugins/events.js\");\n\n\n\n\n//# sourceURL=webpack://esbuild-three-starter/./src/js/plugins/index.js?");

/***/ }),

/***/ "./src/js/plugins/mouse.js":
/*!*********************************!*\
  !*** ./src/js/plugins/mouse.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./events */ \"./src/js/plugins/events.js\");\n/* harmony import */ var js_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! js/utils */ \"./src/js/utils/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (new class {\n  constructor() {\n    this.on = 0;\n    this.off = 0;\n    this.events = {\n      move: \"mousemove\",\n      down: \"mousedown\",\n      up: \"mouseup\"\n    };\n    (0,js_utils__WEBPACK_IMPORTED_MODULE_1__.bindAll)(this, [\"onMove\", \"onDown\", \"onUp\"]);\n    this.addEvents();\n  }\n  addEvents() {\n    const {move, down, up} = this.events;\n    _events__WEBPACK_IMPORTED_MODULE_0__.default.on(move, window, this.onMove);\n    _events__WEBPACK_IMPORTED_MODULE_0__.default.on(down, window, this.onDown);\n    _events__WEBPACK_IMPORTED_MODULE_0__.default.on(up, window, this.onUp);\n    _events__WEBPACK_IMPORTED_MODULE_0__.default.on(\"click\", window, (e) => _events__WEBPACK_IMPORTED_MODULE_0__.default.emit(\"click\", e));\n  }\n  getPos(e) {\n    const x = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;\n    const y = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;\n    const target = e.target;\n    return {\n      x,\n      y,\n      target\n    };\n  }\n  onMove(e) {\n    const {x, y, target} = this.getPos(e);\n    _events__WEBPACK_IMPORTED_MODULE_0__.default.emit(\"mousemove\", {\n      x,\n      y,\n      target,\n      e\n    });\n  }\n  onDown(e) {\n    const {x, y, target} = this.getPos(e);\n    this.on = x;\n    _events__WEBPACK_IMPORTED_MODULE_0__.default.emit(\"mousedown\", {\n      x,\n      y,\n      target\n    });\n  }\n  onUp(e) {\n    const {x, target} = this.getPos(e);\n    this.off = x;\n    const click = Math.abs(this.off - this.on) < 10;\n    _events__WEBPACK_IMPORTED_MODULE_0__.default.emit(\"mouseup\", {\n      x,\n      target,\n      click\n    });\n  }\n}());\n\n\n//# sourceURL=webpack://esbuild-three-starter/./src/js/plugins/mouse.js?");

/***/ }),

/***/ "./src/js/utils/index.js":
/*!*******************************!*\
  !*** ./src/js/utils/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"bindAll\": () => (/* binding */ bindAll)\n/* harmony export */ });\nfunction bindAll(self, toBind) {\n  const l = toBind.length;\n  for (let i = 0; i < l; i += 1) {\n    self[toBind[i]] = self[toBind[i]].bind(self);\n  }\n}\n\n\n//# sourceURL=webpack://esbuild-three-starter/./src/js/utils/index.js?");

/***/ }),

/***/ "./node_modules/normalize.css/normalize.css":
/*!**************************************************!*\
  !*** ./node_modules/normalize.css/normalize.css ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://esbuild-three-starter/./node_modules/normalize.css/normalize.css?");

/***/ }),

/***/ "./src/css/index.css":
/*!***************************!*\
  !*** ./src/css/index.css ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://esbuild-three-starter/./src/css/index.css?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/js/index.js");
/******/ 	
/******/ })()
;